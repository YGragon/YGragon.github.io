<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[讲话技巧学习笔记]]></title>
    <url>%2F2018%2F02%2F25%2F%E8%AE%B2%E8%AF%9D%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本篇介绍了多种方式让你在人际交往中能够提升幽默感以及在临场时如何去说话能够不怯场！ 提升幽默感 提升幽默感的八种方式。 放松：世界上90%的演讲者讲的搞笑内容都不是第一次讲。霸占舞台，去练习！ 自嘲：把姿态放低，丑有时候也可以拿来自嘲 尴尬：尴尬经历是幽默的源泉，记录下来尴尬经历，下次可以使用 互动：找台下活跃，有特点的人互动 意外：情理之中，意料之外；感谢大家稀稀拉拉的掌声。这些年hs是我的好搭档，一直给我帮助和鼓励，如果我的成功，一定是我自己努力得来的.. 模仿：模仿当地方言 照应：前后呼应 双关：一词有两个意思，峰兄（丰胸），袭兄，平兄，龙兄，做女人挺好 临场发挥： PRS 结构 12345678910111213P：problem 阐述问题R：reason 分析问题S：solution 提出解决方案练习：1. “雾霾问题怎么办？”雾霾问题确实越来越严重了，这个问题的出现是由于一些工厂的不合理排放以及冬天不合理烧煤取暖导致的，针对这个问题，我们政府一直在积极的改进，我们加大了对工厂的检查力度，不合理的工厂坚决关闭，同时对于烧煤取暖的问题，我们也一直在跟进，正在推广燃气取暖的方式取代烧煤取暖，相信我们会还给大家蓝天白云的。2. “你的拖延症怎么越来越厉害？”最近一段时间我做事情确实有些慢了，是由于这件事情我很看重，我想要认真仔细的去完成它，前期进度缓慢是为了更好的去完全理解事情的核心，在核心功能完成后，后期进度肯定回提升上去的，请您放心。3. “感觉你不爱我了？”这段时间我承认很少理你，可能给你的感觉是不爱你了，但是你要相信我是很爱你的。这段时间我主要是在提升我的厨艺，想要给你亲手做一份大餐，在下次你有空的时候，邀请你来我家吃我亲手为你准备的大餐。 否新高： 123456789101112否：否定现存观点/方案新：提出新观点/方案高：站在更高的层次论证乔布斯、罗永浩练习：1. “你一辈子都会和我说实话吗？”我不能保证我讲的每一句话都是实话，但是我保证我不会伤害你，我觉得善意的谎言是美好生活的一部分2. “你最大的缺点是什么？”我最大的缺点是在写代码的时候会先写注释，这在项目紧急的情况下会浪费一些时间，但是不写注释，我怕下一个人读我的代码会不容易理解甚至是理解错，这块我也在努力提升自己的代码质量，让别人不用看注释就能知道我的代码写的是什么。 赶过猪： 123456789101112131415赶：感恩被邀请发言过：回顾过去美好的回忆猪：祝愿美好的未来适合聚会场合发言练习：1. “在升职后做就职感言”感谢黄总的邀请，过去一段时间周围小伙伴经常给我帮助和鼓励，我们一起学习和努力奋斗的日子是最美好的回忆，期待未来还能够和大家一起共同进步，共创辉煌！2. “在跟同学聚会的酒桌上即兴发言”感谢老黄同学的盛情邀请，那我就恭敬不如从命了。以前啊，我们一起放学打球，踢球，谁都不服输，现在估计再踢一场球或者是打一场球是不太容易了，那就祝我们在新的一年里都能发大财行大运！3. “在家长会上，老师邀请你发言”感谢王老师的邀请，非常感谢王老师对我儿的细心照顾才使得他有这般成绩和懂事，也希望老师能够继续用您的方式去培养他，让他成为国之栋梁，谢谢老师！ 快速组织语言能力 联想法：把几个不相关的事物联想起来 123456789练习：1. “狐狸、鱼、胡萝卜”这天，狐狸在森林里散步，当它走到一片田野上，发现一只兔子正在拔萝卜，它正准备攻击这只兔子，不巧，被兔子发现了，于是，狐狸和兔子之间展开了生死追击，狐狸追了兔子一路，追到了一条小河边不见了兔子的踪影，它找来找去还是没发现兔子的藏身之处，能看到的只有河里哈哈大笑的一只大头鱼，狐狸以为大头鱼在笑它，于是狐狸一头冲进河里想把鱼揍一顿，奈何它忘记了自己是不会游泳的，于是狐狸就这么死去了。2. “小明、明嫂、隔壁老王”有一天，小明被老师训斥了一顿后提前放学回家，回到家后，发现隔壁老王居然在大嫂家帮忙烧菜做菜....3. “公元前、你、吴彦祖”回想当前，就我的这个颜值，放在公元前，那绝对的是那个时代的国民老公，黄思聪和吴彦祖都排不上号。。。 赞美他人 发现对方的闪光点 三明治法： 先赞美她的闪光点中间给出建设性提升意见最后进行鼓励 八大招式 尽量赞美行为而不是外表 where where 哪里哪里漂亮啦 ​ 对方最在意的是什么就夸什么 成就自己先成就别人 ​ 放低自己 可以在朋友圈多赞美别人 ​ 背后赞美 背后赞美可以加强三者的关系，赞美者，传递者，接收者。 ​ 当众赞美 尤其是有他人为最重要的人在场时，记住不能漏人哦 ​ 赞美你希望对方做到的 用人不疑，疑人不用。比如：我的妈妈知道我放学后总想去玩个够再回来学习，有一天，她带我去见亲戚就在亲戚面前说，我的孩子，她每次放学回来都是先把作业做完了再出去玩，特别的听话。 赞美卡： 练习： 找三位家人或者同事，用上课程当中学到的赞美方法，为他们没人写一张赞美卡 美化声音 腹部用力 练习：CI，HE，数梨练习，经常做有氧运动（比如：跑步） ​ 抑扬顿挫 抑：音量放低，适合做播音节目，练习：再别康桥 扬：音量全部提升，适合打击学和主持人，练习：八百标兵奔北坡。。。，尾音上扬!（个位朋友，大家早上好）顿：停顿，给观众笑和思考的时间挫：转折，在声音和内容上强转折 ​ 让声音有温度、自信 经历挑战，霸占舞台 ​ 练习： 看综艺节目或者广告时模仿，如：羊羊羊，国窖1573 每天十分钟朗诵古诗 霸占舞台，讲的时候可以语速放慢感受自己声音的变化 设计演讲 极度专注 在极度安静的情况下思考 番茄工作法：40分钟思考，休息10分钟 ​ 使用工具 手机备忘录电脑脑图手写纸 ​ 思考三个问题 这次发言的目的是什么？ 传递信息：传达领导意见？娱乐：年会娱乐？说服：说服老板给予预算？激励：激励下属完成年度目标？ 提前和观众沟通 观众喜欢有趣和有料的 ​ 金包骨法： 金句：一句话总结你的观点 ​ 简单、具体、说明了给观众的好处 ​ 例如：坚持不要脸，世界才会给你脸 包装：解释金句骨架：逻辑结构，总分总，开头引起观众的注意力 ​ 开头：讲数据、讲一个吓人的观点、提出问题、讲一个故事、公交车报站（接下来我会从50分钟三大观 点…）、​ 中间：可以讲故事、​ 结尾：结尾需要感性一点 改改改： 完成比完美更重要先改1-2遍，再找朋友试讲！！ 克服紧张 为什么会紧张呢？ ​ 优胜劣汰，适者生存。紧张是好事情，让你更兴奋。 紧张 = 期望 / 准备 ​ 降低期望值，提高准备 降低期望 我过分在意自己一分一秒的表现，实际上，观众才不会在意 观众虽然都是领导，但对于我要讲的内容，他们并没有我专业，我可以碾压他们 一切都是最好的安排 加强准备 模拟真实的演讲环境 把猴子丢给观众 猴子：就是回顾之前的演讲，问问观众，和观众互动。 未雨绸缪，多做有挑战的事 从根本上克服紧张需要不断的去挑战自己的舒适区 11个克服过度紧张的tip 不要脸 讲故事 安排熟人在场 提前去场地 自嘲：坦诚自己紧张 讲舒服的内容，做自己，不用太模仿 自己准备演讲稿 演讲前让自己兴奋 享受意外 要么背熟到讲的一样，要么直接讲 面带微笑 表达的逻辑 把你的思想准确的传递给别人 一个基本点，三个逻辑架构： 把复杂问题简单化 总分总：最经典的逻辑结构，第一个【总】：吸引观众的注意力；【分】可以通过两种方式类整理，最后一个【总】：调动观众的情绪；重点在于中间的【分】 【分】的两种方法 平行结构：1、2、3 递进结构：过去现在将来，恋爱结婚离婚… 让观点更加生动的方式： 拆字法的应用 首字母提炼法： 关键词法：讲要讲的内容提炼关键字 提问法：层层递进法，例如同程CEO在融资时的演讲逻辑 为什么能赚钱？ 能赚多少钱？ 为什么事我们？ 能赚多久？ 回答问题：适合用 奥利奥+结构 练习奥利奥+结构的方式：特别适合用来回答问题 1. Opinion：观点 2. Reason：原因 3. Example：例子 4. Opinion+：升华 女朋友问你，你还爱我吗？ 是的，我很爱你亲爱的（先肯定观点），因为每次和你在一起的时候都有特别的温馨浪漫的感觉（原因） 还记得balala...（讲你和她的故事，例子）... （最后总结，升华）所以亲爱的我真的很爱你 练习奥利奥结构的方法： 找个朋友每天互相问一个问题，不管问什么，都不能否定，一定要用奥利奥回答。 介绍产品：适合用 ABC 结构 A: Advantage 优势B: Benefit 好处C: Case 案例 说服别人 书籍《影响力》 7大原则 对比原则美女之间的对比：当你看了一个比你之前认为很漂亮的女生之后再回头看你之前认为很好看的女生，你会觉的也不过如此。重量之间的对比：挑战之间的对比 互惠原则先舍才能得，大舍才能大得工作上 承诺和一致原则在有亲戚朋友在场的时候做出的承诺会大大降低被放鸽子的概率 社会认同原则人们会受到大众的影响两个饭馆，排队的比不排队的好 权威原则找到威信好的 喜好原则社群文化，让观众喜欢你自己人 短缺原则难得到是更好的。你是很有市场的。制造稀缺感。 马拉松报名练习 1自我介绍，了解到同事们最近半年都有请过病假，咨询专家了解到跑步能得到更好的身体，我和大家一样也很难坚持跑步。这是公司第一次举行的集体户外活动，而且这次活动也是公司十周年的重要组成部分。李总也会报名这次的活动哟，让我们跟随李总报名吧！为了奖励大家报名这次活动，公司特制了独有的T恤免费送给大家，还在犹豫什么，快快来报名这次的马拉松活动吧。 说话是个工具，请把这个工具用在帮助别人积极改变的地方。 演讲 = 演 + 讲 站姿：站起来讲，站要有站相，稳 手势：腰部一下–没气场，开 ​ 腰部在腹部到脖子–气场区​ 脖子以上—-超能区 走动：中间靠前的位置是存在位置最久的，目的 面部表情： 相由心生，心由相生 眼神交流，真诚的盯着观众的眼睛，持续时间为3秒，舞台很大，只需要看一片区域 练习方式：霸占舞台！！]]></content>
      <tags>
        <tag>说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 python 分析干货集中营的数据中提交干货内容最多的人]]></title>
    <url>%2F2018%2F02%2F19%2F%E5%88%A9%E7%94%A8-python-%E5%88%86%E6%9E%90%E5%B9%B2%E8%B4%A7%E9%9B%86%E4%B8%AD%E8%90%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%8F%90%E4%BA%A4%E5%B9%B2%E8%B4%A7%E5%86%85%E5%AE%B9%E6%9C%80%E5%A4%9A%E7%9A%84%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[分析的链接是：http://gank.io/api/data/all/1000/11000 表示返回的数据个数，1 表示页数，具体参数可在干货集中营的 API 文档中查看。干货集中营API文档 定义一个方法，进行计算返回的json数据中提交干货数据最多的人1234567891011121314151617181920212223242526272829303132333435363738394041def get_gank_info(ipaddress): &quot;&quot;&quot; 获取干货集中营的数据 &quot;&quot;&quot; r = requests.get(ipaddress) r = r.json() results = r[&apos;results&apos;] # 解析这个字段 authors, names, counts = [], [], [] # 得到所有作者 for result in results: name = result[&apos;who&apos;] if name != &apos;None&apos; and name != &apos;null&apos;: names.append(name) count = &#123;&#125; for i in names: # 和 get() 方法类似, 如果键不存在于字典中，将会添加键并将值设为默认值 # key -- 查找的键值。 # default -- 键不存在时，设置的默认键值。关键步骤 count[i] = count.setdefault(i,0) count[i] += 1 # print(count[i]) for k, v in count.items(): # 提交的干货大于5篇才保存 if v &gt;= 5: authors.append(str(k)) counts.append(v) print(str(k) + &apos; : &apos; + str(v)) # 可视化柱状图显示 my_style = LS(&apos;#333366&apos;, base_style=LCS) chart = pygal.Bar(style=my_style, x_label_rotation=45, show_lengend=False) chart.title = &quot;1000条干货数据中谁提供的最多&quot; chart.x_labels = authors chart.add(&apos;&apos;,counts) chart.render_to_file(&apos;gank_most_post_type.svg&apos;) 调用该方法即可get_gank_info(&quot;http://gank.io/api/data/all/1000/1&quot;)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 自定义 View 的绘制顺序]]></title>
    <url>%2F2018%2F01%2F29%2FAndroid-%E8%87%AA%E5%AE%9A%E4%B9%89-View-%E7%9A%84%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[学习来源扔物线大神 自定义 View 各个方法的绘制顺序 先执行构造方法 onFinishInflate():所有的子控件均被映射成 xml 后触发 onMeasure():View放置到父容器时调用，用于测量 View 的大小 onSizeChanged():在控件大小发生改变时调用。用于获取控件的宽和高度 onDraw(): 绘制图形界面 继承自 Viewsuper.onDraw() 前 or 后的区别继承自 View 在super.onDraw()前后是没有区别的，因为在 View 这个类里，onDraw() 是空实现。 继承自特定 View 基于已有控件的自定义绘制，就需要考虑super.onDraw()的顺序了 super.onDraw() 前 or 后的区别 在前 绘制代码会执行在原有内容的绘制之前，所以绘制的内容会被控件的原内容盖住。 使用场景：比如你可以通过在文字的下层绘制纯色矩形来作为「强调色」 在后 绘制代码会在原有内容绘制结束之后才执行，所以绘制内容就会盖住控件原来的内容。 继承自 ViewGroup ViewGroup 的绘制顺序：每一个 ViewGroup 会先调用自己的 onDraw()来绘制完自己的主体之后再去绘制它的子 View。这里的绘制子 View 是通过dispatchDraw()去绘制。View 和 ViewGroup 都有 dispatchDraw() 方法，不过由于 View 是没有子 View 的，所以一般来说 dispatchDraw() 这个方法只对 ViewGroup（以及它的子类）有意义。 super.onDraw() 前 or 后的区别 在前 绘制代码会执行在原有内容的绘制之前，如果有子 view ，子 View 会遮住之前绘制的内容。 在后 重写 dispatchDraw()，并在 super.dispatchDraw() 的下面写上你的绘制代码，这段绘制代码就会发生在子 View 的绘制之后，从而让绘制内容盖住子 View 了。 super.dispatchDraw() 前 or 后的区别同 super.onDraw() 完整的绘制过程会依次绘制一下几个内容 背景( drawBackground() )，这个方法是 private 的，不能重写，你如果要设置背景，只能用自带的 API 去设置 主体（onDraw()） 子 View（dispatchDraw()） 滑动边缘渐变和滑动条（4、5 步在这个方法中实现 onDrawForeground()） 前景 例如通常一个 LinearLayout 只有背景和子 View，那么它会先绘制背景再绘制子 View；一个 ImageView 有主体，有可能会再加上一层半透明的前景作为遮罩，那么它的前景也会在主体之后进行绘制 onDrawForeground() 在 onDrawForeground() 中，会依次绘制滑动边缘渐变、滑动条和前景。这个方法是 API 23 才引入的，所以在重写这个方法的时候要确认你的 minSdk 达到了 23，不然低版本的手机装上你的软件会没有效果 onDrawForeground() 前 or 后的区别 在前 如果你把绘制代码写在了 super.onDrawForeground() 的下面，绘制代码会在滑动边缘渐变、滑动条和前景之后被执行，那么绘制内容将会盖住滑动边缘渐变、滑动条和前景。例如：绘制 View 的前景色 在后 绘制内容都会盖住子 View，但被滑动边缘渐变、滑动条以及前景盖住。 draw() 总调度方法 除了 onDraw() dispatchDraw() 和 onDrawForeground() 之外，还有一个可以用来实现自定义绘制的方法： draw()，draw() 是绘制过程的总调度方法。一个 View 的整个绘制过程都发生在 draw() 方法里。背景、主体、子 View 、滑动相关以及前景的绘制，它们都是在 draw() 方法中执行。 super.draw() 前 or 后的区别 在前 绘制内容会被其他所有的内容盖住，包括背景 例如：给 EditText 加一个绿色的底，我们不能使用给它设置绿色背景色的方式，因为这就相当于是把它的背景替换掉，从而会导致下面的那条横线消失。这时候，我们可以重写它的 draw() 方法，然后在 super.draw() 的上方插入代码canvas.drawColor(Color.parseColor(&quot;#66BB6A&quot;)); // 涂上绿色即可完成 在后 它的绘制内容会盖住其他的所有绘制内容 ###]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 自定义 View clipXXX() 和 Matrix 入门]]></title>
    <url>%2F2018%2F01%2F26%2FAndroid-%E8%87%AA%E5%AE%9A%E4%B9%89-View-clipXXX-%E5%92%8C-Matrix-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学习来源扔物线大神 范围裁切clipRect( left, top, right, bottom )使用姿势： 1234canvas.save(); canvas.clipRect(left, top, right, bottom); canvas.drawBitmap(bitmap, x, y, paint); canvas.restore(); clipPath( path )使用姿势： 1234canvas.save(); canvas.clipPath(path1); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); 几何变换Canvas.translate(float dx, float dy) 平移参数里的 dx 和 dy 表示横向和纵向的位移，使用姿势： 1234canvas.save(); canvas.translate(200, 0); canvas.drawBitmap(bitmap, x, y, paint); canvas.restore(); Canvas.rotate(float degrees, float px, float py) 旋转 degrees 是旋转角度，方向是顺时针为正向； px和 py 是轴心的位置 Canvas.scale(float sx, float sy, float px, float py) 缩放sx sy 是横向和纵向的缩放倍数； px py 是缩放的轴心 skew(float sx, float sy) 错切（倾斜）sx 和 sy 是 x 方向和 y 方向的错切（倾斜）系数 使用 Matrix 做变换Matrix 做常见变换的方式： 创建 Matrix 对象； 调用 Matrix 的 pre/postTranslate/Rotate/Scale/Skew() 方法来设置几何变换； 使用 Canvas.setMatrix(matrix) 或 Canvas.concat(matrix) 来把几何变换应用到 Canvas。 把 Matrix 应用到 Canvas 有两个方法： Canvas.setMatrix(matrix) 和 Canvas.concat(matrix)。 Canvas.setMatrix(matrix)：用 Matrix 直接替换 Canvas 当前的变换矩阵，即抛弃 Canvas 当前的变换，改用 Matrix 的变换（注：不同的系统中 setMatrix(matrix) 的行为可能不一致，所以还是尽量用 concat(matrix) ）； Canvas.concat(matrix)：用 Canvas 当前的变换矩阵和 Matrix 相乘，即基于 Canvas 当前的变换，叠加上 Matrix 中的变换 使用姿势： 12345678910Matrix matrix = new Matrix();matrix.reset(); matrix.postTranslate(); matrix.postRotate();canvas.save(); canvas.concat(matrix); canvas.drawBitmap(bitmap, x, y, paint); canvas.restore();]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 自定义 View drawText() 入门]]></title>
    <url>%2F2018%2F01%2F25%2FAndroid-%E8%87%AA%E5%AE%9A%E4%B9%89-View-drawText-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学习来源：扔物线大神 Canvas 绘制文字drawText(String text, float x, float y, Paint paint)text 是文字内容，x 和 y 是文字的坐标。这个坐标并不是文字的左上角，而是一个与文字左下角比较接近的位置。参数中的 y ，指的是文字基线的位置，基线：让所有文字互相对齐的基准线。x 点并不是字母文字左边的位置，而是比它的左边再往左一点点，是为了给各个文字之间留出空隙 drawTextRun(CharSequence text, int start, int end, int contextStart, int contextEnd, float x, float y, boolean isRtl, Paint paint) 用的少drawTextOnPath(String text, Path path, float hOffset, float vOffset, Paint paint)沿着一条 Path 来绘制文字， hOffset 和 vOffset。它们是文字相对于 Path 的水平偏移量和竖直偏移量，利用它们可以调整文字的位置。 StaticLayout (CharSequence source, TextPaint paint, int width, Layout.Alignment align, float spacingmult, float spacingadd, boolean includepad)StaticLayout 支持换行，它既可以为文字设置宽度上限来让文字自动换行，也会在 \n 处主动换行。 width 是文字区域的宽度，文字到达这个宽度后就会自动换行；align 是文字的对齐方向；spacingmult 是行间距的倍数，通常情况下填 1 就好；spacingadd 是行间距的额外增加值，通常情况下填 0 就好；includeadd 是指是否在文字上下添加额外的空间，来避免某些过高的字符的绘制出现越界。 setTextSize(float textSize)设置字体大小 setTypeface(Typeface typeface)设置字体 setFakeBoldText(boolean fakeBoldText)是否使用伪粗体。因为它并不是通过选用更高 weight 的字体让文字变粗，而是通过程序在运行时把文字给「描粗」了。 setStrikeThruText(boolean strikeThruText)是否加删除线。 setUnderlineText(boolean underlineText)是否加下划线 setTextSkewX(float skewX)设置文字横向倾斜度 setTextScaleX(float scaleX)设置文字横向放缩 setLetterSpacing(float letterSpacing)设置字符间距。默认值是 0。 setTextAlign(Paint.Align align)设置文字的对齐方式。一共有三个值：LEFT CETNER 和 RIGHT。默认值为 LEFT。 setTextLocale(Locale locale) / setTextLocales(LocaleList locales)设置文字的语言，比如中文简体，中文繁体，英文等 Paint 相关getTextBounds(String text, int start, int end, Rect bounds)获取文字的显示范围。text 是要测量的文字，start 和 end 分别是文字的起始和结束位置，bounds 是存储文字显示范围的对象 float measureText(String text)测量文字的宽度并返回。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 自定义 View Paint 了解]]></title>
    <url>%2F2018%2F01%2F22%2FAndroid-%E8%87%AA%E5%AE%9A%E4%B9%89-View-Paint-%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[学习主要来源：扔物线大神 颜色基本颜色 setColor(int color) setARGB(int a, int r, int g, int b) setShader(Shader shader)：用于设置绘制颜色，在 Android 的绘制里使用 Shader ，并不直接用 Shader 这个类，而是用它的几个子类。具体来讲有 如下几个： LinearGradient 线性渐变、RadialGradient 辐射渐变、SweepGradient 扫描渐变、 BitmapShader（用 Bitmap 的像素来作为图形或文字的填充）、ComposeShader 混合着色器 LinearGradient 线性渐变：LinearGradient(float x0, float y0, float x1, float y1, int color0, int color1, Shader.TileMode tile)，x0 y0 x1 y1：渐变的两个端点的位置，color0 color1 是端点的颜色，tile：端点范围之外的着色规则，类型是 TileMode。TileMode 一共有 3 个值可选： CLAMP, MIRROR 和 REPEAT。CLAMP 会在端点之外延续端点处的颜色；MIRROR 是镜像模式；REPEAT 是重复模式 RadialGradient 辐射渐变：RadialGradient(float centerX, float centerY, float radius, int centerColor, int edgeColor, TileMode tileMode)。centerX centerY：辐射中心的坐标 ，radius：辐射半径 ，centerColor：辐射中心的颜色 ，edgeColor：辐射边缘的颜色 ，tileMode：辐射范围之外的着色模式。 SweepGradient 扫描渐变：SweepGradient(float cx, float cy, int color0, int color1)，cx cy ：扫描的中心，color0：扫描的起始颜色 ，color1：扫描的终止颜色 BitmapShader：BitmapShader(Bitmap bitmap, Shader.TileMode tileX, Shader.TileMode tileY)，bitmap：用来做模板的 Bitmap 对象 ，tileX：横向的 TileMode ，tileY：纵向的 TileMode。 ComposeShader : 混合着色器就是把两个 Shader 一起使用。ComposeShader() 在硬件加速下是不支持两个相同类型的 Shader 的，所以这里也需要关闭硬件加速才能看到效果。ComposeShader(Shader shaderA, Shader shaderB, PorterDuff.Mode mode)，shaderA, shaderB：两个相继使用的 Shader ，mode: 两个 Shader 的叠加模式，即 shaderA 和 shaderB 应该怎样共同绘制。它的类型是 PorterDuff.Mode PorterDuff.Mode：是用来指定两个图像共同绘制时的颜色策略的。就是说把源图像绘制到目标图像处时应该怎样确定二者结合后的颜色，而对于 ComposeShader(shaderA, shaderB, mode) 这个具体的方法，就是指应该怎样把 shaderB绘制在 shaderA 上来得到一个结合后的 Shader，具体看官方文档 滤镜 setColorFilter(ColorFilter colorFilter)：ColorFilter 并不直接使用，而是使用它的子类。它共有三个子类：LightingColorFilter PorterDuffColorFilter 和 ColorMatrixColorFilter。 LightingColorFilter(int mul, int add)：模拟光照效果，参数里的 mul 和 add 都是和颜色值格式相同的 int 值，其中 mul 用来和目标像素相乘，add 用来和目标像素相加 PorterDuffColorFilter：作用是使用一个指定的颜色和一种指定的 PorterDuff.Mode 来与绘制对象进行合成。它的构造方法是 PorterDuffColorFilter(int color, PorterDuff.Mode mode) 其中的 color 参数是指定的颜色， mode 参数是指定的 Mode。同样也是 PorterDuff.Mode ，不过和 ComposeShader 不同的是，PorterDuffColorFilter 作为一个 ColorFilter，只能指定一种颜色作为源，而不是一个 Bitmap ColorMatrixColorFilter：使用一个 ColorMatrix 来对颜色进行处理。 ColorMatrix 这个类，内部是一个 4x5 的矩阵，第三方库实现炫酷效果：StyleImageView PorterDuffColrFilter((int color, PorterDuff.Mode mode)：使用一个指定的颜色和一种指定的 PorterDuff.Mode 来与绘制对象进行合成 效果 Paint.setStrokeCap(Paint.Cap cap) 设置线头的形状。线头形状有三种：BUTT 平头、ROUND 圆头、SQUARE 方头。默认为 BUTT Paint.setStrokeJoin(Paint.Join join) :设置拐角的形状。有三个值可以选择：MITER 尖角、 BEVEL 平角和 ROUND 圆角。默认为 MITER。 Paint.setStrokeMiter(float miter) : 这个方法是对于 setStrokeJoin() 的一个补充，它用于设置 MITER 型拐角的延长线的最大值。这种补偿方案会有一个问题：如果拐角的角度太小，就有可能由于出现连接点过长的情况，所以为了避免意料之外的过长的尖角出现， MITER 型连接点有一个额外的规则：当尖角过长时，自动改用 BEVEL 的方式来渲染连接点。例如上图的这个尖角，在默认情况下是不会出现的，而是会由于延长线过长而被转为 BEVEL 型连接点。 miter limit 的默认值是 4，对应的是一个大约 29° 的锐角，默认情况下，大于这个角的尖角会被保留，而小于这个夹角的就会被「削成平头」 Paint. setDither(boolean dither) : 设置图像的抖动。在 Android 里使用起来也很简单，一行代码就搞定paint.setDither(true);只要加这么一行代码，之后的绘制就是加抖动的了。 Paint.setFilterBitmap(boolean filter) :设置是否使用双线性过滤来绘制 Bitmap 。图像在放大绘制的时候，默认使用的是最近邻插值过滤，这种算法简单，但会出现马赛克现象；而如果开启了双线性过滤，就可以让结果图像显得更加平滑 paint.setPathEffect(PathEffect effect) : 使用 PathEffect 来给图形的轮廓设置效果。对 Canvas 所有的图形绘制有效 Android 中的 6 种 PathEffect。PathEffect 分为两类，单一效果的 CornerPathEffect``DiscretePathEffect DashPathEffect PathDashPathEffect ，和组合效果的 SumPathEffect ComposePathEffect CornerPathEffect : 把所有拐角变成圆角,CornerPathEffect(float radius) 的参数 radius 是圆角的半径 DiscretePathEffect : 把线条进行随机的偏离，让轮廓变得乱七八糟。乱七八糟的方式和程度由参数决定。DiscretePathEffect(float segmentLength, float deviation) 的两个参数中， segmentLength 是用来拼接的每个线段的长度， deviation 是偏离量。 DashPathEffect ： DashPathEffect(float[] intervals, float phase) 中， 第一个参数 intervals 是一个数组，它指定了虚线的格式：数组中元素必须为偶数（最少是 2 个），按照「画线长度、空白长度、画线长度、空白长度」……的顺序排列，例如上面代码中的 20, 5, 10, 5 就表示虚线是按照「画 20 像素、空 5 像素、画 10 像素、空 5 像素」的模式来绘制；第二个参数 phase 是虚线的偏移量 PathDashPathEffect：PathDashPathEffect(Path shape, float advance, float phase, PathDashPathEffect.Style style)中， shape 参数是用来绘制的 Path ； advance 是两个相邻的 shape 段之间的间隔，不过注意，这个间隔是两个 shape 段的起点的间隔，而不是前一个的终点和后一个的起点的距离； phase 和 DashPathEffect 中一样，是虚线的偏移；最后一个参数 style，是用来指定拐弯改变的时候 shape 的转换方式。style 的类型为 PathDashPathEffect.Style ，是一个 enum ，具体有三个值 TRANSLATE：位移 ROTATE：旋转 MORPH：变体 SumPathEffect：这是一个组合效果类的 PathEffect 。它的行为特别简单，就是分别按照两种 PathEffect 分别对目标进行绘制 ComposePathEffect：这也是一个组合效果类的 PathEffect 。不过它是先对目标 Path 使用一个 PathEffect，然后再对这个改变后的 Path 使用另一个 PathEffect，ComposePathEffect(PathEffect outerpe, PathEffect innerpe) 中的两个 PathEffect 参数， innerpe 是先应用的， outerpe 是后应用的 setShadowLayer(float radius, float dx, float dy, int shadowColor)：在之后的绘制内容下面加一层阴影。radius 是阴影的模糊范围； dx dy 是阴影的偏移量； shadowColor 是阴影的颜色。 setMaskFilter(MaskFilter maskfilter) ： 为之后的绘制设置 MaskFilter。上一个方法 setShadowLayer() 是设置的在绘制层下方的附加效果；而这个 MaskFilter 和它相反，设置的是在绘制层上方的附加效果。MaskFilter 有两种： BlurMaskFilter 和 EmbossMaskFilte]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View 的工作原理]]></title>
    <url>%2F2018%2F01%2F03%2FAndroid-View-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android View 的工作原理 Android 开发艺术探索—-View的工作原理学习和思考总结。 初识 ViewRoot 和 DecorView ViewRoot 对应的是ViewRootImpl类，它是连接WindowManager和DecorView的桥梁，并且 View 的三大流程都是通过 ViewRoot 来完成的。 WindowManager 是用于管理整个 Android 的窗口（View），它能够管理窗口（View）的一些状态、属性、view 的添加、删除、更新等。 DecorView 是窗口的顶级 View。它其实是一个FrameLayout ，内部一般还会包含一个 LinearLayout ，上面是标题栏，下面是内容栏。View层的事件都先经过 DecorView ，然后才传递给我们的 View。 View 的三大流程是指：measure，layout， draw。measure 过程是用来测量 View 的宽高；layout 过程是用来测量 View 在父容器中的放置位置；draw 过程是将 View 绘制到屏幕上。 理解 MeasureSpecMeasureSpec MeasureSpec 在很大程度上决定了一个 View 的规格尺寸，之所以说很大程度是因为在决定 View 的规格的过程中会受到父容器的影响。因为在测量过程中，系统会将 View 的 LayoutParams 转为对应的 MeasureSpec ,然后再根据这个measureSpec 来测量出 View 的宽高。 LayoutParams : 是子控件控制自己在父控件中布局的一个类。例如子控件 TextView 想在父控件 LinearLayout 中显示，并且想子控件想距离父控件左边 20dp 的距离，或者是子控件想要居中显示，可以使用 LayoutParams 去控制。 MeasureSpec 代表一个 32 位 int 值，高两位代表 SpecMode，低 30 位代表 SpecSize 。SpecMode是指测量模式；SpecSize 是指某种测量模式下的 View 的规格大小。 SpecMode 测量模式有三种：UNSPECIFIED、EXACTLY、AT_MOST。 UNSPECIFIED 测量模式：父容器不对 View 有任何限制，View 是多大就给 View 多大的空间。 EXACTLY 测量模式：父容器已经检测出 View 所需要的精确大小的空间，这时候 View 的最终大小就是 SpecSize 所指定的值，它对应于 LayoutParams 中的 match_parent 和设置具体的数值。 AT_MOST 测量模式：父容器指定了一个可用大小的空间即 SpecSize，View 的最终大小不能大于这个值，它对应于 LayoutParams 中的 wrap_content MeasureSpec 和 LayoutParams 的关系 MeasureSpec 是用于测量 View 的规格，而我们在使用 View 的时候会设置 LayoutParams ,系统会根据设置的 LayoutParams 在父容器的约束下转换为 MeasureSpec。MeasureSpec 也不是唯一由 LayoutParams 决定的，LayoutParams 需要和父容器一起才能决定 View 的 MeasureSpec，从而进一步确定 View 的宽高。 当 View 采用固定宽高时，不管父容器的 MeasureSpec 是什么，View 的 MeasureSpec 都是 EXACTLY 模式，View 的大小遵循 LayoutParams 中的大小。 当 View 的宽高是 match_parent 时，如果父容器是 EXACTLY 模式，那么 View 也是 EXACTLY 模式且 View 的大小不会超过父容器的大小；如果父容器是 AT_MOST 模式，那么 View 也是 AT_MOST 模式且 View 的大小不会超过父容器的大小。 当 View 的宽高是 wrap_content 时，不管父容器是 EXACTLY 模式还是 AT_MOST 模式，View 的模式总是最大化并且不超过父容器的剩余空间 View 的工作流程 View 的工作流程主要是指 measure ， layout， draw 。measure 确定 View 的测量宽 / 高，layout确定 View 的最终宽 / 高 和四个顶点，draw 将 View 绘制到屏幕上。 measure 过程 分为 View 和 ViewGroup 两种情况。 原始 View 直接通过 measure 方法就完成了测量过程。而 measure 方法会去调用 View 的 onMeasure 方法。 onMeasure 方法源码： 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; setMeasuredDimension 方法会通过getDefaultSize方法得到宽高志并设置给 View 的宽高。 getDefaultSize 方法源码： 12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result; &#125; 该方法主要是返回 measureSpec 中的 specSize，而这个specSize 就是 View 的测量大小，之所以说是测量大小是因为 View 的最终大小是在 layout 阶段确定的，但是几乎所有的情况下 View 的测量大小和最终的大小是相等的。而getDefaultSize 方法的第一个参数是getSuggestedMinimumWidth方法或者getSuggestedMinimumHeight方法，那么接下来看看该方法做了哪些操作。 getSuggestedMinimumWidth 和 getSuggestedMinimumHeight 方法源码： 12345678protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); &#125; protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight()); &#125; getSuggestedMinimumWidth 方法先判断 View 是否设置背景，如果没有设置背景，那么返回 mMinWidth 所指定的值，如果设置了背景，那么返回 mMinWidth 和背景的最小宽度 二者之间的最大值。getSuggestedMinimumHeight 方法同理。 ViewGroup 先完成 ViewGroup 的测量，然后去遍历 ViewGroup 中子 View 的测量。由于 ViewGroup 是一个抽象类public abstract class ViewGroup extends View implements ViewParent, ViewManager {}，它没有重写 View 的 onMeasure 方法，但是它提供了一个叫 measureChildren 的方法 measureChildren 方法源码： 12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; measureChild 方法源码： 1234567891011protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; 从代码中可以看出主要是在 measureChild 方法中通过 getLayoutParams 方法 取出子控件的 LayoutParams ，然后再通过 getChildMeasureSpec 来获取子元素的 MeasureSpec , 接着将 MeasureSpec 直接传递给 View 的 measure 方法来进行测量。 Tip： View 的measure 过程和 Activity 的生命周期方法不是同步执行的。解决办法由四种： Activity / View 的 onWindowFocusChanged ，在该方法中 View 已经初始化完毕，需要注意该方法会被调用多次。 view.post(runnable)，通过 post 将一个 runnable 传递到消息队列的末尾，然后等待 Looper 调用此 runnable 的时候，View 也已经初始化好了。 ViewTreeObserver ，使用 ViewTreeObserver 的中国回掉完成该功能，比如使用 OnGlobalLayoutListener 接口。 view.measure(int widthMeasureSpec, int heightMeasureSpec)，手动对 View 进行 measure ，该方式较复杂。 layout 过程 layout 方法确定 View 本身的位置，而 layout 方法中的 onLayout 方法会确定所有子元素的位置。 layout 方法源码： 1234567891011121314151617181920212223242526272829303132333435363738394041public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); if (shouldDrawRoundScrollbar()) &#123; if(mRoundScrollbarRenderer == null) &#123; mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); &#125; &#125; else &#123; mRoundScrollbarRenderer = null; &#125; mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; &#125; 该方法先通过 setFrame 方法来设定 View 的四个顶点的位置，接着调用 onLayout 方法去确定子元素的位置。接下来是判断了该 View 是显示在圆形可穿戴设备上，这块是为了适配可穿戴设备吧。当布局改变时调用 OnLayoutChangeListener 接口中的 onLayoutChange 方法。 draw 过程 draw 过程是将 View 绘制到屏幕上面，View 的绘制过程遵循如下几步： 绘制背景 background.draw（canvas） 绘制自己（onDraw） 绘制 children （dispatchDraw） 绘制装饰（onDrawScrollBars） draw 方法源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas&apos; layers to prepare for fading * 3. Draw view&apos;s content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we&apos;re done... return; &#125; /* * Here we do the full fledged routine... * (this is an uncommon case where speed matters less, * this is why we repeat some of the tests that have been * done above) */ boolean drawTop = false; boolean drawBottom = false; boolean drawLeft = false; boolean drawRight = false; float topFadeStrength = 0.0f; float bottomFadeStrength = 0.0f; float leftFadeStrength = 0.0f; float rightFadeStrength = 0.0f; // Step 2, save the canvas&apos; layers int paddingLeft = mPaddingLeft; final boolean offsetRequired = isPaddingOffsetRequired(); if (offsetRequired) &#123; paddingLeft += getLeftPaddingOffset(); &#125; int left = mScrollX + paddingLeft; int right = left + mRight - mLeft - mPaddingRight - paddingLeft; int top = mScrollY + getFadeTop(offsetRequired); int bottom = top + getFadeHeight(offsetRequired); if (offsetRequired) &#123; right += getRightPaddingOffset(); bottom += getBottomPaddingOffset(); &#125; final ScrollabilityCache scrollabilityCache = mScrollCache; final float fadeHeight = scrollabilityCache.fadingEdgeLength; int length = (int) fadeHeight; // clip the fade length if top and bottom fades overlap // overlapping fades produce odd-looking artifacts if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123; length = (bottom - top) / 2; &#125; // also clip horizontal fades if necessary if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123; length = (right - left) / 2; &#125; if (verticalEdges) &#123; topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength())); drawTop = topFadeStrength * fadeHeight &gt; 1.0f; bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength())); drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f; &#125; if (horizontalEdges) &#123; leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength())); drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f; rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength())); drawRight = rightFadeStrength * fadeHeight &gt; 1.0f; &#125; saveCount = canvas.getSaveCount(); int solidColor = getSolidColor(); if (solidColor == 0) &#123; final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) &#123; canvas.saveLayer(left, top, right, top + length, null, flags); &#125; if (drawBottom) &#123; canvas.saveLayer(left, bottom - length, right, bottom, null, flags); &#125; if (drawLeft) &#123; canvas.saveLayer(left, top, left + length, bottom, null, flags); &#125; if (drawRight) &#123; canvas.saveLayer(right - length, top, right, bottom, null, flags); &#125; &#125; else &#123; scrollabilityCache.setFadeColor(solidColor); &#125; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers final Paint p = scrollabilityCache.paint; final Matrix matrix = scrollabilityCache.matrix; final Shader fade = scrollabilityCache.shader; if (drawTop) &#123; matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, right, top + length, p); &#125; if (drawBottom) &#123; matrix.setScale(1, fadeHeight * bottomFadeStrength); matrix.postRotate(180); matrix.postTranslate(left, bottom); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, bottom - length, right, bottom, p); &#125; if (drawLeft) &#123; matrix.setScale(1, fadeHeight * leftFadeStrength); matrix.postRotate(-90); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, left + length, bottom, p); &#125; if (drawRight) &#123; matrix.setScale(1, fadeHeight * rightFadeStrength); matrix.postRotate(90); matrix.postTranslate(right, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(right - length, top, right, bottom, p); &#125; canvas.restoreToCount(saveCount); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); &#125; 自定义 View 需要做出炫酷的效果，使用系统的控件是很难完成的，那么自定义 View 就是解决这个问题的。自定义 View 涉及到 View 的层次结构、事件分发、View 的工作原理等技术细节。 自定义的分类 继承 View 重写 onDraw 方法 继承 ViewGroup 派生特殊的 Layout 继承特定的 View 比如（TextView） 继承特定的 ViewGroup 比如（LinearLayout） 自定义 View 须知 让 View 支持 warp_content 因为直接继承 View 或者 ViewGroup 控件，如果不在 onMeasure 方法中对wrap_content 做特殊处理，wrap_content 和 match_parent 效果是一样的。 如果有必要，让你的 View 支持 padding 因为直接继承 View 或者 ViewGroup , 如果不在 draw 方法中对 View 的 padding 做处理，那么 padding 属性是不会起作用的。而且直接继承 ViewGroup 的控件还需要在 onMeasure 和 onLayout 中考虑 padding 和子元素 margin 对其造成的影响，不然将导致 padding 和子元素的 margin 都失效。 尽量不要再 View 中使用 Handler ，因为没有必要 因为 View 内部本身提供了 post 系列的方法，完全可以替代 Handler 的作用。 View 中如果由线程或者动画，需要及时停止，否则会造成内存泄露 View 带有滑动嵌套情况时，需要处理好滑动个冲突 自定义 View 示例 圆角图片（例子是网络上比较完善的，对比书中简单实现的例子，可以更好的学习） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapShader;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Matrix;import android.graphics.Paint;import android.graphics.Rect;import android.graphics.RectF;import android.graphics.Shader;import android.graphics.SweepGradient;import android.graphics.drawable.BitmapDrawable;import android.graphics.drawable.ColorDrawable;import android.graphics.drawable.Drawable;import android.net.Uri;import android.support.v7.widget.AppCompatImageView;import android.text.TextPaint;import android.util.AttributeSet;/** * 圆形图片 * 圆角 * 设置边框 * 设置边框颜色 * 设置边框渐变 */public class CircleImageView extends AppCompatImageView &#123; private static final ScaleType SCALE_TYPE = ScaleType.CENTER_CROP; private static final Bitmap.Config BITMAP_CONFIG = Bitmap.Config.ARGB_8888; private static final int COLORDRAWABLE_DIMENSION = 2; // 圆形边框的厚度默认值。 // 如果是0，则没有天蓝色渐变的边框。 private static final int DEFAULT_BORDER_WIDTH = 0; // 默认的圆形边框颜色 private static final int DEFAULT_BORDER_COLOR = Color.BLACK; private final RectF mDrawableRect = new RectF(); private final RectF mBorderRect = new RectF(); private final Matrix mShaderMatrix = new Matrix(); private final Paint mBitmapPaint = new Paint(); private final Paint mBorderPaint = new Paint(); private int mBorderColor = DEFAULT_BORDER_COLOR; private int mBorderWidth = DEFAULT_BORDER_WIDTH; private Bitmap mBitmap; private BitmapShader mBitmapShader; private int mBitmapWidth; private int mBitmapHeight; private float mDrawableRadius; private float mBorderRadius; private boolean mReady; private boolean mSetupPending; private final Paint mFlagBackgroundPaint = new Paint(); private final TextPaint mFlagTextPaint = new TextPaint(); private String mFlagText; private boolean mShowFlag = false; private Rect mFlagTextBounds = new Rect(); // 渐变----用于边框颜色的渐变 Shader mSweepGradient = null; public CircleImageView(Context context) &#123; super(context); init(); &#125; public CircleImageView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public CircleImageView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; // 默认给图片设置了裁剪的样式 super.setScaleType(SCALE_TYPE); mReady = true; if (mSetupPending) &#123; setup(); mSetupPending = false; &#125; &#125; @Override public ScaleType getScaleType() &#123; return SCALE_TYPE; &#125; @Override public void setScaleType(ScaleType scaleType) &#123; if (scaleType != SCALE_TYPE) &#123; // ScaleType 设置只能为CENTER_CROP throw new IllegalArgumentException(String.format( &quot;ScaleType %s not supported.&quot;, scaleType)); &#125; &#125; @Override public void setAdjustViewBounds(boolean adjustViewBounds) &#123; if (adjustViewBounds) &#123; throw new IllegalArgumentException( &quot;adjustViewBounds not supported.&quot;); &#125; &#125; /** * 设置支持wrap_content * @param widthMeasureSpec * @param heightMeasureSpec */ @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST)&#123; setMeasuredDimension(200,200); &#125;else if (widthSpecMode == MeasureSpec.AT_MOST)&#123; setMeasuredDimension(200, heightSpecSize); &#125;else if (heightMeasureSpec == MeasureSpec.AT_MOST)&#123; setMeasuredDimension(widthSpecSize, 200); &#125; &#125; /** * 核心 * @param canvas */ @Override protected void onDraw(Canvas canvas) &#123; if (getDrawable() == null) &#123; return; &#125; // 绘制圆形图片 canvas.drawCircle(getWidth() / 2, getHeight() / 2, mDrawableRadius, mBitmapPaint); // 有描边 if (mBorderWidth != 0) &#123; canvas.save(); // 画布整体顺时针旋转20° canvas.rotate(20, getWidth() / 2, getHeight() / 2); // 绘制外圆描边 canvas.drawCircle(getWidth() / 2, getHeight() / 2, mBorderRadius, mBorderPaint); canvas.restore(); &#125; if (mShowFlag &amp;&amp; mFlagText != null) &#123; canvas.drawArc(mBorderRect, 40, 100, false, mFlagBackgroundPaint); mFlagTextPaint.getTextBounds(mFlagText, 0, mFlagText.length(), mFlagTextBounds); canvas.drawText(mFlagText, getWidth() / 2, (float) ((3 + Math.cos((float) (Math.PI * 5 / 18))) * getHeight() / 4 + mFlagTextBounds.height() / 3), mFlagTextPaint); &#125; &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); setup(); &#125; /** * 获取边框的颜色 * @return */ public int getBorderColor() &#123; return mBorderColor; &#125; /** * 设置边框的颜色 * @param borderColor */ public void setBorderColor(int borderColor) &#123; if (borderColor == mBorderColor) &#123; return; &#125; mBorderColor = borderColor; mBorderPaint.setColor(mBorderColor); invalidate(); &#125; /** * 获取边框的宽度 * @return */ public int getBorderWidth() &#123; return mBorderWidth; &#125; /** * @param borderWidth * 圆形的边框厚度。 */ public void setBorderWidth(int borderWidth) &#123; if (borderWidth == mBorderWidth) &#123; return; &#125; mBorderWidth = borderWidth; setup(); &#125; /** * 设置bitmap * @return */ @Override public void setImageBitmap(Bitmap bm) &#123; super.setImageBitmap(bm); mBitmap = bm; setup(); &#125; /** * 设置drawable * @return */ @Override public void setImageDrawable(Drawable drawable) &#123; super.setImageDrawable(drawable); mBitmap = getBitmapFromDrawable(drawable); setup(); &#125; @Override public void setImageResource(int resId) &#123; super.setImageResource(resId); mBitmap = getBitmapFromDrawable(getDrawable()); setup(); &#125; /** * 设置路径 * @return */ @Override public void setImageURI(Uri uri) &#123; super.setImageURI(uri); mBitmap = getBitmapFromDrawable(getDrawable()); setup(); &#125; private Bitmap getBitmapFromDrawable(Drawable drawable) &#123; if (drawable == null) &#123; return null; &#125; if (drawable instanceof BitmapDrawable) &#123; return ((BitmapDrawable) drawable).getBitmap(); &#125; try &#123; Bitmap bitmap; if (drawable instanceof ColorDrawable) &#123; bitmap = Bitmap.createBitmap(COLORDRAWABLE_DIMENSION, COLORDRAWABLE_DIMENSION, BITMAP_CONFIG); &#125; else &#123; bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), BITMAP_CONFIG); &#125; Canvas canvas = new Canvas(bitmap); drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight()); drawable.draw(canvas); return bitmap; &#125; catch (OutOfMemoryError e) &#123; return null; &#125; &#125; /** * 核心 * 在构造方法执行完毕之后执行该方法 */ private void setup() &#123; if (!mReady) &#123; mSetupPending = true; return; &#125; if (mBitmap == null) &#123; return; &#125; // BitmapShader类用来渲染头像 mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // 图片画笔 mBitmapPaint.setAntiAlias(true); mBitmapPaint.setShader(mBitmapShader); // 边框画笔 mBorderPaint.setStyle(Paint.Style.STROKE); mBorderPaint.setAntiAlias(true); mBorderPaint.setColor(mBorderColor); mBorderPaint.setStrokeWidth(mBorderWidth); // 取的原图片的宽高 mBitmapHeight = mBitmap.getHeight(); mBitmapWidth = mBitmap.getWidth(); // 设置含边界显示区域，取的是CircleImageView的布局实际大小，为方形 mBorderRect.set(0, 0, getWidth(), getHeight()); // 计算外圆（包含描边）的半径 mBorderRadius = Math.min((mBorderRect.height() - mBorderWidth) / 2, (mBorderRect.width() - mBorderWidth) / 2); // 初始图片显示区域为mBorderRect mDrawableRect.set(mBorderWidth, mBorderWidth, mBorderRect.width() - mBorderWidth, mBorderRect.height() - mBorderWidth); // 计算内圆的半径 mDrawableRadius = Math.min(mDrawableRect.height() / 2, mDrawableRect.width() / 2); mFlagBackgroundPaint.setColor(Color.BLACK &amp; 0x66FFFFFF); mFlagBackgroundPaint.setFlags(TextPaint.ANTI_ALIAS_FLAG); mFlagTextPaint.setFlags(TextPaint.ANTI_ALIAS_FLAG); mFlagTextPaint.setTextAlign(Paint.Align.CENTER); mFlagTextPaint.setColor(Color.WHITE); mFlagTextPaint .setTextSize(getResources().getDisplayMetrics().density * 18); // 边框内的颜色渐变 mSweepGradient = new SweepGradient(getWidth() / 2, getHeight() / 2, new int[] &#123; Color.rgb(255, 255, 255), Color.rgb(1, 209, 255) &#125;, null); mBorderPaint.setShader(mSweepGradient); updateShaderMatrix(); invalidate(); &#125; /** * 这个函数为设置BitmapShader的Matrix参数，设置最小缩放比例，平移参数。 * 作用：保证图片损失度最小和始终绘制图片正中央的那部分 */ private void updateShaderMatrix() &#123; float scale; float dx = 0; float dy = 0; mShaderMatrix.set(null); if (mBitmapWidth * mDrawableRect.height() &gt; mDrawableRect.width() * mBitmapHeight) &#123; scale = mDrawableRect.height() / (float) mBitmapHeight; dx = (mDrawableRect.width() - mBitmapWidth * scale) * 0.5f; &#125; else &#123; scale = mDrawableRect.width() / (float) mBitmapWidth; dy = (mDrawableRect.height() - mBitmapHeight * scale) * 0.5f; &#125; // 设置缩放 mShaderMatrix.setScale(scale, scale); // 设置平移 mShaderMatrix.postTranslate((int) (dx + 0.5f) + mBorderWidth, (int) (dy + 0.5f) + mBorderWidth); mBitmapShader.setLocalMatrix(mShaderMatrix); &#125; public void setShowFlag(boolean show) &#123; mShowFlag = show; invalidate(); &#125; public void setFlagText(String text) &#123; mFlagText = text; invalidate(); &#125;&#125; 类似于 ViewPager 控件的 View 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207public class HorizontalScrollViewEx extends ViewGroup &#123; private static final String TAG = &quot;HorizontalScrollViewEx&quot;; private int mChildrenSize; private int mChildWidth; private int mChildIndex; // 分别记录上次滑动的坐标 private int mLastX = 0; private int mLastY = 0; // 分别记录上次滑动的坐标(onInterceptTouchEvent) private int mLastXIntercept = 0; private int mLastYIntercept = 0; private Scroller mScroller; private VelocityTracker mVelocityTracker; public HorizontalScrollViewEx(Context context) &#123; super(context); init(); &#125; public HorizontalScrollViewEx(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public HorizontalScrollViewEx(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; if (mScroller == null) &#123; mScroller = new Scroller(getContext()); // VelocityTracker 是跟踪触摸事件滑动速度的帮助类，用于实现flinging以及其它类似的手势 mVelocityTracker = VelocityTracker.obtain(); &#125; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean intercepted = false; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; // 采用外部拦截法处理滑动冲突 intercepted = false; if (!mScroller.isFinished()) &#123; // 为了优化滑动体验而加入 mScroller.abortAnimation(); intercepted = true; &#125; break; &#125; case MotionEvent.ACTION_MOVE: &#123; int deltaX = x - mLastXIntercept; int deltaY = y - mLastYIntercept; if (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123; // 父类需要处理该事件 intercepted = true; &#125; else &#123; intercepted = false; &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; intercepted = false; break; &#125; default: break; &#125; Log.d(TAG, &quot;intercepted=&quot; + intercepted); mLastX = x; mLastY = y; mLastXIntercept = x; mLastYIntercept = y; return intercepted; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; mVelocityTracker.addMovement(event); int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; if (!mScroller.isFinished()) &#123; mScroller.abortAnimation(); &#125; break; &#125; case MotionEvent.ACTION_MOVE: &#123; int deltaX = x - mLastX; int deltaY = y - mLastY; scrollBy(-deltaX, 0); break; &#125; case MotionEvent.ACTION_UP: &#123; // 当松开手的时候，会自动向两边滑动，具体向那边滑动要看当前所处的位置 int scrollX = getScrollX(); // 初始化滑动速率的单位 mVelocityTracker.computeCurrentVelocity(1000); // 获得横向速率 float xVelocity = mVelocityTracker.getXVelocity(); if (Math.abs(xVelocity) &gt;= 50) &#123; // 滑动方向 mChildIndex = xVelocity &gt; 0 ? mChildIndex - 1 : mChildIndex + 1; &#125; else &#123; mChildIndex = (scrollX + mChildWidth / 2) / mChildWidth; &#125; // 子元素最后的位置 mChildIndex = Math.max(0, Math.min(mChildIndex, mChildrenSize - 1)); int dx = mChildIndex * mChildWidth - scrollX; // 带有动画的滑动 smoothScrollBy(dx, 0); mVelocityTracker.clear(); break; &#125; default: break; &#125; mLastX = x; mLastY = y; return true; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measuredWidth = 0; int measuredHeight = 0; final int childCount = getChildCount(); measureChildren(widthMeasureSpec, heightMeasureSpec); int widthSpaceSize = MeasureSpec.getSize(widthMeasureSpec); int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int heightSpaceSize = MeasureSpec.getSize(heightMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); if (childCount == 0) &#123; // 没有子元素，则将自己的宽高设置为 0，0；此处应该是需要根据 LayoutParams 中的宽高来处理 setMeasuredDimension(0, 0); &#125; else if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123; // 如果宽高为 wrap_content，这里还需要考虑父控件的 padding 以及子控件的 margin final View childView = getChildAt(0); // 所有子元素的宽的和就是父控件的宽 measuredWidth = childView.getMeasuredWidth() * childCount; measuredHeight = childView.getMeasuredHeight(); setMeasuredDimension(measuredWidth, measuredHeight); &#125; else if (heightSpecMode == MeasureSpec.AT_MOST) &#123; // 如果高为 wrap_content final View childView = getChildAt(0); measuredHeight = childView.getMeasuredHeight(); setMeasuredDimension(widthSpaceSize, childView.getMeasuredHeight()); &#125; else if (widthSpecMode == MeasureSpec.AT_MOST) &#123; // 如果宽为 wrap_content final View childView = getChildAt(0); measuredWidth = childView.getMeasuredWidth() * childCount; setMeasuredDimension(measuredWidth, heightSpaceSize); &#125; &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childLeft = 0; final int childCount = getChildCount(); mChildrenSize = childCount; for (int i = 0; i &lt; childCount; i++) &#123; final View childView = getChildAt(i); if (childView.getVisibility() != View.GONE) &#123; final int childWidth = childView.getMeasuredWidth(); mChildWidth = childWidth; // 将子控件从左到右摆放 childView.layout(childLeft, 0, childLeft + childWidth, childView.getMeasuredHeight()); childLeft += childWidth; &#125; &#125; &#125; private void smoothScrollBy(int dx, int dy) &#123; mScroller.startScroll(getScrollX(), 0, dx, 0, 500); invalidate(); &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); &#125; &#125; @Override protected void onDetachedFromWindow() &#123; mVelocityTracker.recycle(); super.onDetachedFromWindow(); &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-学习笔记博客系统总结]]></title>
    <url>%2F2018%2F01%2F01%2FPython-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[学习笔记是《Python从入门到实践》书中的一个项目。书中会有一些错误，这里我已经修改过了，在Github上的项目是可以运行的。 项目需求 编写一个名为“学习笔记”Web应用程序，让用户能后记录感兴趣的主题，并在学习每个主题的过程中添加日志条目。“学习笔记”的主页对这个网站进行扫面，并邀请用户注册或登录。用户登录后，就可以创建主题，添加条目以及阅读既有条目。 开发环境 Django 2.0 Python 3.5.2 window 10 64位 调试浏览器-Chrome 62.0.3202.89版本 开发工具 Sublime Text 3 Tip: 我这里是在虚拟环境下开发，所以要查看 Django 的版本需要先激活虚拟环境 , 然后输入python -m django --version; 查看Python 版本只需在命令行窗口下输入python即可查看。 项目的开发前准备创建虚拟环境新建一个目录用于存放当前“学习笔记”项目的所有文件，在终端下切换到当前目录来创建虚拟环境，创建命令如下： python -m venv ll_env: 先是运行了venv模块，应使用它来创建了一个名为ll_env的虚拟环境。如果不能使用 venv 模块，那么可以尝试先安装 virtualenv。如果能使用 venv 模块，可以不安装 virtualenv. 安装virtualenvpip install --user virtualenv 激活虚拟环境建立了虚拟环境需要激活才能使用，所以使用下面的命令来激活它：各个平台可能会不一样，我这里是 window 平台 ll_env\Scriptes\activate, 停止虚拟环境可输入：deactivate命令 安装 Django因为我们是在虚拟环境中开发，所以 Django 也是在虚拟环境中安装，输入如下命令： pip install Django Tip:Django 仅在虚拟环境被激活的时候才可用 在 Django 中创建项目django-admin startproject leaning_log .: 注意别漏了末尾的. 创建数据库Django 将大部分的项目相关的信息都存储在数据库中，因此我们需要创建一个共Django使用的数据库。 python manage.py migrate 运行项目在做完以上内容后就可以运行项目了，但是此时运行项目得到的是 Django 主页 python manage.py sunserver，启动了服务器后，在浏览器中输入localhost:8000，8000表示端口号。如果没出现错误，应该能看到 Django 的主页。关闭服务器在命令行界面按住ctrl+c即可 有可能会出现端口号被占用，提示“That port is already use ”，可以重新执行命令pythonmanage.py runserver 8001,如果还提示端口被占用，可接着换端口去多次尝试。 创建应用程序Django 项目是由一系列的应用程序组成，他们协同工作，让项目成为一个整体。当前命令行窗口应该还是运行着服务器的。所以要重新打开一个命令行窗口，并切换到manage.py目录下，激活该虚拟环境，再执行命令 startapp ,命令如下 激活虚拟环境ll_env\Scripts\activate 运行应用程序python manage.py startapp leaning_logs 定义模型 leaning_logs/models.py模型就是一个类，包含属性和方法。模型中会定义外键，用于关联对应的对象，在这里的外键是用户，用于确定主题属于哪个用户，需要这么去定义外键 owner = models.ForeignKey(User, &quot;on_delete=models.CASCADE&quot;) 123456789101112131415161718192021222324252627from django.db import modelsfrom django.contrib.auth.models import Userclass Topic(models.Model): &quot;&quot;&quot;用户要学习的主题.&quot;&quot;&quot; text = models.CharField(max_length=200) date_added = models.DateTimeField(auto_now_add=True) # 外键是用户，可以通过这个外键确定这个主题属于哪个用户 owner = models.ForeignKey(User, &quot;on_delete=models.CASCADE&quot;) def __str__(self): &quot;&quot;&quot;返回模型的字符串表示&quot;&quot;&quot; return self.textclass Entry(models.Model): &quot;&quot;&quot;用户发表的文章&quot;&quot;&quot; # 外键是主题，可以通过这个外键去确定这个文章属于哪个主题 topic = models.ForeignKey(Topic, &quot;on_delete=models.CASCADE&quot;) text = models.TextField() date_added = models.DateTimeField(auto_now_add = True) class Meta: verbose_name_plural = &apos;entries&apos; def __str__(self): &quot;&quot;&quot;返回模型的字符串表示&quot;&quot;&quot; return self.text[:50] + &quot;...&quot; 激活模型 leaning_log/settings.py创建了模型（应用程序）需要激活，让 Django 将应用程序包含到项目中. 1234567891011121314151617# Application definitionINSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, # 第三方应用程序 &apos;bootstrap3&apos;, # 我的应用程序 &apos;leaning_logs&apos;, &apos;users&apos;,] 创建了模型之后需要让 Django 修改数据库，使其能够存储与模型相关的信息，因此需要再终端窗口中执行下面的命令： python manage.py makemigrations leaning_logs python manage.py migrate 当每次需要修改“学习笔记”管理的数据时，都才去如下三个步骤： 修改models.py 对leaning_logs调用makemigrations 让 Django 迁移项目 Django 管理网站创建超级用户Django 允许创建具备所有权限的用户—超级用户。 python manage.py createsuperuser, 根据提示输入用户名，邮箱地址，密码，确认密码 Tip:Django 并不存储你输入的密码，存储的是你输入密码的派生出来的一个字符串，所以不用担心你的密码会泄露 向管理网站注册模型 leaning_logs/admin.pyDjango 自动再管理网站中添加了一些模型，如 User 和 Group，但对于我们创建的模型，必须手动进行注册。 123456from django.contrib import adminfrom leaning_logs.models import Topic, Entry# 注册表单admin.site.register(Topic)admin.site.register(Entry) 在浏览器中输入localhost:8000/admin/，可以看到我们注册的模型了 Django 自动添加的模型。 Django shell输入一些数据后，就可以通过交互式终端去查看这些数据了，这里的中观交互环境称为 Django shell ，Django shell 是测试项目和排除故障的理想的方式。 进入终端python manage.py shell 通过 python 语法可以查看项目中的数据，例如想查看所有文章，可以这么写： 123topics = Topic.objects.all()for topic int topics: print(topic.id, topic) 每次修改模型后，需要重启 shell 才能看到修改的效果。window下退出 shell 的方法是按下 ctrl+z 再按下回车键 创建网页：主页使用Django 创建网页的过程通常分为三个阶段： 定义 URL 编写视图 编写模板 映射 URL，leaning_log/urls.py django 2. 0 版本可以使用 path 模块替代了 url 模块 先导入相应的模块 12345678from django.contrib import adminfrom django.urls import include, pathurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&apos;users/&apos;, include(&apos;users.urls&apos;,namespace=&apos;users&apos;)), path(r&apos;&apos;, include(&apos;leaning_logs.urls&apos;,namespace=&apos;leaning_logs&apos;)),] 在 leaning_logs 和 user 下创建 urls.py 文件因为在leaning_log/urls.py 中定义了路径, 所以需要在对应的应用程序下也要创建对一ing的文件，否则会报错，提示找不不到该文件。 分析每一条 url ，如url(r&#39;^topics/(?P&lt;topic_id&gt;\d+)/$&#39;, views.topic, name=&#39;topic&#39;), 开头的r可以让python将接下来的字符串视为原始字符串，不会转义 ^表示字符串的开头，末尾的$表示字符串的结束。主要匹配的就是这二者之间的内容 ?P&lt;topic_id&gt;将匹配的值存储到 topic_id 中。 \d+表示包含在两个斜杠内的任意数字都匹配 第二个参数是 url 对应的视图 第三个参数是 给 url 指定的名称 1234567891011121314151617181920212223242526272829303132333435363738--------------------------leaning_logs/urls.py 的内容如下----------------------------&quot;&quot;&quot;定义leaning_logs的URL模式&quot;&quot;&quot;from django.conf.urls import urlfrom . import viewsapp_name=&apos;leaning_log&apos;urlpatterns = [ # 主页 , ^开始匹配之后的内容, $结束匹配之前的内容 url(r&apos;^$&apos;, views.index, name=&apos;index&apos;), # 显示所有的主题 url(r&apos;^topics/$&apos;, views.topics, name=&apos;topics&apos;), # 特定主题的详细页面, ?P&lt;topic_id&gt;：将匹配的值存储在topic_id中，\d+：匹配任意数字 url(r&apos;^topics/(?P&lt;topic_id&gt;\d+)/$&apos;, views.topic, name=&apos;topic&apos;), # 用于添加新主题的网页 url(r&apos;^new_topic/$&apos;, views.new_topic, name=&apos;new_topic&apos;), # 用于添加新条目的页面 url(r&apos;^new_entry/(?P&lt;topic_id&gt;\d+)/$&apos;, views.new_entry, name=&apos;new_entry&apos;), # 用于编辑条目的页面 url(r&apos;^edit_entry/(?P&lt;entry_id&gt;\d+)/$&apos;, views.edit_entry, name=&apos;edit_entry&apos;),]-------------------------- user/urls.py 的内容如下-------------------from django.conf.urls import urlfrom django.contrib.auth.views import loginfrom . import viewsapp_name=&apos;leaning_log&apos;urlpatterns = [ # 登录页面. template_name表示使用的是模板中的登录页面， url(r&apos;^login/$&apos;, login, &#123;&apos;template_name&apos;: &apos;users/login.html&apos;&#125;, name=&apos;login&apos;), # 退出登录. url(r&apos;^logout/$&apos;, views.logout_view, name=&apos;logout&apos;), # 注册页面. url(r&apos;^register/$&apos;, views.register, name=&apos;register&apos;),] 编写视图仅展示 leaning_logs/views.py，更多的内容可以查看源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from django.shortcuts import renderfrom django.http import HttpResponseRedirect, Http404from django.urls import reversefrom django.contrib.auth.decorators import login_requiredfrom .models import Topic, Entryfrom .forms import TopicForm, EntryFormdef index(request): &quot;&quot;&quot;学习笔记的主页&quot;&quot;&quot; return render(request, &apos;leaning_logs/index.html&apos;)@login_requireddef topics(request): &quot;&quot;&quot;显示所有的主题，login_required：加入登录验证，owner=request.user才能查看主题列表&quot;&quot;&quot; topics = Topic.objects.filter(owner=request.user).order_by(&apos;date_added&apos;) # 将结果存在context字典中 context = &#123;&apos;topics&apos;:topics&#125; return render(request, &apos;leaning_logs/topics.html&apos;, context)@login_requireddef topic(request, topic_id): &quot;&quot;&quot;显示单个主题及其所有的条目&quot;&quot;&quot; topic = Topic.objects.get(id=topic_id) # 确认请求的主题属于当前用户 if topic.owner != request.user: raise Http404 # -date_added -表示按时间降序显示 entries = topic.entry_set.order_by(&apos;-date_added&apos;) context = &#123;&apos;topic&apos;:topic, &apos;entries&apos;:entries&#125; return render(request, &apos;leaning_logs/topic.html&apos;, context)@login_requireddef new_topic(request): &quot;&quot;&quot;添加新主题&quot;&quot;&quot; if request.method != &apos;POST&apos;: # 未提交数据：创建一个新表单 form = TopicForm() else: # POST 提交的数据，对数据进行处理 form =TopicForm(request.POST) if form.is_valid(): # 先修改主题，再保存到数据库中 new_topic = form.save(commit=False) # 将当前修改主题的人变为新的话题所有者 new_topic.owner = request.user # 保存到数据库 new_topic.save() # 返回主页 return HttpResponseRedirect(reverse(&apos;leaning_logs:topics&apos;)) context = &#123;&apos;form&apos;:form&#125; return render(request, &apos;leaning_logs/new_topic.html&apos;, context)@login_requireddef new_entry(request, topic_id): &quot;&quot;&quot;在特定的主题重添加条目&quot;&quot;&quot; topic = Topic.objects.get(id=topic_id) if request.method != &apos;POST&apos;: # 未提交数据，创建一个空表单 form = EntryForm() else: # POST 提交的数据，对数据进行处理 form = EntryForm(data = request.POST) if form.is_valid(): new_entry = form.save(commit=False) new_entry.topic = topic new_entry.save() return HttpResponseRedirect(reverse(&apos;leaning_logs:topic&apos;, args=[topic_id])) context = &#123;&apos;topic&apos;:topic, &apos;form&apos;:form&#125; return render(request, &apos;leaning_logs/new_entry.html&apos;, context)@login_requireddef edit_entry(request, entry_id): &quot;&quot;&quot;编辑既有的条目&quot;&quot;&quot; entry = Entry.objects.get(id=entry_id) topic = entry.topic if topic.owner != request.user: raise Http404 if request.method != &apos;POST&apos;: # 初次请求，使用当前条目填充表单 form = EntryForm(instance=entry) else: # POST提交的数据，对数据进行处理 form = EntryForm(instance=entry, data=request.POST) if form.is_valid(): form.save() return HttpResponseRedirect(reverse(&apos;leaning_logs:topic&apos;,args=[topic.id])) context = &#123;&apos;entry&apos;:entry, &apos;topic&apos;:topic, &apos;form&apos;:form&#125; return render(request, &apos;leaning_logs/edit_entry.html&apos;,context) 编写模板仅写其中的一个模板—leaning_logs/templates/leaning_logs/topic.html，更多内容查看项目。这块主要是 html 的相关知识 1234567891011121314151617181920212223242526272829303132333435&#123;% extends &apos;leaning_logs/base.html&apos; %&#125;&#123;% block header %&#125; &lt;h3&gt;&#123;&#123; topic&#125;&#125;&lt;/h3&gt;&#123;% endblock header %&#125;&#123;% block content %&#125; &lt;p&gt; &lt;a href=&quot;&#123;% url &apos;leaning_logs:new_entry&apos; topic.id %&#125;&quot;&gt;添加新的笔记 &lt;/a&gt; &lt;/p&gt; &lt;ul&gt; &#123;% for entry in entries %&#125; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h4&gt; &#123;&#123; entry.date_added|date:&apos;M d, Y H:i&apos; &#125;&#125; &lt;small&gt; &lt;a href=&quot;&#123;% url &apos;leaning_logs:edit_entry&apos; entry.id %&#125;&quot;&gt;编辑&lt;/a&gt; &lt;/small&gt; &lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &#123;&#123; entry.text|linebreaks &#125;&#125; &lt;/div&gt; &lt;!-- panel --&gt; &lt;/div&gt; &#123;% empty %&#125; 当前主题下还没有笔记哦~，快去记录你的人生吧！ &#123;% endfor %&#125; &lt;/ul&gt;&#123;% endblock content %&#125; 用户系统也可以看作一个应用程序，所以和上面的 leaning_logs 是一样的。 实现思路是一样的，项目地址是Leaning_log]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在北京一周年]]></title>
    <url>%2F2017%2F12%2F19%2F%E5%86%99%E5%9C%A8%E5%8C%97%E4%BA%AC%E4%B8%80%E5%91%A8%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[来北京去年12月19号，考完试后回了趟家，从家里到学校后就来北京报道了，在北京一家做手机主题的公司实习3500一个月，没来北京之前心里想着肯定是要在北京过一段时间的地下室生活了。来了北京之后有铁柱(也是在这家公司实习的朋友)，鑫哥(很好的学长)等人的照顾，庆幸没住到地下室，非常感谢这些朋友。 实习做的是测试，原本是实习三个月，后来想着能够在公司多学一下技术就在公司多待了两个月，在公司学到很多知识，也见识了职场的斗争。在实习末段，由于一些原因，我选择了离开这家公司。公司的同事都特别好，技术总监更是对我关照有加，非常感谢这些朋友！ 暂时离开北京辞职后（虽然是实习生但是技术总监是希望我留下的），回到学校时应该时6月初，就剩一个月就毕业了，大四将近一整年都在外面过，好多朋友都没好好叙叙旧，喜欢的篮球都没怎么打。回到学校后就做毕设、有时间就和朋友聚聚。 这时候已经不是春招了，来学校招聘的公司已经没有几个了，偶尔零星来一两个公司，但都不是自己的菜。也就释然了，好好放松等毕业后再找找（当时还是太年轻啊）。 转眼就毕业了，当时再北京的房租还租着，所以毕业后就来了北京，这时候是6月30号。在合租屋边学习边找工作，一顿海投了简历，收到面试机会的少之又少。原因可能是： 自己是应届生，没工作经验，没人要 已经过了招聘高峰期，公司人员已满 每次面试回来都做了总结，但是面试了几家还是没面试上。这时候已经是7月13号了。我是南方人，想着再北京再找几天要是没找到就去南方试试机会，正好一个我喜欢的女生在杭州那边，杭州互联网机会这几年也不错，于是，打包行李去了杭州。 说实话，这时候口袋里真的快没钱了，去杭州住的是青年旅社20块一天的那种，团购了5天，在杭州的萧山那边住下了。杭州的招聘机会比北京少很多，而且有些培训机构一不小心就会掉入他们陷阱，在杭州海投了简历两天后才收到一个面试邀请，这家公司是创业公司，崇拜阿里文化。但是薪水给的不是很理想–转正3000，放弃后我去了趟嘉兴，那个女生在那边，找了她，吃了她做的饭，那是那段时间吃过最香的饭了。辗转了杭州几个地方，最后还是没找到合适的工作。 有个上海朋友让我去上海那边碰碰运气，我思考了一个晚上，买了回程的票。找工作还是需要先自己有足够的能力，所以回来了。 又回来北京回来的原因也有一部分原因是北京的房租还得接着交啊，签的合同是一年，到期是今年的9月份。回到北京是7月21号，回来后，把出去面试的过程做了总结，并把自己薄弱的地方，做了很多功课。停止投递简历，在发疯似的做功课一周后感觉自己可以出去找工作试试了。 这时候大概是7月25号，投出去的简历有了回复，收到2个面试，出去面了下，都没得到回复，这时候的心是慌的，慌的只有自己知道。房租快道要交的日期了，口袋真的没钱了，不敢和家里要钱，朋友问我工作怎样，我都只能慌张应答。好在26号面试了一家公司，公司方面可能也是有人要辞职，所以入职很快。入职的是小公司很多福利都没有，但是能够入职，我已经很感谢了。 往后一段时间现在还在这家公司，公司小，能学到很多东西，技术总监人很nice，有什么问题他会告诉你思路。虽然现在每天都很辛苦，但是有奋斗的目标（倩儿）就不会太迷茫。感谢目前遇到的所有人，谢谢你们。 我是做Android开发，目前掌握好 Android 开发是重点，这几天有空闲时间学了下 Python，也是想着多掌握一门技术，下次找工作会更有把握一些，加油！ 北京昌平区回龙观 2017年12月19日21:36:42]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据可视化]]></title>
    <url>%2F2017%2F12%2F12%2FPython%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据可视化指的是通过可视化表示来探索数据，它与数据挖掘紧密相关，而数据挖掘是指使用代码来探索数据集的规律和关联，数据集可以是用一行代码就能表示的小型数字列表，也可以是数以吉字节的数据。 matplotlib是一个数学绘图库，利用这个工具能够厚制作简单的图表。 Pygal是专注于生成适合在数字设备上显示的图表，通过使用 Pygal 可在用户图表交互时突出元素以及调整其大小，还可以轻松地调整整个图表的尺寸，使其适合在微型智能手表或者矩形显示器上显示。 安装matplotlib、Pygal window 环境下安装 matplotlib 先安装Visual Studio，打开https://dev.windows.com/,点击Downloads，再查找Visual Studio Community下载运行并安装 访问https:pypi.python.org/pypi/matplotlib,找到与你使用的Python版本匹配的扩展名为.whl文件，下载之 将下载的.whl文件复制到你的项目文件夹，在该文件夹下打开命令窗口（ctrl+鼠标右键，选择在此处打开命令窗口） cd python_work python -m pip install --user matplotlib-1.4.3-cp35-none-win32.whl 安装完成后打开一个命令窗口，进入 python 环境，输入：import matplotlib，如果没有报错则安装成功 windows 环境下安装 Pygal python -m pip install --user pygal==2.4 绘制折线图 绘制一个平方数序列1、4、9、16、25的图表 123456789101112131415161718# 导入模块 pyplotimport matplotlib.pyplot as plt# 输入的数值input_value = [1, 2, 3, 4, 5]# 对应的输入数值的平方squares = [1, 4, 9, 16, 25]# plot 函数根据给定的参数去绘制图形，linewidth=5 表示线的粗细plt.plot(input_value, squares, linewidth=5)# 设置图表标题和文字大小，并给坐标轴加上标签plt.title(&quot;Square Numbers&quot;, fontsize = 24)plt.xlabel(&quot;Value&quot;, fontsize = 14)plt.ylabel(&quot;Square of Value&quot;, fontsize = 14)# 设置刻度标记的字体大小plt.tick_params(axis = &apos;both&apos;, labelsize = 14)plt.show() 结果 TODO: 上传图片 plot(input_value, squares, linewidth=5)函数根据给定的参数去绘制图形，参数1：输入的内容，参数2：输入的内容对应的输出内容，参数3：线的粗细 使用 scatter() 绘制散点图并设置样式 绘制一个平方数序列为1~1000以内数平方根的散点图 1234567891011121314151617181920212223242526272829303132333435import matplotlib.pyplot as plt# 1~1000 的数值x_values = list(range(1,1000))# 对应值的结果y_values = [x**2 for x in x_values]# s 表示线的粗细, edgecolor=&apos;none&apos;表示删除数据点的轮廓, c = &apos;red&apos; 修改线条颜色# plt.scatter(x_values, y_values, s = 40)# plt.scatter(x_values, y_values, edgecolor=&apos;none&apos;, s = 40)# plt.scatter(x_values, y_values, c = &apos;red&apos;, edgecolor=&apos;none&apos;, s = 40)# 颜色值还可以用RGB表示，值越接近0，指定的颜色越深，越接近1指定的颜色越浅# plt.scatter(x_values, y_values, c = (0, 0, 0.8), edgecolor=&apos;none&apos;, s = 40)# 将参数c设置成y值列表，用参数cmap告诉pyplot使用哪个颜色映射# c = y_values, cmap = plt.cm.Blues 将y值较小的点显示为浅蓝色，将 y 值较大的设置为深蓝色plt.scatter(x_values, y_values, c = y_values, cmap = plt.cm.Blues, edgecolor=&apos;none&apos;, s = 40)# 设置图表标签，坐标轴标签plt.title(&quot;Square Numbers&quot;, fontsize = 24)plt.xlabel(&quot;Value&quot;, fontsize = 14)plt.ylabel(&quot;Square on Value &quot;, fontsize = 14)# 设置标记刻度的大小,axis = &apos;both&apos;,x轴和y轴的刻度为粗体plt.tick_params(axis = &apos;both&apos;, which = &apos;major&apos;, labelsize = 14)# 设置每个坐标轴的取值范围，x轴的范围为(0~1100),y轴的范围为(0, 1100000)plt.axis([0, 1100, 0, 1100000])# 展示# plt.show()# 自动保存图片,参数1：文件名（下面这么写是保存在当前文件的目录下），参数2：将图表多余的空白区域裁剪掉plt.savefig(&apos;squares_plot.png&apos;, bbox_inches = &apos;tight&apos;) 结果 TODO: 上传图片 scatter(x_values, y_values, c = y_values, cmap = plt.cm.Blues, edgecolor=&#39;none&#39;, s = 40)，参数1：输入值，参数2：输出值；参数 3 和参数 4 ：将参数 3 的值较小的点显示为浅蓝色，将参数 3 的值较大的设置为深蓝色；参数5：none 表示删除数据点的轮廓，参数6：线的粗细，默认为20。 tick_params(axis = &#39;both&#39;, which = &#39;major&#39;, labelsize = 14)，参数1：表示 x 轴 和 y 轴设置为粗体，参数2：值为 ‘major’、’minor’、’both’，分别代表设置主刻度线、副刻度线以及同时设置，默认值为’major’，参数3：刻度线标签的字体大小 axis([0, 1100, 0, 1100000])，参数1、2：X 轴的坐标范围，参数3、4：Y 轴的坐标范围 savefig(&#39;squares_plot.png&#39;, bbox_inches = &#39;tight&#39;)，参数1：保存的路径，参数2：将图表多余的空白区域裁剪掉 随机漫步 每次行走路线完全是随机的，没有明确的方向，结果是由一行一列交叉点随机决策决定的。 主要代码有 random_walk.py 和 rw_visual.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# random_walk.py 代码如下from random import choiceclass RandomWalk(): &quot;&quot;&quot;一个生成随机漫步数据的类&quot;&quot;&quot; def __init__(self, num_points = 5000): &quot;&quot;&quot;初始化随机漫步的属性&quot;&quot;&quot; self.num_points = num_points # 所有随机漫步都始于（0，0） self.x_values = [0] self.y_values = [0] def fill_walk(self): &quot;&quot;&quot;计算漫步包含的所有点&quot;&quot;&quot; # 不断漫步，直到列表的达到指定的长度 while len(self.x_values) &lt; self.num_points: # choice([1,-1]):表示要么向右走1，要么向左走-1 x_direction = choice([1, -1]) # choice([1,-1]：随机选择一个0~4之间的整数(包含0)，告诉Python沿指定的方向走多远 x_distance = choice([0, 1, 2, 3, 4]) # 移动的方向 * 距离，以确定沿 x 轴和 y 轴移动的距离，x_step为正表示右移，为负表示左移，为0表示垂直移动 x_step = x_direction * x_distance # y 轴同理 x 轴，方向为上下 y_direction = choice([1, -1]) y_distance = choice([0, 1, 2, 3, 4]) y_step = y_direction * y_distance # 拒绝原地踏步 if x_step == 0 and y_step == 0: continue # 计算下一个点的x值和y值，将 x_values[-1] 最后一个值 + x_step 作为下一个 x 值 next_x = self.x_values[-1] + x_step next_y = self.y_values[-1] + y_step self.x_values.append(next_x) self.y_values.append(next_y)# rw_visual.py 的代码如下import matplotlib.pyplot as pltfrom random_walk import RandomWalk# 只要程序属于活动状态，就不断的模拟随机漫步while True: # 创建一个RandomWalk实例，并将其包含的点都绘制出来 # 增加点数,运行时间也会变长 # rw = RandomWalk(50000) rw = RandomWalk() # 计算漫步包含的所有点 rw.fill_walk() # 设置窗口的尺寸 # plt.figure(figsize = (10, 6)) # 传递屏幕分辨率 plt.figure(dpi = 128, figsize = (10, 6)) point_numbers = list(range(rw.num_points)) plt.scatter(rw.x_values, rw.y_values, c = point_numbers, cmap = plt.cm.Blues, edgecolor=&apos;none&apos;, s = 1) # 突出起点和终点 plt.scatter(0, 0, c = &apos;green&apos;, edgecolor=&apos;none&apos;, s = 100) plt.scatter(rw.x_values[-1], rw.y_values[-1], c = &apos;red&apos;, edgecolor=&apos;none&apos;, s = 100) # 隐藏坐标轴 plt.axes().get_xaxis().set_visible(False) plt.axes().get_yaxis().set_visible(False) plt.show() # plt.savefig(&apos;rw_visual.png&apos;, bbox_inches = &apos;tight&apos;) # 关闭matplotlib时会提示是否要再模拟一次，输入y可以再运行一次，输入n则退出 keep_running = input(&quot;Make another walk ? (y/n): &quot;) if keep_running == &apos;n&apos;: break 隐藏坐标轴：x 轴：plt.axes().get_xaxis().set_visible(False)，y 轴：plt.axes().get_yaxis().set_visible(False) 设置分辨率：plt.figure(dpi = 128, figsize = (10, 6)) 同时掷两个面数相同的骰子，掷1000次骰子每次得到的值的概率 用直方图展示掷 2 个骰子出现点数的值的概率 创建骰子类 循环得到模拟掷 1000 次骰子各个值的数量 用 Pygal 可视化展示直方图 创建骰子对象 1234567891011121. 创建一个骰子类，用于模拟掷出去的骰子点数from random import randintclass Die(): &quot;&quot;&quot;表示一个骰子的类&quot;&quot;&quot; def __init__(self, num_sides = 6): &quot;&quot;&quot;骰子默认为6面&quot;&quot;&quot; self.num_sides = num_sides def roll(self): &quot;&quot;&quot;返回一个位于1和骰子面数之间的随机值&quot;&quot;&quot; return randint(1, self.num_sides) 分析数据并展示结果 12345678910111213141516171819202122232425262728293031323334import pygalfrom die import Die# 创建两个D6骰子die_1 = Die()die_2 = Die()# 掷几次骰子，并将结果存储在一个列表中results = []for roll_num in range(1000): result = die_1.roll() + die_2.roll() results.append(result)# 分析结果，得到掷一次（2个）骰子的和，存在集合中frequencies = []max_result = die_1.num_sides + die_2.num_sidesfor value in range(2, max_result + 1): frequency = results.count(value) frequencies.append(frequency)# 对结果进行可视化hist = pygal.Bar()hist.title = &quot;Results of rolling on D6 1000 times.&quot;hist.x_labels = [&apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;10&apos;, &apos;11&apos;, &apos;12&apos;]hist.x_title = &quot;Results&quot;hist.y_title = &quot;Frequency of Result&quot;# 颜色块对应的区域表示的含义hist.add(&apos;D6 + D6&apos;, frequencies)# 将图表渲染为一个SVG文件，这种文件的扩展名必须为svghist.render_to_file(&apos;die_visual.svg&apos;)print(frequencies) pygal.Bar()：将结果可视化 hist.render_to_file(&#39;die_visual.svg&#39;)：将图表渲染为一个 svg 文件且文件扩展名必须为 svg 同时掷两个面数不同的骰子 创建的骰子类的点数不同 x 轴的范围不一样 提取CSV文件的数据，让数据可视化 CSV 文件的内容是一系列以逗号分割的值，测试的文件名为death_valley_2014.csv，可在该项目下找到 1234567891011121314151617181920212223242526272829303132333435363738394041import csvfrom datetime import datetimefrom matplotlib import pyplot as plt# 从文件中获取最高气温和最低气温filename = &apos;death_valley_2014.csv&apos;with open(filename) as f: reader = csv.reader(f) dates, highs, lows = [], [], [] for row in reader: # 捕捉异常，因为文件中有一天是没有数据的 try: current_date = datetime.strptime(row[0], &quot;%Y-%m-%d&quot;) high = int(row[1]) low = int(row[3]) except Exception as e: print(current_date, &apos;missing data&apos;) else: highs.append(high) dates.append(current_date) lows.append(low) # 屏幕设置 fig = plt.figure(dpi = 128, figsize = (10, 6)) # 绘制线 plt.plot(dates, highs, c = &apos;red&apos;, alpha = 0.5) plt.plot(dates, lows, c = &apos;blue&apos;, alpha = 0.5) # 最高温和最低温之间的区域颜色着色 plt.fill_between(dates, highs, lows, facecolor = &apos;blue&apos;, alpha = 0.1) # 设置图表标签，坐标轴标签 plt.title(&quot;Daily high and low temperature - 2014\nDeath Valley, CA&quot;, fontsize = 20) plt.xlabel(&apos;&apos;, fontsize = 16) # 绘制倾斜的日期 fig.autofmt_xdate() plt.ylabel(&quot;Temperature(F)&quot;, fontsize = 16) # 设置标记刻度的大小 plt.tick_params(axis = &apos;both&apos;, which = &apos;major&apos;, labelsize = 16) plt.show() 读取 CSV 文件：csv.reader(f) 时间格式化：datetime.strptime(row[0], &quot;%Y-%m-%d&quot;) 两个插值之间绘制颜色：plt.fill_between(dates, highs, lows, facecolor = &#39;blue&#39;, alpha = 0.1) 绘制 X 轴的日期为倾斜：fig.autofmt_xdate() 制作世界人口地图 在世界地图上显示各个国家 2010 年的人口数，通过不同颜色来区别，用国别码表示国家，数字表示人口数量。 数据可以去Open Knowledge寻找，这里用到的文件名是population.json,可在项目地址中找到 1234567891011# 获取国别码# 通过 pygal.i18n 模块导入，字典 COUNITRIES 中包含了键和值分别为国别码和国家名from pygal.i18n import COUNTRIESdef get_country_code(country_name): &quot;&quot;&quot;根据指定的国家，返回Pygal使用的两个字母的国别码&quot;&quot;&quot; for code, name in COUNTRIES.items(): if name == country_name: return code # 如果没有找到指定的国家，则返回None return None 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 获取国别码对应国家的人口数import jsonimport pygal# 高亮主题，用于更好的区别各个国家的人口数，LightColorizedStyle作为基本样式，RotateStyle用于设置颜色from pygal.style import LightColorizedStyle as LCS, RotateStyle as RSfrom country_codes import get_country_code# 将数据加载到列表中filename = &apos;population_data.json&apos;with open(filename) as f: pop_data = json.load(f)# 创建一个包含人口数量的字典cc_populations = &#123;&#125;for pop_dict in pop_data: if pop_dict[&apos;Year&apos;] == &apos;2010&apos;: country_name = pop_dict[&apos;Country Name&apos;] # 将包含小数点的字符串转为整数，这个数字有可能是人口数据缺失导致，可以先将字符串转为浮点数，再将浮点数转为整数 population = int(float(pop_dict[&apos;Value&apos;])) # 获取到国别码 code = get_country_code(country_name) if code: # 如果返回了国别码，则将国别码和人口数量作为键和值填充字典 cc_populations[code] = population# 根据人口数量将所有国家分成三组cc_pops_1, cc_pops_2, cc_pops_3 = &#123;&#125;, &#123;&#125;, &#123;&#125;for cc, pop in cc_populations.items(): if pop &lt; 10000000: cc_pops_1[cc] = pop elif pop &lt; 1000000000: cc_pops_2[cc] = pop else: cc_pops_3[cc] = pop# 看看每组包含多少个国家print(len(cc_pops_1), len(cc_pops_2), len(cc_pops_3))# 设置颜色，和基本样式wm_style = RS(&apos;#336699&apos;, base_style=LCS)# 绘制世界地图wm = pygal.Worldmap(style=wm_style)wm.title = &apos;World Population in 2010, by Country&apos;wm.add(&apos;0-10m&apos;, cc_pops_1)wm.add(&apos;10m-1bn&apos;, cc_pops_2)wm.add(&apos;&gt;1bn&apos;, cc_pops_3)# 输出为svg为文件wm.render_to_file(&apos;world_population.svg&apos;) 读取 json 数据 ：json.load(f)，参数为文件名 绘制世界地图：pygal.Worldmap(style=wm_style) 获取Web应用程序接口（API），让数据可视化 使用GitHub的API来请求有关该网站中 Python 项目的信息，然后使用 Pygal 生成交互可视化的图形界面，用以展示这些 Python 项目受欢迎的程度 获取 API 安装 requests 处理返回的结果，分析出我们需要的数据项 Pygal 根据数据绘图展示 获取API 去GitHub主页的底部找到API，之后能不能找到你要的内容就看英文水平了（可以安装谷歌翻译插件，一键翻译…）,这里用到的API地址为：https://api.github.com/search/repositories?q=language:python&amp;sort=stars 安装 requests pip install --user requests 处理返回的结果，分析出我们需要的数据项 再安装一个json数据查看的插件，找出你需要的字段，例如这里需要拿到：Name,Owner,Stars,Repository,Description,分别对应的是，仓库的名称、作者、星数、链接、描述 Pygal 根据数据绘图展示，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import requestsimport pygalfrom pygal.style import LightColorizedStyle as LCS, LightenStyle as LS# 执行API调用，并存储响应url = &apos;https://api.github.com/search/repositories?q=language:python&amp;sort=stars&apos;r = requests.get(url)# 200 表示访问成功print(&quot;Status code:&quot;, r.status_code)# 将API响应存储在一个变量中response_dict = r.json()print(&quot;Total repositores:&quot;, response_dict[&apos;total_count&apos;])# 探索有关仓库的信息repo_dicts = response_dict[&apos;items&apos;]print(&quot;Repositores returned:&quot;, len(repo_dicts))# 横纵坐标值names, stars = [], []# 研究第一个仓库repo_dict = repo_dicts[0]print(&quot;\nSelected information about each repository:&quot;)names, plot_dicts = [], []for repo_dict in repo_dicts: # 得到横坐标 names.append(repo_dict[&apos;name&apos;]) # 对每个项目用字典来存储自定义提示的内容 plot_dict = &#123; &apos;value&apos;: repo_dict[&apos;stargazers_count&apos;], &apos;label&apos;: repo_dict[&apos;description&apos;], &apos;xlink&apos;: repo_dict[&apos;html_url&apos;] &#125; # 得到纵坐标 plot_dicts.append(plot_dict) # 设置颜色值，基本样式my_style = LS(&apos;#333366&apos;, base_style = LCS)my_config = pygal.Config()# 创建Bar实例需要的实参，这里通过关键字传递my_config.x_label_rotation = 45my_config.show_legend = Falsemy_config.title_font_size = 24my_config.label_font_size = 14my_config.major_label_font_size = 18# 将较长的项目名缩短为15个字符my_config.truncate_label = 15# 隐藏图表中的隐藏线my_config.show_y_guides = False# 设置图表的自定义宽度my_config.width = 1000chart = pygal.Bar(my_config, style = my_style)# chart = pygal.Bar(style = my_style, x_label_rotation = 45, show_legend = False)chart.title = &quot;GitHub 上点赞最多的仓库&quot;chart.x_labels = nameschart.add(&apos;&apos;, plot_dicts)chart.render_to_file(&apos;python_repos.svg&apos;) 配置 Pygal 的数据：my_config = pygal.Config() 使用配置的参数展示直方图：chart = pygal.Bar(my_config, style = my_style) 获取网络数据：requests.get(url) 可以用字典来存储自定义提示的内容]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python小游戏-《外星人入侵》]]></title>
    <url>%2F2017%2F12%2F10%2FPython%E5%B0%8F%E6%B8%B8%E6%88%8F-%E3%80%8A%E5%A4%96%E6%98%9F%E4%BA%BA%E5%85%A5%E4%BE%B5%E3%80%8B%2F</url>
    <content type="text"><![CDATA[《外星人入侵》游戏游戏介绍 在游戏中，玩家控制着一艘最初出现在屏幕底部中央的飞船，玩家可以使用键盘中的左右键控制飞船的左右移动，还可以用空格键进行射击。 游戏开始时，一群外星人出现在天空中，他们在屏幕中往下移动，玩家的任务就是射杀这些外星人。玩家将所有外星人击杀后，玩家等级升一级并且在屏幕上方将出现新的一群外星人，他们的移动速度更快。玩家每次击杀一个外星人都记录一个分数，游戏结束后记录每局游戏的最高分，每次游戏开始时将最高分显示在屏幕中央。 只要有外星人撞到了玩家的飞船或者到达了底部，玩家就损失一艘飞船，玩家损失3艘飞船后，游戏结束！ 分析 需要一个游戏窗口，显示飞船图片，显示外星人图片，显示分数，等级 控制飞船：左右移动、空格射击 控制外星人：下移速度 控制子弹：子弹的速度、方向 记录玩家数据：等级、最高分、当前分、剩余的飞船数 使用工具 Pygame：用于等任务绘制图像 Sublime Text 3：文本编辑器，用于开发超级爽！ 工具的安装12# 安装 Pygame python -m pip install --user pygame-1.9.2a0-cp35-none-win32.whl 后面的是版本号，可以去下载对应的版本，地址是https://bitbucket.org/pygame/downloads/，找到对应的系统版本 Sublime Text 3安装就简单了，自行解决。 编码前的分析 系统的设置管理：屏幕参数的初始化、飞船数据的初始化、外星人数据的初始化、子弹数据的初始化 编码【直接看GitHub源码地址】————————————- 程序入口 每个程序都有程序的入口，Python 游戏也不例外，以下是程序的入口文件aliens_invasion.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import sysimport pygameimport game_functions as gffrom settings import Settingsfrom ship import Shipfrom alien import Alienfrom pygame.sprite import Groupfrom game_stats import GameStatsfrom button import Buttonfrom scoreboard import Scoreboarddef run_game(): # 初始化游戏并创建屏幕对象 pygame.init() ai_settings = Settings() ; # 设置屏幕参数 screen = pygame.display.set_mode((ai_settings.screen_width, ai_settings.screen_height)) # 设置游戏名称 pygame.display.set_caption(&quot;Alien Invasion&quot;) # 创建paly按钮 play_button = Button(ai_settings, screen, &quot;Play&quot;) # 在屏幕上创建飞船 ship = Ship(ai_settings, screen) # 将子弹存储在一个编组中 bullets = Group() # 将外星人存储在一个编组中 aliens = Group() # 创建外星人群 gf.create_fleet(ai_settings,screen,ship,aliens) # 设置背景色 bg_color = (ai_settings.bg_color) # 创建一个外星人实例 alien = Alien(ai_settings, screen) # 创建一个用于存储游戏统计的实例 stats = GameStats(ai_settings) # 创建记分牌 sb = Scoreboard(ai_settings, screen, stats) # 开始游戏的主要循环 while True: # 监听键盘和鼠标事件 gf.check_events(ai_settings, screen, stats, sb, play_button, ship, aliens, bullets) # 根据游戏状态来刷新屏幕里面的内容，游戏有开始和结束状态 if stats.game_active: # 刷新飞船的位置 ship.update() # 更新子弹的位置 gf.update_bullets(ai_settings, screen, stats, sb, ship, aliens, bullets) # 更新外星人的位置 gf.update_aliens(ai_settings, screen, stats, sb, ship, aliens, bullets) # 刷新屏幕 gf.update_screen(ai_settings, screen, stats, sb, ship, aliens, bullets, play_button)# 函数调用run_game() 设置管理 总的数据管理中心，便于数据的控制，代码如下setting.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Settings(): &quot;&quot;&quot; 存储《外星人入侵》的所有的设置的类 1. 屏幕设置 2. 飞船设置 3. 子弹设置 4. 外星人设置 5. 游戏初始化时参数的默认设置 6. 游戏升级后的参数修改设置 &quot;&quot;&quot; def __init__(self): &quot;&quot;&quot; 初始化游戏的设置 &quot;&quot;&quot; # 屏幕设置 self.screen_width = 1200 self.screen_height = 600 self.bg_color = (230, 230, 230) # 飞船的设置 # 一开始玩家拥有的飞船数量 self.ship_limit = 3 # 子弹的设置 self.bullet_width = 3 self.bullet_hight = 15 self.bullet_color = 60, 60, 60 # 子弹的默认数量（一次只能发射的个数） self.bullets_allowed = 3 # 外星人的设置 self.fleet_drop_speed = 20 # 以什么样的速度加快游戏节奏 self.speedup_scale = 1.1 # 击杀外星人点数的提高速度 self.score_scale = 1.5 self.initialize_dynamic_settings() def initialize_dynamic_settings(self): &quot;&quot;&quot;初始化游戏进行而变化的设置&quot;&quot;&quot; # 飞船的移动像素为1.5一次 self.ship_speed_factor = 1.5 # 子道的移动像素为3一次 self.bullet_speed_factor = 3 # 外星人的移动像素为1一次 self.alien_speed_factor = 1 # fleet_direction 为 1 表示向右移，为-1表示向左移 self.fleet_direction = 1 # 计分 self.alien_points = 50 def increase_speed(self): &quot;&quot;&quot;提高速度设置和外星人点数&quot;&quot;&quot; # 提高飞船的速度 self.ship_speed_factor *= self.speedup_scale # 提高子弹的速度 self.bullet_speed_factor *= self.speedup_scale # 提高外星人的速度 self.alien_speed_factor *= self.speedup_scale # 提高击杀一只外星人分数的速度 self.alien_points = int(self.alien_points * self.score_scale) 各个对象 游戏中需要有飞船对象ship.py，外星人对象alien.py，子弹对象bullet.py，UI显示对象scoreboard.py，游戏数据统计对象game_stats.py，开始游戏按钮对象button.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 飞船对象import pygamefrom pygame.sprite import Spriteclass Ship(Sprite): &quot;&quot;&quot; 飞船类 1. 飞船数据初始化 2. 显示飞船 3. 更新飞船移动后的位置 &quot;&quot;&quot; def __init__(self, ai_settings, screen): &quot;&quot;&quot; 初始化飞行并设置其初始位置 &quot;&quot;&quot; super(Ship, self).__init__() self.screen = screen self.ai_settings = ai_settings # 加载飞船图像并获取其外界矩形 self.image = pygame.image.load(&apos;images/ship.bmp&apos;) self.rect = self.image.get_rect() self.screen_rect = screen.get_rect() # 将每艘飞船放在屏幕底部中央 self.rect.centerx = self.screen_rect.centerx self.rect.bottom = self.screen_rect.bottom # 在飞船的属性center中存储小数值 self.center = float(self.rect.centerx) # 移动标志 self.moving_right = False self.moving_left = False def update(self): &quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot; # 更新飞船的center值，而不是rect. 不让飞船移出屏幕边界 if self.moving_right and self.rect.right &lt; self.screen_rect.right: self.center += self.ai_settings.ship_speed_factor if self.moving_left and self.rect.left &gt; 0: self.center -= self.ai_settings.ship_speed_factor # 根据self.center更新rect对象 self.rect.centerx = self.center def blitme(self): &quot;&quot;&quot; 在指定位置绘制飞船&quot;&quot;&quot; self.screen.blit(self.image, self.rect) def center_ship(self): &quot;&quot;&quot;让飞船在屏幕上居中&quot;&quot;&quot; self.center = self.screen_rect.centerx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 外星人对象import pygamefrom pygame.sprite import Spriteclass Alien(Sprite): &quot;&quot;&quot; 表示外星人的类 1. 主要有外星人数据的初始化 2. 绘制外星人的位置 3. 更新移动外星人后的位置 4. 检测外星人是否到达屏幕边缘 &quot;&quot;&quot; def __init__(self, ai_settings, screen): &quot;&quot;&quot;初始化外星人需要的数据&quot;&quot;&quot; super(Alien, self).__init__() self.screen = screen self.ai_settings = ai_settings # 加载外星人图像，并设置其rect属性 self.image = pygame.image.load(&apos;images/alien.bmp&apos;) self.rect = self.image.get_rect() # 每个外星人最初都在左上角附近 self.rect.x = self.rect.width self.rect.y = self.rect.height # 存储外星人的准确位置 self.x = float(self.rect.x) def blitme(self): &quot;&quot;&quot;在指定位置绘制外星人&quot;&quot;&quot; self.screen.blit(self.image, self.rect) def update(self): &quot;&quot;&quot;向右移动外星人&quot;&quot;&quot; self.x += (self.ai_settings.alien_speed_factor * self.ai_settings.fleet_direction) self.rect.x = self.x def check_edges(self): &quot;&quot;&quot;如果外星人位于屏幕边缘，就返回True&quot;&quot;&quot; screen_rect = self.screen.get_rect() if self.rect.right &gt;= screen_rect.right: return True elif self.rect.left &lt;= 0: return True 123456789101112131415161718192021222324252627282930313233343536# 子弹对象import pygamefrom pygame.sprite import Spriteclass Bullet(Sprite): &quot;&quot;&quot; 一个对飞船发射的子弹进行管理的类 1. 子弹参数的初始化 2. 更新子弹的位置 3. 在屏幕上绘制子弹 &quot;&quot;&quot; def __init__(self, ai_settings, screen, ship): &quot;&quot;&quot;初始化子弹参数&quot;&quot; super(Bullet, self).__init__() self.screen = screen self.color = ai_settings.bullet_color self.speed_factor = ai_settings.bullet_speed_factor # 在 (0,0) 处创建一个表示子弹的矩形，再设置正确的位置 self.rect = pygame.Rect(0, 0, ai_settings.bullet_width, ai_settings.bullet_hight) self.rect.centerx = ship.rect.centerx self.rect.top = ship.rect.top # 存储用小数表示的子弹位置 self.y = float(self.rect.y) def update(self): &quot;&quot;&quot;向上移动子弹&quot;&quot;&quot; # 更新表示子弹的小数位置值 self.y -= self.speed_factor # 更新表示子弹的rect位置 self.rect.y = self.y def draw_bullet(self): &quot;&quot;&quot;在屏幕上绘制子弹&quot;&quot;&quot; pygame.draw.rect(self.screen, self.color, self.rect) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# UI 界面对象import pygame.fontfrom pygame.sprite import Groupfrom ship import Shipclass Scoreboard(): &quot;&quot;&quot; 显示得分信息的类 1. 初始化类 2. 显示当前得分 3. 显示最高分 4. 显示当前等级 5. 显示剩余飞船数 6. 将以上内容绘制在屏幕上 &quot;&quot;&quot; def __init__(self, ai_settings, screen, stats): &quot;&quot;&quot;初始化显示得分的涉及的属性&quot;&quot;&quot; self.screen = screen self.screen_rect = screen.get_rect() self.ai_settings = ai_settings self.stats = stats # 显示得分信息时使用的字体设置 self.text_color = (30, 30, 30) self.font = pygame.font.SysFont(None, 48) # 准备初始得分图像 self.prep_score() # 准备最高分图像 self.prep_high_score() # 准备剩余的飞船数量 self.prep_ships() # 准备玩家等级 self.prep_level() def prep_score(self): &quot;&quot;&quot;将得分转换为一副渲染的图像&quot;&quot;&quot; rounded_score = int(round(self.stats.score, -1)) # 将得分格式化为 10,000,000 这种格式的数字 score_str = &quot;&#123;:,&#125;&quot;.format(rounded_score) # 渲染得分图像 self.score_image = self.font.render(score_str, True, self.text_color, self.ai_settings.bg_color) # 将得分放在屏幕右上角 self.score_rect = self.score_image.get_rect() self.score_rect.right = self.screen_rect.right -20 self.score_rect.top = 20 def prep_high_score(self): &quot;&quot;&quot;将最高得分转换为一副渲染的图像&quot;&quot;&quot; high_score = int(self.stats.high_score) # 将得分格式化 high_score_str = &quot;&#123;:,&#125;&quot;.format(high_score) self.high_score_image = self.font.render(high_score_str, True, self.text_color, self.ai_settings.bg_color) # 将得分放在屏幕中间 self.high_score_rect = self.high_score_image.get_rect() self.high_score_rect.centerx = self.screen_rect.centerx self.high_score_rect.top = self.score_rect.top def prep_level(self): &quot;&quot;&quot;将等级转换为一副渲染的图像&quot;&quot;&quot; self.level_image = self.font.render(str(self.stats.level), True, self.text_color, self.ai_settings.bg_color) # 将等级放在得分下方 self.level_rect = self.level_image.get_rect() self.level_rect.right = self.score_rect.right self.level_rect.top = self.score_rect.bottom + 10 def prep_ships(self): &quot;&quot;&quot;显示还剩下多少条飞船&quot;&quot;&quot; # 将所有飞船放在一个组中，便于管理 self.ships = Group() # 计算剩余飞船数 for ship_number in range(self.stats.ships_left): ship = Ship(self.ai_settings, self.screen) ship.rect.x = 10 + ship_number * ship.rect.width ship.rect.y = 10 self.ships.add(ship) def show_score(self): &quot;&quot;&quot;在屏幕上显示当前得分、最高分、等级&quot;&quot;&quot; self.screen.blit(self.score_image, self.score_rect) self.screen.blit(self.high_score_image, self.high_score_rect) self.screen.blit(self.level_image, self.level_rect) self.ships.draw(self.screen) 1234567891011121314151617181920212223242526272829303132# 游戏数据统计对象import game_functions as gfclass GameStats(object): &quot;&quot;&quot; 跟踪游戏的统计信息 1. 统计对象的初始化 2. &quot;&quot;&quot; def __init__(self, ai_settings): &quot;&quot;&quot;初始化统计信息&quot;&quot;&quot; self.ai_settings = ai_settings self.reset_stats() # 游戏刚启动时处于非活动状态 self.game_active = False # 在任何情况下都不应该重置最高分 # 先从文件中读取，有则显示最高分，没有则显示0 read_high_score = gf.read_high_score() # 判空 if read_high_score.strip() == &apos;&apos;: self.high_score = int(0) else: self.high_score = int(read_high_score) def reset_stats(self): &quot;&quot;&quot;初始化在游戏运行期间可能变化的统计信息&quot;&quot;&quot; self.ships_left = self.ai_settings.ship_limit self.score = 0 # 玩家等级 self.level = 1 1234567891011121314151617181920212223242526272829303132333435363738# 开始游戏按钮对象import pygame.fontclass Button(): &quot;&quot;&quot; 开始游戏按钮 1. 初始化按钮属性 2. 设置按钮的文本 3. 在屏幕上绘制按钮 &quot;&quot;&quot; def __init__(self, ai_settings, screen, msg): &quot;&quot;&quot;初始化按钮的属性&quot;&quot;&quot; self.screen = screen self.screen_rect = screen.get_rect() # 设置按钮的尺寸和其他属性 self.width, self.height = 200, 50 self.button_color = (0, 255, 0) self.text_color = (255, 255, 255) self.font = pygame.font.SysFont(None, 48) # 创建按钮的rect, 并使其居中 self.rect = pygame.Rect(0, 0, self.width, self. height) self.rect.center = self.screen_rect.center # 按钮的标签只需创建一次 self.prep_msg(msg) def prep_msg(self, msg): &quot;&quot;&quot;将msg渲染为图像，并失去在按钮上居中&quot;&quot;&quot; self.msg_image = self.font.render(msg, True, self.text_color, self.button_color) self.msg_image_rect = self.msg_image.get_rect() self.msg_image_rect.center = self.rect.center def draw_botton(self): # 绘制一个用颜色填充的按钮再绘制文本 self.screen.fill(self.button_color, self.rect) self.screen.blit(self.msg_image, self.msg_image_rect) 控制方法 通过game_funcations.py去串联各个对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258# 串联各个对象import sysimport pygamefrom bullet import Bulletfrom alien import Alienfrom time import sleepdef check_events(ai_settings, screen, stats, sb, play_button, ship, aliens, bullets): &quot;&quot;&quot; 响应按键和鼠标事件 1. 键盘按下和抬起要实现的操作 2. 鼠标按下，开启游戏 3. 将最高分写入文件 4. 更新子弹数量，删除击中到外星人的子弹，以及被击中的外星人 5. 创建一群外星人群 6. 检测游戏是否结束 &quot;&quot;&quot; for event in pygame.event.get(): if event.type == pygame.QUIT: # 按下q 退出游戏 write_high_score(stats) sys.exit() elif event.type == pygame.KEYDOWN: check_keydown_events(event, ai_settings, screen, stats, ship, bullets) elif event.type == pygame.KEYUP: check_keyup_events(event, ship) elif event.type == pygame.MOUSEBUTTONDOWN: mouse_x, mouse_y = pygame.mouse.get_pos() check_play_button(ai_settings, screen, stats, sb, play_button, ship, aliens, bullets, mouse_x, mouse_y)def check_play_button(ai_settings, screen, stats, sb, play_button, ship, aliens, bullets, mouse_x, mouse_y): &quot;&quot;&quot;玩家单击开始按钮开始游戏&quot;&quot;&quot; button_clicked = play_button.rect.collidepoint(mouse_x, mouse_y) if button_clicked and not stats.game_active: # 重置游戏设置 ai_settings.initialize_dynamic_settings() # 隐藏光标 pygame.mouse.set_visible(False) # 重置游戏统计信息 stats.reset_stats() stats.game_active = True # 重置记分牌图像 sb.prep_score() sb.prep_high_score() sb.prep_level() sb.prep_ships() # 清空外星人列表和子弹列表 aliens.empty() bullets.empty() # 创建一群新的外星人，并让飞船居中 create_fleet(ai_settings, screen, ship, aliens) ship.center_ship()def check_keydown_events(event, ai_settings, screen, stats, ship, bullets): # 响应鼠标按下事件 if event.key == pygame.K_RIGHT: # 按下向右移动飞船 ship.moving_right = True elif event.key == pygame.K_LEFT: # 按下向左移动飞船 ship.moving_left = True elif event.key == pygame.K_SPACE: # 创建一颗子弹，并将其加入到编组bullets中, 控制只能发射3颗子弹 fire_bullet(ai_settings, screen, ship, bullets) elif event.key == pygame.K_q: # 按下q退出游戏 write_high_score(stats) sys.exit()def write_high_score(stats): # 先读取文件，如果最高分比文件中的分数还低就不写入文件，否则写入文件 read_high_score_txt = int(read_high_score()) # 当前分数大于文件中的最高分，则写入文件 if read_high_score_txt &lt; stats.high_score: write_file = &apos;high_score.txt&apos; with open(write_file, &apos;w&apos;) as write_file_object: write_file_object.write(str(stats.high_score))def read_high_score(): &quot;&quot;&quot;读取文件中的最高分&quot;&quot;&quot; read_file = &apos;high_score.txt&apos; with open(read_file) as read_file_object: read_high_score = read_file_object.read() return read_high_scoredef check_keyup_events(event, ship): # 响应鼠标松开事件 if event.key == pygame.K_RIGHT: ship.moving_right = False elif event.key == pygame.K_LEFT: ship.moving_left = Falsedef update_bullets(ai_settings, screen, stats, sb, ship, aliens, bullets): &quot;&quot;&quot;更新子弹的位置，并删除已经消失的子弹&quot;&quot;&quot; bullets.update() # 删除消失的子弹 for bullet in bullets.copy(): if bullet.rect.bottom &lt;= 0: bullets.remove(bullet) # 响应子弹和外星人的碰撞 check_bullet_alien_collisions(ai_settings, screen, stats, sb, ship, aliens, bullets)def check_bullet_alien_collisions(ai_settings, screen, stats, sb, ship, aliens, bullets): # 删除发生碰撞的子弹和外星人 collisions = pygame.sprite.groupcollide(bullets, aliens,True, True) # 统计击杀的外星人分数 if collisions: for aliens in collisions.values(): stats.score += ai_settings.alien_points * len(aliens) sb.prep_score() # 检查是否诞生了新的最高分 check_high_score(stats, sb) # 屏幕上外星人被杀光 if len(aliens) == 0: # 删除现有的子弹,加快游戏节奏，并新建一群外星人 bullets.empty() ai_settings.increase_speed() create_fleet(ai_settings, screen, ship, aliens) # 如果整群外星人被消灭了，就提高一个等级 stats.level += 1 sb.prep_level()def check_high_score(stats, sb): &quot;&quot;&quot;检查是否诞生了新的最高分&quot;&quot;&quot; if stats.score &gt; stats.high_score: stats.high_score = stats.score sb.prep_high_score()def fire_bullet(ai_settings, screen, ship, bullets): &quot;&quot;&quot;如果还没达到子弹的发射上限，就发射一颗子弹&quot;&quot;&quot; if len(bullets) &lt; ai_settings.bullets_allowed: new_bullet = Bullet(ai_settings, screen, ship) bullets.add(new_bullet)def get_number_aliens_x(ai_settings, alien_width): # 外星人间距为外星人的宽度 计算一行可容纳多少个外星人 available_space_x = ai_settings.screen_width - 2 * alien_width number_aliens_x = int(available_space_x / (2 * alien_width)) return number_aliens_xdef get_number_rows(ai_settings, ship_height, alien_height): &quot;&quot;&quot;计算屏幕可以容纳多少行外星人&quot;&quot;&quot; available_space_y = (ai_settings.screen_height - (3 * alien_height) - ship_height) number_rows = int(available_space_y / (2 * alien_height)) return number_rowsdef create_alien(ai_settings, screen, aliens, alien_number, row_number): # 创建一个外星人 alien = Alien(ai_settings, screen) alien_width = alien.rect.width # 外星人的坐标 alien.x = alien_width + 2 * alien_width * alien_number alien.rect.x = alien.x alien.rect.y = alien.rect.height + 2 * alien.rect.height * row_number aliens.add(alien)def create_fleet(ai_settings, screen, ship, aliens): &quot;&quot;&quot;创建外星人群&quot;&quot;&quot; alien = Alien(ai_settings, screen) number_aliens_x = get_number_aliens_x(ai_settings, alien.rect.width) number_rows = get_number_rows(ai_settings,ship.rect.height, alien.rect.height) # 创建第一行外星人 &quot;&quot;&quot; for alien_number in range(number_aliens_x): # 创建一个外星人并将其加入当前行 alien = Alien(ai_settings, screen) create_alien(ai_settings, screen, aliens, alien_number) &quot;&quot;&quot; # 创建外星人群 for row_number in range(number_rows): for alien_number in range(number_aliens_x): # 创建一个外星人并将其加入当前行 alien = Alien(ai_settings, screen) create_alien(ai_settings, screen, aliens, alien_number, row_number)def update_aliens(ai_settings, screen, stats, sb, ship, aliens, bullets): &quot;&quot;&quot;检查是否有外星人在屏幕边缘，并更新正群外星人的位置&quot;&quot;&quot; check_fleet_edges(ai_settings, aliens) aliens.update() # 检测外星人和飞船之间的碰撞 if pygame.sprite.spritecollideany(ship, aliens): print(&quot;Ship hit!!!&quot;) ship_hit(ai_settings, screen, stats, sb, ship, aliens, bullets) check_aliens_bottom(ai_settings, screen, stats, sb, ship, aliens, bullets)def check_fleet_edges(ai_settings, aliens): &quot;&quot;&quot;有外星人到达边缘时采取响应的措施&quot;&quot;&quot; for alien in aliens.sprites(): if alien.check_edges(): change_fleet_direction(ai_settings, aliens) breakdef change_fleet_direction(ai_settings, aliens): &quot;&quot;&quot;将整体外星人下移，并改变他们的方向&quot;&quot;&quot; for alien in aliens.sprites(): alien.rect.y += ai_settings.fleet_drop_speed ai_settings.fleet_direction *= -1 def ship_hit(ai_settings, screen, stats, sb, ship, aliens, bullets): # 响应被外星人撞到的飞船 if stats.ships_left &gt; 0: # 将ship_left减1 stats.ships_left -= 1 # 更新飞船数 sb.prep_ships() # 清空外星人列表和子弹列表 aliens.empty() bullets.empty() # 创建一群新的外星人，并将飞创放到屏幕底部的中间 create_fleet(ai_settings, screen, ship, aliens) ship.center_ship() # 暂停 sleep(0.5) else: stats.game_active = False # 非游戏状态显示光标 pygame.mouse.set_visible(True)def check_aliens_bottom(ai_settings, screen, stats, sb, ship, aliens, bullets): &quot;&quot;&quot;检查是否有外星人到达屏幕底部&quot;&quot;&quot; screen_rect = screen.get_rect() for alien in aliens.sprites(): if alien.rect.bottom &gt;= screen_rect.bottom: # 像飞船被撞到一样处理 ship_hit(ai_settings, stats, screen, sb, ship, aliens, bullets) breakdef update_screen(ai_settings, screen, stats, sb, ship, aliens, bullets, play_button): &quot;&quot;&quot;更新屏幕上的图像，并切换到新的屏幕&quot;&quot;&quot; # 每次循环时都重绘屏幕 screen.fill(ai_settings.bg_color) # 在飞船和外星人后面重绘所有子弹 for bullet in bullets.sprites(): bullet.draw_bullet() # 在指定位置绘制飞船 ship.blitme() aliens.draw(screen) # 显示得分 sb.show_score() # 如果游戏处于非活动状态，就绘制Play按钮 if not stats.game_active: play_button.draw_botton() # 让最近绘制的屏幕可见 pygame.display.flip()]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础（八）-文件和异常]]></title>
    <url>%2F2017%2F12%2F08%2FPython%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89-%E6%96%87%E4%BB%B6%E5%92%8C%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[读取文件中的数据 读取整个文件 123with open(&apos;text.txt&apos;) as file_object: contents = file_object.read() print(contents) 分析 with 关键字在不需要访问文件时会将其关闭，open()函数接收一个参数，该参数是文件路径，text.txt是当前目录下的文件，所以可以直接这么写，在其他路径直接写其他路径名，如：text.txt在当前目录下的txt文件夹中，那么路径为：txt\text.txt，要是在D盘的txt文件夹下可以这么写：D:\txt\text.txt。as 表示给对象起别名，read()读取这个文件的全部内容，结果为字符串（该字符串结尾会多一行空行），可用rstrip()去除空行。 逐行读取文件 1234with open(&apos;text.txt&apos;) as file_object: for line in file_object: # 逐行读取需要去除空行，否则空行会越来越多（也是看需求吧） print(line.rstrip()) strip() 和rstrip() 的区别 strip() ： 去掉所有空格 rstrip() ：去掉空行 写入文件 写入空文件 1234file_name = &apos;text0.txt&apos;with open(file_name, &apos;w&apos;) as file_object: file_object.write(&quot; I Love Python.\n&quot;) file_object.write(&quot; I Love Android&quot;) open()函数又两个参数，第一个参数是文件名，第二个参数是模式：w表示写入模式，还有r表示读取模式，a 或者 r+表示附加模式，python 默认是以只读模式打开文件 如果写入的文件不存在，则穿件该文件 如果是写入模式, 会将文件清空再写入 附件模式，是在文件的内容末尾加上新写入的内容 异常 使用try-except代码块：ZeroDivisionError 1234try: print(5/0)except ZeroDivisionError: print(&quot;you can&apos;t divide by zero!&quot;) FileNotFoundError 异常 打开文件找不到文件 pass 表示什么都不做，在发生错误时不想输出信息，可以用pass语句 存储数据 使用 json.dump() 和 json.load() 1234567891011121314# 存文件import jsonnumbers = [2, 3, 5, 7, 11, 13]filename = &apos;numbers.json&apos;with open(filename, &apos;w&apos;) as f_obj: json.dump(numbers, f_obj) # 取文件import jsonfilename = &apos;numbers.json&apos;with open(filename) as f_obj: numbers = json.load(f_obj)print(numbers) 导入 json 模块，创建一个数字列表，将列表存储到文件，利用json.dump()将文件存为json格式 利用json.load()将文件读取出来]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础（七）-类]]></title>
    <url>%2F2017%2F12%2F08%2FPython%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[面向对象编程是最有效的软件编写方法之一，在面向对象编程中的类可以模拟显示世界中的事物和情景，并基于这些类来创建对象，在类中定义对象的通用行为。 创建和使用类123456789101112131415161718192021222324252627# 创建class Dog(): &quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot; def __init__(self, name, age): &quot;&quot;&quot;初始化属性name和age&quot;&quot;&quot; self.name = name self.age = age self.color = &apos;yellow&apos; def sit(self): &quot;&quot;&quot;模拟小狗被命令蹲下&quot;&quot;&quot; print(self.name.title() + &quot; is now sitting&quot;) print(&quot;My dog&apos;s color is &quot; + self.color) def roll_over(self): &quot;&quot;&quot;模拟小狗被命令打滚&quot;&quot;&quot; print(self.name.title() + &quot; rolled over!&quot;) # 使用my_dog= Dog(&apos;wangcai&apos;,3)my_dog.sit()print(&quot;My dog&apos;s name is &quot; + my_dog.name.title() + &quot;.&quot;)# 输出结果Wangcai is now sittingMy dog&apos;s color is yellowMy dog&apos;s name is Wangcai. 方法__init__()，相当于构造方法，每次创建类都运行该方法，方法前后都有两个下划线，这是为了避免和普通方法名称发生冲突 可以在__init__()中给属性默认值如：color被给定默认值为yellow 方法sit()由于不需要其他参数，所以只传了一个实例类本身的形参self 使用就是直接类名(参数)，将结果给一个变量，通过该变量.方法名就能够调用类中的方法了。 修改属性的值，可以通过实例直接修改、通过方法修改属性的值、通过方法对属性的值递增：如 1234567891011121314151617181920212223242526# 还是使用上面的例子# 1. 通过实例直接修改my_dog = Dog(&apos;wangcai&apos;,3)# 将年龄改为4my_dog.age = 4# 2. 通过方法修改属性的值# 在 Dog 类中声明一个方法 update_age(self, age)方法如下：def update_age(self, age): self.age = age使用：my_dog = Dog(&apos;wangcai&apos;,3)# 将年龄改为4my_dog.update_age(4) # 3. 通过方法对属性的值递增# 在 Dog 类中声明一个方法 increment_age(self, age)方法如下：def increment_age(self, age): self.age += age使用：my_dog = Dog(&apos;wangcai&apos;,3)# 将年龄改为4my_dog.increment_age(1) 继承123456789101112131415161718192021222324252627282930313233# 父类class Car(): &quot;&quot;&quot;docstring for Car&quot;&quot;&quot; def __init__(self, make, model, year): self.make = make self.model = model self.year = year def get_desc_name(self): car_name = str(self.year) + &apos; &apos; + self.make + &apos; &apos; + self.model print(car_name.title()) # 子类class ElectricCar(Car): &quot;&quot;&quot;docstring for ElectricCar&quot;&quot;&quot; def __init__(self, arg): super().__init__(self, make, model, year) self.battery_size = 70 def desc_battery(self): print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-kWh battery&quot;) # 重写父类的方法 # def get_desc_name(): # print(&quot; 2027 I want to buy tesla&quot;)# 使用子类my_tesla = ElectricCar(&apos;tesla&apos;, &apos;model s&apos;, 2017)print(my_tesla.get_desc_name())print(my_tasla.desc_battery())# 输出结果是2017 Tesla Model SThis car has a 70-kWh battery 父类中和其他类一样，子类中的super().__init__(self, 父类 init 方法中的参数列表)，这些参数必不可少。 def desc_battery(self) 是子类的方法，用于获取汽车电池 如果将重写方法的注释打开，那么输出结果将覆盖父类中get_desc_name()的输出，结果如下： 122027 I want to buy teslaThis car has a 70-kWh battery 导入类假如我们创建了Animal类( 文件名为animal )，类中含有sit()方法，想在Dog类中使用该方法，方式如下： 12345678910111213# animal 文件名，Animal类名from animal import Animalanimal0 = Animal()animal0.sit() # 这样即可调用# 如果想导入多个类可用逗号隔开，如下：from animal import Animal, Peoson# 导入整个模块import animal# 导入模块中的所有类from animal import *]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础（六）-函数]]></title>
    <url>%2F2017%2F12%2F07%2FPython%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数定义12345def greet_user(msg): &quot;&quot;&quot;函数的描述&quot;&quot;&quot; print(msg)greet_user(&quot;hello&quot;) 输出结果是：Hello 分析 def 关键字来声明函数，greet_user()表示函数名，msg表示函数的参数，&quot;&quot;&quot;&quot;&quot;&quot;里面的内容表示函数的作用解释 多个参数的位置的顺序要摆放正确，不然出了Bug真的不好找aaa。 带返回值的函数1234567def greet_user(first_name, last_name): &quot;&quot;&quot;函数的描述&quot;&quot;&quot; full_name = first_name + &apos; &apos; + last_name return full_name.title()user_name = greet_user(&apos;Aller&apos;,&apos;Dong&apos;)print(user_name) 通过关键字return返回结果 返回一个字典12345678def greet_user(first_name, last_name): &quot;&quot;&quot;函数的描述&quot;&quot;&quot; person = &#123;&apos;first&apos;:first_name,&apos;last&apos;:last_name&#125; return personperson = greet_user(&apos;Aller&apos;,&apos;Dong&apos;)print(person) 返回结果 和Java中返回对象有点像哦~ 传递任意数量的实参1234567def greet_user(*names): &quot;&quot;&quot;函数的描述&quot;&quot;&quot; for name in names: print(name)greet_user(&apos;AllerDong&apos;)greet_user(&apos;Zhangsan&apos;, &apos;Lisi&apos;, &apos;Wangwu&apos;) 通过*号表示任意数量的参数 将函数存储在模块中 导入整个模块 import 模块名称，如在当前目录下创建两个文件，一个是test0.py，一个是test1.py，test0.py的代码如下 1234def greet_user(*names): &quot;&quot;&quot;函数的描述&quot;&quot;&quot; for name in names: print(name) 那么在test1.py中想使用test0.py中的代码可以这么写 12import test0test0.greet_user(&apos;AllerDong&apos;) 输出结果为：AllerDong，这么做主要是能让代码重用（程序员都比较懒） 导入特定函数 test0.py 不变，修改test1.py中的代码为 12from test0 import greet_usergreet_user(&apos;AllerDong&apos;) 二者的区别在于，导入整个模块（import 模块名）后在使用模块中的函数时需要用模块名.函数名的格式取调用，而导入特定函数（from 模块名 import 函数名）就只能使用该函数，模块中的其他函数是用不了的。在使用时直接函数名就可以使用了 使用as给模块起别名(也是为了偷懒) 12import test0 as tt.greet_user(&apos;AllerDong&apos;)]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础（五）-字典]]></title>
    <url>%2F2017%2F12%2F07%2FPython%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89-%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[一个简单的字典123alien_0 = &#123;&apos;color&apos;:&apos;green&apos;, &apos;points&apos;:&apos;5&apos;&#125;print(alien_0[&apos;color&apos;])print(alien_0[&apos;points&apos;]) 输出结果 在字典中添加键值对1234alien_0 = &#123;&apos;color&apos;:&apos;green&apos;, &apos;points&apos;:&apos;5&apos;&#125;alien_0[&apos;x_position&apos;] = 0alien_0[&apos;y_position&apos;] = 25print(alien_0) 输出结果 分析 Python 不关心键值对的添加顺序，只关心键和值之间的关联关系 修改字典中的值1234567alien_0 = &#123;&apos;color&apos;:&apos;green&apos;, &apos;points&apos;:&apos;5&apos;&#125;alien_0[&apos;x_position&apos;] = 0alien_0[&apos;y_position&apos;] = 25# 修改color为yellowalien_0[&apos;color&apos;] = &apos;yellow&apos;print(alien_0) 输出结果 删除键值对12345678910alien_0 = &#123;&apos;color&apos;:&apos;green&apos;, &apos;points&apos;:&apos;5&apos;&#125;alien_0[&apos;x_position&apos;] = 0alien_0[&apos;y_position&apos;] = 25# 原来的字典print(alien_0)del alien_0[&apos;points&apos;]# 删除points键对应的值后的字典print(alien_0) 结果 遍历字典1234567891011alien_0 = &#123;&apos;color&apos;:&apos;green&apos;, &apos;points&apos;:&apos;5&apos;&#125;alien_0[&apos;x_position&apos;] = 0alien_0[&apos;y_position&apos;] = 25print(alien_0)# 遍历所有键值对for key, value in alien_0.items(): print(&quot;\nKey: &quot;+key) # print只能输出字符串，所有需要用`str()`强转 print(&quot;Value: &quot;+str(value)) 输出结果 遍历字典中的所有键 123456789alien_0 = &#123;&apos;color&apos;:&apos;green&apos;, &apos;points&apos;:&apos;5&apos;&#125;alien_0[&apos;x_position&apos;] = 0alien_0[&apos;y_position&apos;] = 25print(alien_0)# 遍历所有键值对for key, value in alien_0.keys(): print(&quot;\nKey: &quot;+key) 遍历字典中的所有值 123456789alien_0 = &#123;&apos;color&apos;:&apos;green&apos;, &apos;points&apos;:&apos;5&apos;&#125;alien_0[&apos;x_position&apos;] = 0alien_0[&apos;y_position&apos;] = 25print(alien_0)# 遍历所有键值对for value in alien_0.values(): print(&quot;Value: &quot;+str(value)) 字典嵌套1234567alien_0 = &#123;&apos;color&apos;:&apos;green&apos;, &apos;points&apos;:&apos;5&apos;&#125;alien_1 = &#123;&apos;color&apos;:&apos;yellow&apos;,&apos;points&apos;:&apos;15&apos;&#125;alien_2 = &#123;&apos;color&apos;:&apos;blue&apos;, &apos;points&apos;:&apos;25&apos;&#125;aliens = [alien_0, alien_1, alien_2]for alien in aliens: print(alien) 输出结果 在字典中存储列表1234alien_0 = &#123;&apos;color&apos;:&apos;green&apos;, &apos;cars&apos;:[&apos;audi&apos;, &apos;bmw&apos;]&#125;for car in alien_0[&apos;cars&apos;]: print(car) 输出结果 在字典中存储字典123456alien_0 = &#123;&apos;color&apos;:&#123;&apos;first&apos;:&apos;green&apos;, &apos;two&apos;:&apos;yellow&apos;&#125;, &apos;cars&apos;:&#123;&apos;first&apos;:&apos;audi&apos;,&apos;two&apos;:&apos;bmw&apos;&#125;,&#125;for alien, car in alien_0.items(): print(alien) print(&quot;\t&quot; + car[&apos;first&apos;]) print(&quot;\t&quot; + car[&apos;two&apos;]) 输出结果 分析 alien 为键，car为值 先输出键，color 键对应的值，然后再输出 cars 键对应的值 试试字典嵌套字典，字典中又嵌套列表….感觉再作死！（最好别嵌套这么多） 目前的做法不对，希望以后能找到更好的思路 1234567891011121314alien_0 = &#123;&apos;color&apos;:&#123;&apos;first&apos;:&apos;green&apos;, &apos;two&apos;:&apos;yellow&apos;&#125;, &apos;cars&apos;:&#123;&apos;first&apos;:[&apos;audi&apos;,&apos;toyota&apos;],&apos;two&apos;:&apos;bmw&apos;&#125;,&#125;# 第一步创建一个列表取存储alien_0字典中的第一个键对应的值list_1 = []# 第二步遍历字典alien_0，将值放入创建的list_1列表中for alien, car in alien_0.items(): list_1.append(car[&apos;first&apos;])print(list_1)# 第三步判断该值是否存在列表中for car_car in list_1: if &apos;audi&apos; in car_car: print(car_car) # 第四步 存在该值，则打印出来 print(car_car[1]) 结果 分析 alien_0 是一个字典，字典的第一个value嵌套了字典，第二个value嵌套了字典同时字典中嵌套了列表。我想取得列表的第1个元素，那就一层一层来呗请看代码中的分析 这么做的缺点是需要知道列表中存在该值….]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础（四）-if语句]]></title>
    <url>%2F2017%2F12%2F06%2FPython%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89-if%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[推荐一个编辑器 Sublime Text 超级好用，而且可以直接运行 Python 代码，在编辑器页面按下ctrl + B即可运行，厉害了我的ST 一个简单的示例123456cars = [&apos;audi&apos;, &apos;bmw&apos;, &apos;subaru&apos;, &apos;tiyota&apos;]for car in cars: if car == &apos;bmw&apos;: print(car.upper()) else: print(car.title()) 输出结果 分析 声明一个列表，通过 for 循环判断列表中是否存在一个值和bmw一样，是的话将bmw转为大写BMW,否则将列表中其他的字符串首字母大写 检查字符串是否相等、不等1234567car = &apos;audi&apos;car == &apos;bmw&apos;输出 Falsecar = &apos;audi&apos;car != &apos;bmw&apos;输出 True 字符串比较是区分大小写的，’audi’ 不等于’Audi’ 比较数字，=，&lt;=，&gt;=，和Java中一样123age = 18age == 18输出 True 检查多个条件，and12345age_0 = 22age_1 = 18age_0 &gt;= 21 and age_1 &gt;=21输出False 检查特定值是否在列表中，是否不在列表中1234567cars = [&apos;audi&apos;, &apos;bmw&apos;, &apos;subaru&apos;, &apos;toyota&apos;]&apos;audi&apos; in cars输出Truecars = [&apos;audi&apos;, &apos;bmw&apos;, &apos;subaru&apos;, &apos;toyota&apos;]&apos;mini&apos; not in cars输出True if-elif-else1234567age = 12if age &gt; 4 print(&quot;大于4&quot;)elif age &lt; 18: print(&quot;小于18&quot;)else: print(&quot;大于4小于18&quot;) 确定列表不是空的12345cars = []if cars: print(&quot;列表非空&quot;)else: print(&quot;列表是空的&quot;) 使用多个列表1234567cars = [&apos;audi&apos;, &apos;bmw&apos;, &apos;subaru&apos;, &apos;toyota&apos;]types = [&apos;small&apos;, &apos;middle&apos;, &apos;big&apos;, &apos;toyota&apos;]for type in types: if type in cars: print(&quot;tpyes 列表中有 cars 列表中的值&quot;) else: print(&quot;tpyes 列表没中有 cars 列表中的值&quot;)]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础（三）- 操作列表]]></title>
    <url>%2F2017%2F11%2F26%2FPython%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89-%E6%93%8D%E4%BD%9C%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[遍历列表 定义一个列表 通过for 循环输出结果 创建数值列表 使用range()函数 range(1，5) 函数的参数范围，包前不包后 list(range(2,11,2))：从2开始数，不断加2，直到11（不包括11） 对数字列表进行简单的统计 min() 列表中的最小值 max() 列表中的最大值 sum() 求和 使用列表的一部分（切片） players(0:3):（包前不包后）第一个参数没有索引将从头开始,第二个参数没有写索引结果将直到结束，负数代表从末尾开始（-1表示最后一个元素）可以遍历任意长度切片：如下 复制列表 palyers_two = players[:] 元祖 Python 将不能修改的值成为不可变的，而不可变的列表成为元祖 遍历方式和遍历列表的方式一样 定义是：用()括起来的内容，列表是用[]包裹的数据 修改元祖变量：值是不能改变的，但是变量是可以改变的。 代码格式 缩进使用4个空格 每行不超过80个字符 程序的不同部分可用空行分开]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin简单使用EventBus3.x]]></title>
    <url>%2F2017%2F11%2F24%2FKotlin%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8EventBus3-x%2F</url>
    <content type="text"><![CDATA[完成功能：替换activity间传值的繁琐过程（明天补上动图） 使用到的 Kotlin 语法 我也是现学现用的，写的不对，多多指教 AS版本：2.3 EventBus版本：3.1.1 Kotlin 环境 这个网上很多讲解了，我也是看着别人的博客搭建的。就装一个 Kotlin 插件，然后导入 EventBus3 ，导入步骤看Github介绍。 这里需要注意不能在onStar方法中注册，Github中的介绍是在onStart方法中注册，但是我用Kotlin和Java都试过了，会内存溢出，具体原因还没查明，了解的望告知，谢谢! 变量赋值 val txt:String? = &quot;EventBus1&quot;，不管是字符串还是整型数据，都用 val去声明一个变量；txt:String是变量名字和变量的类型，中间通过:号隔开，利用?去做非空操作，就是这个值不会为NULL。=号后面就是赋值的内容了。 点击事件 123bt_message.setOnClickListener&#123; startActivity(Intent(this, EventBus2Activity::class.java))&#125; bt_message是xml中的布局 id ,在 Moudle 的 build.gradle 文件中引入apply plugin: &#39;kotlin-android-extensions&#39;,这个引入过程网上也讲解的很清楚了，引入之后就可以直接用id去设置内容，省去了 Java 中的 findViewById 操作。 点击事件比Java的简洁了太多太多…Kotlin 中是创建对象是没有 new 的 创建类、方法 1234567891011121314# 创建类class EventBusMessages &#123; var message:String? = null&#125;# 创建方法（这里直接引用代码中所创建的方法了）fun onEvent(messageEvent: EventBusMessages) &#123; /** * 注意传递的参数 * 如果传递的是对象，这里也要传入对象 * 如果传递的是字符串，这里要传入String * 以此类推... */ event_bus1_tv.setText(messageEvent.message)&#125; 创建类：直接用class去定义，加上类名即可 创建方法：用 fun 去定义，加上方法名即可，想加参数在括号中声明即可，声明方式是：对象：类型 Java中get/set的替代方式 也不能说替代，Java 中也有这种方式。Kotlin 的实现相当于Java 中给属性设置为public，然后通过创建出的对象去完成赋值操作 123456789# 定义一个对象class EventBusMessages &#123; var message:String? = null&#125;# 赋值 val eventMessage = EventBusMessages() eventMessage.message = &quot;你好&quot; val msg = eventMessage.message Kotlin 使用EventBus3.x 终于说到正事了，说这么多。kotlin 使用 EventBus 和 Java 是一毛一样的，感觉说了好多废话，直接上代码吧！ 注册EventBus，必须在OnCreate（Java也是） 源码地址 代码主要在event_bus包中，代码很乱，待完善。 GitHub]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础（二）-列表]]></title>
    <url>%2F2017%2F11%2F22%2FPython%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Python列表访问列表元素123456789bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]print(bicycles[0])输出结果：trekbicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]print(bicycles[-1])输出结果：specialized 通过元素索引即可访问列表数据 索引从0开始，-1表示最后一个元素，-2表示倒数第二个元素，以此类推 使用列表中的各个值12345bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]message = &quot;My first bicycles was a &quot; + bicycles[0].title() + &quot;.&quot;print(message)输出结果：My first bicycles was a Trek . 字符串拼接通过 + 号连接 title() 函数可以将字符串首字母变大写 修改列表元素123456bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]# 修改第一个元素为 fenghuangpaibicycles[0] = &apos;fenghuangpai&apos;print(bicycles)输出结果：[&apos;fenghuangpai&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;] #是注释的开始 通过索引找到元素，然后赋新的值给该索引对应的元素即可修改 添加列表元素12345678910111213bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]# 在列表末尾添加 fenghuangpai 元素bicycles.append(&apos;fenghuangpai&apos;) print(bicycles)输出结果：[&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;,&apos;fenghuangpai&apos;]bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]# 在列表中添加 fenghuangpai 元素bicycles.insert(1，&apos;fenghuangpai&apos;) print(bicycles)输出结果：[&apos;trek&apos;,&apos;fenghuangpai&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;] append() 函数在列表末尾添加元素 insert() 函数可以通过索引去指定位置添加元素，注意数组越界 删除列表元素123456789101112131415161718192021222324252627# 使用 del 语句删除元素bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]del bicycles[0]print(bicycles)输出结果：[&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]# 使用pop()删除元素bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]poped_bicycles = bicycles.pop()print(poped_bicycles)输出结果：[&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;]# 弹出列表中任意位置的元素bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]poped_bicycles = bicycles.pop(1)print(poped_bicycles)输出结果：[&apos;trek&apos;,&apos;redline&apos;,&apos;specialized&apos;]# 根据值删除元素bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]poped_bicycles = bicycles.remove(&apos;redline&apos;)print(poped_bicycles)输出结果：[&apos;trek&apos;,&apos;cannondale&apos;,&apos;specialized&apos;] pop() 和 del 的区别 如果要从列表中删除一个元素且不再以任何方式使用它，就用del语句，如果你在删除元素后还要继续使用它，就使用pop() 列表排序1234567891011121314151617181920# 字母正序bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]bicycles.sort()print(bicycles)输出结果：[&apos;cannondale&apos;,&apos;redline&apos;,specialized&apos;,&apos;trek&apos;]# 字母反序bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]bicycles.sort(reverse=True)print(bicycles)输出结果：[&apos;trek&apos;,&apos;specialized&apos;,&apos;redline&apos;,&apos;cannondale&apos;]# 倒着打印bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]bicycles.reverse()print(bicycles)输出结果：[&apos;specialized&apos;,&apos;redline&apos;,&apos;cannondale&apos;,&apos;trek&apos;] ​ 获取列表长度1234bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]len(bicycles)输出结果：4]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoordinatorLayout结合AppBarLayout使用]]></title>
    <url>%2F2017%2F11%2F19%2FCoordinatorLayout%E7%BB%93%E5%90%88AppBarLayout%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[实现的效果 分析 Toolbar 随着列表的滑动而动态显示 FloatingActionButton 在列表上划时隐藏，下拉时显示 实现 Toolbar 随着列表的滑动而动态显示 这里是将Toolbar嵌套到了AppbarLayout这个控件中，并设置这个属性app:layout_scrollFlags=&quot;scroll|enterAlways&quot;，然后在可滑动的控件中添加上一个布局行为app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; app:layout_scrollFlags:这是滑动标志，设置scroll表示在可滑动列表上滑时Toolbar会一起向上滑动并隐藏，它还有其他值可以设置（如果使用了其他值，必定要再添加上这个值才能起作用），enterAlways表示可滑动列表向下滑动时Toolbar会跟着一起向下滑动显示；snap:表示子View 随着可滑动列表的滑动而直接隐藏或者显示，没有中间子 View 显示的过程；enterAlwaysCollapsed:是enterAlways的增强版，它表示可滑动列表下滑 Toolbar 也跟着下滑，当超过Toolbar的高度后才开始显示子 View，这个子View一般是AppBarLayout布局里面的 view；exitUntilCollapsed：当可滑动列表上划时Toolbar直接显示在顶部，子 View 滑出屏幕。 AppbarLayout 内部继承了一个垂直的LinearLayout，并在内部做了很多滚动的操作 布局代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.xxxx.xxx.xxActivity&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;!--封装的一个toolbar--&gt; &lt;com.dongxi.rxdemo.widget.CustomToolbar android:id=&quot;@+id/custom_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;@color/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll|enterAlways&quot; &gt; &lt;/com.dongxi.rxdemo.widget.CustomToolbar&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:id=&quot;@+id/swipe_refresh&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; &gt; &lt;com.dongxi.rxdemo.widget.EmptyRecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;/com.dongxi.rxdemo.widget.EmptyRecyclerView&gt; &lt;!--空视图--&gt; &lt;include android:id=&quot;@+id/empty_view&quot; layout=&quot;@layout/recyclerview_empty_layout&quot;/&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; &lt;!--悬浮按钮--&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|end&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@mipmap/ic_launcher&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; FloatingActionButton 在列表上划时隐藏，下拉时显示 这个可以有很多方式实现，推荐一篇写的不错的文章FloatingActionButton滚动时的显示与隐藏小结 我这里实现的就比较简单了，思路是在RecyclerView 滑动的时候，去监听滑动状态，如果滑动的距离大于0则上划，需要隐藏悬浮按钮，如果滑动的距离小于0则是下滑，需要展示悬浮按钮，代码如下： 12345678910111213141516mRecyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); if (dy &gt; 0)&#123; mFab.setVisibility(View.GONE); &#125;else &#123; mFab.setVisibility(View.VISIBLE); &#125; &#125; &#125;); 源码地址GitHub]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础（一）-数据类型]]></title>
    <url>%2F2017%2F11%2F19%2FPython%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Python入坑 想学 Python 的原因主要是想学一门后端语言，同时 Python 强大的爬虫功能页深深吸引了我。 谨以此系列记录我的 Python 入坑生涯。 变量和简单的数据类型 安装环境就不说了，Python的环境配置相对于其他语言来说，那简直就是太简单了。 输出 Hello Python 安装好 Python 环境（这里是 window10） 打开命令窗口 win + R 输入 cmd , 回车，然后输入 python 可以看到 python 的版本号就是环境配置对了 输入 print(‘hello python’)，得到输出结果：hello python 变量-输出字符串 将字符串 ‘ hello python ’ 赋值给 hello 变量 通过 print 方法输出这个变量的值 修改字符串的大小写 将字符串 aller dong 赋值给 name 这个变量 name.title()：将字符串的首字母转为大写 name.upper()：将字符串中的小写字母转为大写字母 name.lower()：将字符串中的大写字母转为小写字母 使用制表符或者换行符来添加空白，去掉字符串中的空白 \n 换行 \t 制表符 rstrip() 去掉字符串中的空白 Python 使用两个乘号表示乘方 使用 str() 可以看出，在字符串中添加 int 类型会报类型转换错误 123会报类型转换错误age = 23msg = &quot; Happy &quot; + age + &quot; birthday &quot; 如果一个变量未定义，会报变量未定义的错误 123会报 &apos;birthday&apos; 未定义，str(age) 是将整型类型转为字符串类型，这样就不会报类型转换错误了age = 23msg = &quot; Happy &quot; + str(age) + birthday 正确写法 123输出：Happy 23 birthdayage = 23msg = &quot; Happy &quot; + str(age) + &quot; birthday &quot;]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoordinatorLayout 初步使用]]></title>
    <url>%2F2017%2F11%2F14%2FCoordinatorLayout-%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[介绍 CoordinatorLayout是一个加强版的FrameLayout,这个布局是Design Support库提供，通常情况下和FrameLayout的使用是一样的。 区别是：CoordinatorLayout 可以监听其所有子控件的各种事件，然后自动帮助我们做出最为合理的响应。举个常见的例子，Snackbar 和悬浮按钮FloatingActionButton的自动同步，效果如下： 使用只需要两步即可实现！ 第一步：在布局中添加FloatingActionButton控件 123456789101112131415&lt;android.support.design.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; ...//省略其他控件 &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|end&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@mipmap/ic_launcher&quot; android:elevation=&quot;10dp&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayo 第二步：在调用Snackbar的处添加如下内容 1234567891011Snackbar .make(view, &quot;hehe&quot;, Snackbar.LENGTH_SHORT) .setAction(&quot;heheda&quot;, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(CardRecycleViewActivity.this,CollapsingToolbarActivity.class) ; intent.putExtra(&quot;name&quot;,mStringList.get(position)) ; startActivity(intent); &#125; &#125;) .show(); 解析 第一步就是添加控件，没什么说的 可以看到第二步中的Snackbar.make()方法中传入了一个view，这个view只要是CoordinateLayout的直接子view就行。可以在setAction()方法中处理点击事件（这里是跳转了下一个activity） 第三步…简单使用就是这么简单，没有第三步了。 代码地址Github]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager+GridView实现水平滑动和点击背景色切换]]></title>
    <url>%2F2017%2F11%2F12%2FViewPager-GridView%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E6%BB%91%E5%8A%A8%E5%92%8C%E7%82%B9%E5%87%BB%E8%83%8C%E6%99%AF%E8%89%B2%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[需求 实现2行4列，可以水平滑动的列表，有指示器提示当前页，同时点击切换背景色，如下图： 分析 2行4列，水平滑动 用GridView实现网格效果，水平滑动用ViewPager实现 指示器指示当前页 直接在ViewPager下方设置一个ViewGroup，用于动态显示指示器 点击当前页的某一项，更换这一项的背景色（这里有个坑，下文分析） 给数据设置一个标志参数，选中设置为true ，未选中设置为false ，选中后刷新页面 实现网上有大神已经实现了基本的效果,，我这里分析上面说到的一个坑 网上大神实现的效果（没有实现点击切换背景色），链接如下： https://www.cnblogs.com/wangfengdange/archive/2016/10/27/6004576.html 上面链接实现的效果有人说可以在adapter中设置一个临时变量，然后点击的时候改变这个临时变量，在adapter 的getVIew()方法中判断这个变量去显示背景色，这中方法在这里我没实现出效果，可能是我姿势不对吧，有实现的可以告知一下谢谢。邮箱：Aller_Dong@163.com 网上实现点击切换背景色的办法（我没实现出来）猜测可能原因是GridView是动态添加到ViewPager中导致 https://yq.aliyun.com/wenzhang/show_48022 当然了，需求下来肯定要实现的。点击切换背景（这里需要感谢成哥的指导）。话不多说我的实现如下： 设置一个全局变量用于存储点击的position 设置一个Map集合，用于存储点击的position所在ViewPager的页码，key为页码，value为对应的position 用一个集合去存储adapter 在ViewPager的setOnPageChangeListener方法中去监听滑动，如果当前页没有Item被点击,那么遍历所有的数据，给数据的标志设为false，如果有点击项，给点击的数据的标志设置为true，最后notifyDataSetChange() 源码地址 代码主要在viewpager_gridview包下，这是个需求demo的测试项目，代码很乱，请见谅! GitHub]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 动态处理文本的两种半~方式]]></title>
    <url>%2F2017%2F10%2F28%2FAndroid-%E5%8A%A8%E6%80%81%E5%A4%84%E7%90%86%E6%96%87%E6%9C%AC%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[（以上文字纯属乱写，如有雷同，那就告诉我…天底下还有人比我帅了？？）实现的效果就像这样，不知道是不是叫做动态处理文本。效果就是这么个效果，实现就是这么去实现，看下文分析。 使用场景需要高亮文本中的某些内容，以突出重要的数据或者诱导用户去点击该内容。实现方式可以通过Html.fromHtml()方式和SpannableStringBuilder( 或者SpannableString )去实现。 Tip: SpannableStringBuilder和SpannableString 的区别是 SpannableString 无法更改 String 的内容，也无法拼接多个 SpannableString； SpannableStringBuilder 则可以通过其append()方法来拼接多个String，这里只介绍了SpannableStringBuilder的实现方式。 Html.fromHtml( ) 方式 Android目前不支持全部的HTML的标签，目前只支持与文本显示和段落等标签，对于图片和其他的多媒体，还有一些自定义标签不能识别; 实现效果 使用方式 首先需要拿到你要高亮的字符串，通过html标签去设置，下面的代码用到了font标签和strong标签。 然后通过Html.from(string) 方法去解析该字符串即可实现效果。 12String str2 = &quot;我要&lt;font color=&apos;#FF4081&apos;&gt;打赏&lt;/font&gt;这个内容，&lt;strong&gt;&lt;font color=&apos;#FF4081&apos;&gt;作者太TM帅&lt;/font&gt;&lt;/strong&gt;了balabala，谁也不许拦我，除非她给我发红包，或者点个Star&quot;; mTvTestHtmlText.setText(Html.fromHtml(str2)); SpannableStringBuilder 方式 使用方式 主要是通过 setSpan() 方法去实现，由于该方法能够同时使用多个，因此同一个字符串的长度内的内容可以有多种显示效果， 例如：效果图中的打赏二字，添加了下划线的同时字体的颜色页变成偏蓝色，而且还添加了点击效果哦 组合使用实现的效果：代码中有注释，挺好理解的 需要注意的是setSpan方法的最后一个参数，这个参数的含义是：控制第二和第三个参数的生效范围。它有四个可选值，分别是 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE(前后都不包括，前指的是第二个参数，后指的是第三个参数) Spanned.SPAN_INCLUSIVE_EXCLUSIVE(前面包括，后面不包括) Spanned.SPAN_EXCLUSIVE_INCLUSIVE(前面不包括，后面包括) Spanned.SPAN_INCLUSIVE_INCLUSIVE(前后都包括) 12345678910111213141516171819202122232425262728String str2 = &quot;我要&lt;font color=&apos;#FF4081&apos;&gt;打赏&lt;/font&gt;这个内容，&lt;strong&gt;&lt;font color=&apos;#FF4081&apos;&gt;作者太TM帅&lt;/font&gt;&lt;/strong&gt;了balabala，谁也不许拦我，除非她给我发红包，或者点个Star&quot;;SpannableStringBuilder builder = new SpannableStringBuilder(str1);// &quot;我要&quot;字体颜色变为粉色，Spanned.SPAN_EXCLUSIVE_INCLUSIVE 表示起始和终止的模式为：包左不包右builder.setSpan(new ForegroundColorSpan(Color.parseColor(&quot;#FF4081&quot;)), 0, 2, Spanned.SPAN_EXCLUSIVE_INCLUSIVE);// 设置背景色builder.setSpan(new BackgroundColorSpan(Color.parseColor(&quot;#009ad6&quot;)), 4, 6, Spanned.SPAN_EXCLUSIVE_INCLUSIVE);// 设置字体大小（绝对值,单位：像素） builder.setSpan(new AbsoluteSizeSpan(80), 12, 14, Spanned.SPAN_EXCLUSIVE_INCLUSIVE);// 设置粗体和斜体builder.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 15, 23, Spanned.SPAN_EXCLUSIVE_INCLUSIVE);// 设置删除线builder.setSpan(new StrikethroughSpan(), 23, 29, Spanned.SPAN_EXCLUSIVE_INCLUSIVE);// 设置下划线builder.setSpan(new UnderlineSpan(), 29, 35, Spanned.SPAN_EXCLUSIVE_INCLUSIVE);// 设置图片builder.setSpan(new ImageSpan(this, R.mipmap.ic_launcher), 35, 38, Spanned.SPAN_EXCLUSIVE_INCLUSIVE);// 设置点击builder.setSpan(new ClickableSpan() &#123; @Override public void onClick(View widget) &#123; Toast.makeText(MainActivity.this, &quot;点击了打赏&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;, 2, 4, Spanned.SPAN_EXCLUSIVE_INCLUSIVE);mTvTestSpannerText.setText(builder);// 设置点击mTvTestSpannerText.setMovementMethod(LinkMovementMethod.getInstance()); 还有一种方式实现 TextView 文本的删除线，加粗，下划线，斜体123456789//代码中添加删除线textView1.getPaint().setFlags(Paint.STRIKE_THRU_TEXT_FLAG); //在代码中设置加粗 textView2.getPaint().setFlags(Paint.FAKE_BOLD_TEXT_FLAG); //添加下划线 textView3.getPaint().setFlags(Paint.UNDERLINE_TEXT_FLAG); 在 xml 布局中设置加粗，斜体可以这么添加android:textStyle=&quot;italic|bold&quot; 项目地址这是一个我平时遇到的不能一下子实现的功能而做的 Demo 仓库，里面实现的内容很杂，想到什么就去实现什么，所以见谅吧。 地址是： AndroidLeaningDemo 在166~197行左右]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View绘制基础]]></title>
    <url>%2F2017%2F10%2F21%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%B8%B8%E8%A7%81API%2F</url>
    <content type="text"><![CDATA[学习来源：HenCoder 总结 主要介绍使用 Paint 和 Canvas 绘制的常见API paint 是画笔，能够添加画笔的颜色pain.setColor(int color)、画笔绘制的模式（实心paint.setStyle(Paint.Style.FILL)，空心paint.setStyle(Paint.Style.STROKE)）、画笔绘制的文本大小paint.setTextSize(int size)，是否抗锯齿方式一：Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG)；方式二：paint.setAntiAlias(boolean open)（开启抗锯齿会使绘制的边缘更平滑），设置画笔的宽度paint.setStrokeWWidth(int width) 使用 canvas 能够绘制线段(drawLine())、圆形(drawCircle())、画椭圆(drawOval())、扇形(drawArc())、矩形(drawRect())、画点(drawPoint())、文字(drawText())、图形drawPath()（图形包括所有能绘制的规则和不规则的内容）、Bitmap(drawBitmap()) 绘制的关键 自定义绘制的方式是重写绘制方法，其中最常用的是 onDraw() 绘制的关键是 Canvas 的使用 Canvas 的绘制类方法： drawXXX() （关键参数：Paint） 可以使用不同的绘制方法来控制遮盖关系(path.setFillType(FillType filltypr)) EVEN_ODD WINDING （默认值） INVERSE_EVEN_ODD INVERSE_WINDING 从 onDraw( ) 开始表演吧 先来段代码看看如何开始自定义view 1234567891011121314151617181920212223public class Practice01View extends View &#123; Paint paint = new Paint(); public Practice01ClipRectView(Context context) &#123; super(context); &#125; public Practice01ClipRectView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public Practice01ClipRectView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 绘制一个圆 canvas.drawCircle(300, 300, 200, paint); &#125;&#125; 步骤： 创建一个类继承自View 重写三个构造方法 重写 onDraw() 方法 可以看出在onDraw中用到了两个参数 canvas , paint paint：相当于画笔的作用 canvas : 相当于画布的作用 ​ Paint 常用的方法： Paint.setStyle(Style style) 设置绘制模式 Paint.setColor(int color) 设置颜色 Paint.setStrokeWidth(float width) 设置线条宽度 Paint.setTextSize(float textSize) 设置文字大小 Paint.setAntiAlias(boolean aa) 设置抗锯齿开关 Canvas 常用的方法： canvas.drawColor(int color)：在整个绘制区域统一涂上参数所指定的颜色，主要用于绘制背景色 canvas.drawRGB(int r, int g, int b)：效果同上 canvas.drawARGB(int a, int r, int g, int b)：效果同上 canvas.drawCircle(float centerX, float centerY, float radius, Paint paint)：画圆 canvas.drawRect(float left, float top, float right, float bottom, Paint paint)：画矩形 canvas.drawPoint(float x, float y, Paint paint)：画点，x,y是点的坐标 canvas.drawPoints(float[] pts, int offset, int count, Paint paint) / drawPoints(float[] pts, Paint paint)：批量画点 canvas.drawOval(float left, float top, float right, float bottom, Paint paint)：画椭圆 canvas.drawLine(float startX, float startY, float stopX, float stopY, Paint paint)：画线 drawLines(float[] pts, int offset, int count, Paint paint) / drawLines(float[] pts, Paint paint) 画线（批量） canvas.drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)：画圆角矩形 canvas.drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean userCenter, Paint paint)：画扇形或者弧形 canvas.drawPath(Path path, Paint paint)：画自定义的图形,Path 可以描述直线、二次曲线、三次曲线、圆、椭圆、弧形、矩形、圆角矩形。把这些图形结合起来，就可以描述出很多复杂的图形 Path 有两类方法，一类是直接描述路径的，另一类是辅助的设置或计算Path 方法第一类：直接描述路径，添加子图形和画线（直线或曲线）第一组： addXxx() ——添加子图形 addCircle(float x, float y, float radius, Direction dir) 添加圆最后一个参数 dir 是画圆的路径的方向。路径方向有两种：顺时针 (CW clockwise) 和逆时针 (CCW counter-clockwise) 。对于普通情况，这个参数填 CW 还是填 CCW 没有影响。它只是在需要填充图形 (Paint.Style 为 FILL 或 FILL_AND_STROKE) ，并且图形出现自相交时，用于判断填充范围的。 addOval(float left, float top, float right, float bottom, Direction dir) 添加椭圆 addOval(RectF oval, Direction dir) 添加椭圆 addRect(float left, float top, float right, float bottom, Direction dir) 添加矩形 addRect(RectF rect, Direction dir) 添加矩形 addRoundRect(RectF rect, float rx, float ry, Direction dir) 添加圆角矩形 addRoundRect(float left, float top, float right, float bottom, float rx, float ry, Direction dir) 添加圆角矩形 addRoundRect(RectF rect, float[] radii, Direction dir) 添加圆角矩形 addRoundRect(float left, float top, float right, float bottom, float[] radii, Direction dir) 添加圆角矩形 addPath(Path path) 添加另一个 Path 第二组：xxxTo() ——画线（直线或曲线） lineTo(float x, float y) rLineTo(float x, float y) 画直线这两个方法的区别是，lineTo(x, y) 的参数是绝对坐标，而 rLineTo(x, y) 的参数是相对当前位置（最后一次绘制的坐标画 Path 的方法的终点位置。初始值为原点 (0, 0)）的相对坐标 quadTo(float x1, float y1, float x2, float y2) rQuadTo(float dx1, float dy1, float dx2, float dy2) 画二次贝塞尔曲线贝塞尔曲线是几何上的一种曲线。它通过起点、控制点和终点来描述一条曲线，主要用于计算机图形学 cubicTo(float x1, float y1, float x2, float y2, float x3, float y3) rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3) 画三次贝塞尔曲线（原理同上） moveTo(float x, float y) / rMoveTo(float x, float y) 移动到目标位置不论是直线还是贝塞尔曲线，都是以当前位置作为起点，而不能指定起点。但你可以通过 moveTo(x, y) 或 rMoveTo() 来改变当前位置，从而间接地设置这些方法的起点 arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo) arcTo(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean forceMoveTo) / arcTo(RectF oval, float startAngle, float sweepAngle) 画弧形这个方法和 Canvas.drawArc() 比起来，少了一个参数 useCenter，而多了一个参数 forceMoveTo 。少了 useCenter ，是因为 arcTo() 只用来画弧形而不画扇形，所以不再需要 useCenter 参数；而多出来的这个 forceMoveTo 参数的意思是，绘制是要「抬一下笔移动过去」，还是「直接拖着笔过去」，区别在于是否留下移动的痕迹。 addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle) addArc(RectF oval, float startAngle, float sweepAngle)又是一个弧形的方法。一个叫 arcTo ，一个叫 addArc()，都是弧形，区别在哪里？其实很简单： addArc() 只是一个直接使用了 forceMoveTo = true 的简化版 arcTo() 。 close() 封闭当前子图形 Path 方法第二类：辅助的设置或计算 Canvas 还可以绘制 Bitmap drawBitmap(Bitmap bitmap, float left, float top, Paint paint) 画 Bitmap drawBitmap(Bitmap bitmap, Rect src, RectF dst, Paint paint) drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint) drawBitmapMesh()，可以绘制具有网格拉伸效果的 Bitmap Canvas 还可以绘制文字 drawText(String text, float x, float y, Paint paint) 绘制文字]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 动画学习]]></title>
    <url>%2F2017%2F10%2F02%2FAndroid-%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[学习来源：Android应用开发之所有动画使用详解，KEEGAN小钢，Android 开发艺术探索 Android 中动画的介绍 作用 能够让静态的内容变得更加唯美，适当的动画能够给予用户更好的体验。 使用情景 引导页的渐变动画 图片的点击效果，缩放效果 … Android 中动画的分类和使用视图动画View Animation： 视图动画在古老的Android版本系统中就已经提供了，只能被用来设置View的动画 alpha：渐变透明度动画 1234&lt;alpha&gt; android:fromAlpha=&quot;float&quot; //动画开始时的透明度（0.0--1.0，0.0是全透明，1.0是不透明） android:toAlpha=&quot;float&quot; //动画结束时的透明度 &lt;/alpha&gt; alpha 实现淡入的效果 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot; /&gt; 将这动画效果添加到View上也只需要一行代码：view.startAnimation(AnimationUtils.loadAnimation(this, R.anim.fade_in)); rotate：画面转移旋转动画 1234567&lt;rotate&gt; android:fromDegrees=&quot;int&quot; //旋转开始角度，正数代表顺时针度数，负数代表逆时针度数 android:toDegrees=&quot;int&quot; //旋转结束角度 android:pivotX=&quot;float&quot; //缩放起点 X 坐标（数值，百分数，百分数p，例如 50表示以当前view左上角加 50px） android:pivotY=&quot;float&quot; //缩放起点 Y 坐标（50% 表示以当前 View 的左上角加上当前 view 宽高的 50% 作为起始点） （50%p 表示以当前 View 的左上角加上父控件宽高的 50% 作为起始点） &lt;/rotate&gt; rotate：以下示例代码旋转角度从0到360，即旋转了一圈，旋转的中心点都设为了50%，即是View本身中点的位置。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;2000&quot; android:fromDegrees=&quot;0&quot; android:toDegrees=&quot;360&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; /&gt; 在 Java 代码中使用RotateAnimation rotateAnimation = (RotateAnimation) AnimationUtils.loadAnimation(this, R.anim.rotate_one);view.startAnimation(rotateAnimation); scale：渐变尺寸伸缩动画 12345678&lt;scale&gt; android:fromXScale=&quot;float&quot; //初始 X 轴缩放比例，1.0表示无变化 android:toXScale=&quot;float&quot; //结束 X 轴缩放比例 android:fromYScale=&quot;float&quot; //初始 Y 轴缩放比例 android:toYScale=&quot;float&quot; //结束 Y 轴缩放比例 android:pivotX=&quot;float&quot; //缩放起点 X 轴坐标（参数含义同 rotate ） android:pivotY=&quot;float&quot; //缩放结束 Y 轴坐标&lt;/scale&gt; PS：以上四个属性，0.0表示缩放到没有，1.0表示正常无缩放，小于1.0表示收缩，大于1.0表示放大 android:pivotX 缩放时的固定不变的X坐标，一般用百分比表示，0%表示左边缘，100%表示右边缘 android:pivotY 缩放时的固定不变的Y坐标，一般用百分比表示，0%表示顶部边缘，100%表示底部边缘 scale 实现时长为一秒钟的view从原有样子放大到1.5倍的效果 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:pivotX=&quot;0%&quot; android:pivotY=&quot;100%&quot; android:toXScale=&quot;1.5&quot; android:toYScale=&quot;1.5&quot; /&gt; 在 Java 代码中使用ScaleAnimation zoomOutAnimation = (ScaleAnimation) AnimationUtils.loadAnimation(this, R.anim.zoom_out);view.startAnimation(zoomOutAnimation); translate：画面转移位置移动动画效果 123456&lt;translate&gt; android:fromXDelta=&quot;float&quot; //起始点 X 轴坐标（参数含义同 rotate ） android:fromYDelta=&quot;float&quot; //起始点 Y 轴坐标 android:toXDelta=&quot;float&quot; //结束点 X 轴坐标 android:toYDelta=&quot;float&quot; //结束点 Y 轴坐标&lt;/translate&gt; translate使用例子，以下代码实现的是从左到右的移动效果，起始位置为相对于控件本身-100%的位置，即在控件左边，与控件本身宽度一致的位置；结束位置为相对于父控件100%的位置，即会移出父控件右边缘的位置。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;2000&quot; android:fromXDelta=&quot;-100%&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;100%p&quot; android:toYDelta=&quot;0&quot; /&gt; 在 Java 代码中使用TranslateAnimation moveAnimation = (TranslateAnimation) AnimationUtils.loadAnimation(this, R.anim.move_left_to_right);view.startAnimation(moveAnimation); 帧动画Drawable Animation： 这种动画（也叫Frame动画、帧动画）其实可以划分到视图动画的类别，专门用来一个一个的显示Drawable的resources，就像放幻灯片一样。存放在 res/drawable目录下 12345678910&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshor=&quot;true&quot; : true 表示只执行一次，false 表示循环执行 &gt; &lt;item&gt; 每一帧的动画资源 android:drawable=&quot;drawable name &quot; : 资源文件 android:duration=&quot;1000&quot; : 一帧显示多长时间 &lt;/item&gt; &lt;/animation-list&gt; 使用方式 12345ImageView img = (ImageView)findViewById(R.id.img) ;img.setBackgroundResource(R.drawable.***) ;Animation imgAnimation = (AnimationDrawable)img.getBackground() ;imgAnimation.start() ; 使用注意 AnimationDrawable 的start() 方法不能在activity的 onCreat() 中调用， 因为AnimationDrawable还未完全附着到window上， 所以最好的调用时机时在onWindowFocusChange()方法中。onWindowFocusChange()方法在Activity生命周期中表示view的可视，onStart, onResume, onCreate都不是真正view visible的时间点，真正的view visible时间点是onWindowFocusChanged()函数被执行时。通过下面的执行流程可以清楚了解到AnimationDrawable 的使用时机。 123451. 启动: onStart----&gt;onResume----&gt;onAttachedToWindow-----------&gt;onWindowVisibilityChanged--visibility=0----------&gt;onWindowFocusChanged(true)-------&gt;2. 锁屏: onPause----&gt;onStop----&gt;onWindowFocusChanged(false) -----------(lockscreen)3. 进入下一个页面 : onPause-----&gt;onWindowFocusChanged(false)------&gt;onWindowVisibilityChanged----visibility=8------------&gt;onStop(to another activity) 属性动画Property Animation： 属性动画只对Android 3.0（API 11）以上版本的Android系统才有效，对于低版本的可以使用开源动画库nineoldandroids去实现兼容，它在低版本的实现也是通过View动画实现，只是使用方式像属性动画。属性动画可以设置给任何Object，包括那些还没有渲染到屏幕上的对象。并且属性动画是可扩展的，可以让你自定义任何类型和属性的动画。 属性动画提供的属性有： 123456Duration : 动画的持续时间TimeInterpolation: 定义动画变化速率的接口，所有插值器都必须实现此接口，如线性、非线性插值器TypeEvaluator: 用于定义属性值计算方式的接口，有int,float,color 类型Animation sets: 动画集合，即可以对一个对象应用多个动画Frame refresh delay: 多少时间刷新一次，默认为10ms,最终的刷新时间还受系统进程调度和硬件影响Repeat Country and behavior: 重复次数与方式 属性动画的可以使用在xml中和Java代码中，下面是属性动画在xml中的使用姿势 12345678910111213141516171819202122232425262728293031&lt;set android:ordering=&quot;together|sequentially&quot; // 控制动画的启动方式，together（默认）表示同时执行，sequentially表示按照顺序先后执行 &gt; ... &lt;objectAnimator&gt; android:propertyName=&quot;string&quot; // 必须要设置的节点属性，代表执行动画的属性（通过改名字去引用） android:duration=&quot;int&quot; // 动画时常，默认是300 ms android:valueFrom=&quot;folat|int|color&quot; // 动画的起始点 android:valueTo=&quot;folat|int|color&quot; // 必须要设置的节点属性，表明动画结束的点 android:startOffset=&quot;int&quot; // 动画延迟的时间，毫秒为单位 android:repeatCount=&quot;int&quot; // 动画的重复次数，0表示不重复（默认），-1表示无线重复，1表示执行完动画后再重复一次，也就是动画执行两次 android:repeatMode=&quot;repeat|reverse&quot; //重复的模式 android:valueType=&quot;intType|floatType&quot; //关键参数，如果该value是一个颜色，那么不需要指定该值。 &lt;/objectAnimator&gt; &lt;animation&gt; android:duration=&quot;int&quot; android:valueFrom=&quot;folat|int|color&quot; android:valueTo=&quot;folat|int|color&quot; android:startOffset=&quot;int&quot; android:repeatCount=&quot;int&quot; android:repeatMode=&quot;repeat|reverse&quot; android:valueType=&quot;intType|floatType&quot; &lt;/animation&gt; ... &lt;/set&gt;在 Java 代码中调用的方式：AnimatorSet set = AnimatorInflater.loadAnimation(context,R.animator,****); // 获取动画资源set.setTarget(object) ; // 给目标对象设置动画set.start() ; // 启动动画 大多数的情况使用 ObjectAnimator 就足够了，因为它是的目标对象动画值的处理过程变得足够简单，不用像ValueAnimator那样自己写动画更新的逻辑，但是使用 ObjectAnimator 也有一些限制，比如它需要目标对象的属性提供指定的处理方法（譬如：getXXX,setXXX方法）注意: ObjectAnimator 的动画原理是不停的调用setXXX方法更新属性值，所有使用 ObjectAnimator更新属性时的前提时 Object 必须声明有getXXX方法 属性代码在Java中的使用姿势，习惯上使用Java代码去实现，容易理解一些。 123D 旋转动画实例：ObjectAnimator.ofFloat(view,&quot;rotationY&quot;,0.0f,360.0f).setDuration(1000).start() ; ViewPropertyAnimator ViewPropertyAnimator 提供了一种可以使多个属性同时做动画的简单方法，而且它在内部只使用一个 Animator。当它计算完这些属性的值之后，它直接把那些值赋给目标 View 并 invalidate 那个对象（自动执行动画，不用 start() ），而它完成这些的方式比普通的 ObjectAnimator 更加高效。 1234使用方式：View.animate() 后跟 translationX() 等方法，动画会自动执行 例如： myView.animate().alpha(0); myView.animate().x(50f).y(100f); AnimatorSet AnimatorSet 顾名思义就是动画集合，例如下面的代码实现了view对象从不透明到透明的动画后，接着在Y轴上移动了viewWidth的宽度 123456789ObjectAnimator a1 = ObjectAnimator.ofFloat(view,&quot;alpha&quot;,1.0f,0f) ; // 从不透明到透明ObjectAnimator a2 = ObjectAnimator.ofFloat(view,&quot;translationY&quot;,0.0f,viewWidth) ; // 从 0 到view的宽度移动...AnimatorSet set = new AnimatorSet() ;set.setDuration(2000) ;set.setInterpolator(new LinearInterpolater()) ; // 设置线性匀速插值器set.play(a1).after(a2) ;... // 其他组合方式set.start() ; set.play(a1).after(a2):表示先执行动画 a1 后再执行动画 a2，也可以这么写set.playSequentially(a1, a2);效果是一样的。set.play(a1).with(a2): 表示a2和a1一块执行，set.play(a1).before(a2);表示先执行动画a2 然后再执行动画 a1，set.playTogether(a1, a2)：表示两个动画通知执行。 setInterpolator:其实就是速度设置器，大致有以下速度设置效果 AccelerateDecelerateInterpolator：先加速再减速，默认效果 LinearInterpolator：一直匀速 AccelerateInterpolator：一直加速 DecelerateInterpolator：一直减速 AnticipateInterpolator：先回拉一下再进行正常动画轨迹 OvershootInterpolator：动画会超过目标值一些，然后再弹回来 AnticipateOvershootInterpolator：开始前回拉，最后超过一些然后回弹 BounceInterpolator：在目标值处弹跳一会后停止 CycleInterpolator：这个也是一个正弦 / 余弦曲线，它和 AccelerateDecelerateInterpolator 的区别是，它可以自定义曲线的周期，所以动画可以不到终点就结束，也可以到达终点后回弹，回弹的次数由曲线的周期决定，曲线的周期由 CycleInterpolator() 构造方法的参数决定 PathInterpolator：自定义动画完成度 / 时间完成度曲线，用这个 Interpolator 你可以定制出任何你想要的速度模型。定制的方式是使用一个 Path 对象来绘制出你要的动画完成度 / 时间完成度曲线 FastOutLinearInInterpolator：加速运动，FastOutLinearInInterpolator 的曲线公式是用的贝塞尔曲线，而 AccelerateInterpolator 用的是指数曲线。具体来说，它俩最主要的区别是 FastOutLinearInInterpolator 的初始阶段加速度比 AccelerateInterpolator 要快一些。 给动画设置监听 ViewPropertyAnimator 和 ObjectAnimator 略微不一样： ViewPropertyAnimator 用的是 setListener() 和 setUpdateListener() 方法，可以设置一个监听器，要移除监听器时通过 set[Update]Listener(null) 填 null 值来移除；而 ObjectAnimator 则是用 addListener() 和 addUpdateListener() 来添加一个或多个监听器，移除监听器则是通过 remove[Update]Listener() 来指定移除对象。 另外，由于 ObjectAnimator 支持使用 pause() 方法暂停，所以它还多了一个 addPauseListener() / removePauseListener() 的支持；而 ViewPropertyAnimator 则独有 withStartAction() 和 withEndAction() 方法，可以设置一次性的动画开始或结束的监听 硬件加速 对于 Android 来说，硬件加速有它专属的意思：在 Android 里，硬件加速专指把 View 中绘制的计算工作交给 GPU 来处理 四个层次级别的硬件加速1、整个应用 Application 层，设置为 true 则开启，false 则关闭 1&lt;application android:hardwareAccelerated=&quot;true&quot;&gt; 2、Activity 层，设置为 true 则开启，false 则关闭 1&lt;activity android:hardwareAccelerated=&quot;true&quot;&gt; 3、Window 层，只能打开(必须在 setContentView 之前调用) 1getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); 4、View 层，只能关闭。也可在 XML 使用android:layerType=&quot;software&quot; 来关闭硬件加速 1view.setLayerType(View.LAYER_TYPE_SOFTWARE, null); 获取是否支持硬件加速方法有两种方式： 使用 View 的 isHardwareAccelerated() 如果返回 true 则说明它在绘制的时候使用了硬件加速。 使用 Canvas 的 isHardwareAccelerated() 如果 canvas 在绘制的时候启用了硬件加速，返回 true。 硬件加速谨慎使用 它可以加速无 invalidate() 时的刷新效率，但对于需要调用 invalidate() 的刷新无法加速。 使用硬件加速绘制所消耗的实际时间是比不使用硬件加速时要高的，所以要慎重使用 引导页动画例子 实现的效果如下，代码来自这位仁兄iwgang 分析效果图 三张图片，每张图片顶部有标题的描述。图片的边角是会露出。当用户左划或者右滑到一定的距离，之前或者之后的图片需要缩小和放大、文字需要淡入或者淡出。例如：第一次启动App显示第一张图篇和文字，当用户左划到第二章图片全部显示的这个过程，这个过程的动画是第一张图片往左缩小、文字往左淡出，第二张的图片逐渐放大、文字淡入直至全部显示。最后的那个立即体验按钮是通过判断是否是最后一张图片而去动态显示的。 这里源码作者的实现是采用VIewPager去实现翻页效果。 第一个问题：图片的边角露出如何实现？ 利用ViewPager的一个方法去实现，源码中是这么用的：mViewPager.setPageMargin(-dip2px(135));dip2px是作者封装的屏幕分辨率工具。 第二个问题：滑动视差效果如何实现？ 也是利用ViewPager的一个方法是实现，mViewPager.setPageTransformer(false, new ViewPager.PageTransformer() {}这个方法是ViewPager提供的页面切换时的动画效果。 在重写的transformPage(View view, float position)中去实现滑动的视差动画。通过判断当前的position从第一页到第二页position的变化是第一页的变化是[0，-1]，第二页的变化是[1,0]。如果是第一页则图片不缩放，文字标题和描述不缩放、透明度为不透明；如果是第二页则图片XY方向缩放为原来图片的0.85f倍，文字变为透明。以此类推。 123456789101112131415161718192021 if (position &lt; -1) &#123; //[-无穷，-1]的情况 mTitle.setAlpha(0); mDesc.setAlpha(0);&#125; else if (position &lt;= 1) &#123; //[-1，1]的情况 float scaleFactor = Math.max(0.85f, 1 - Math.abs(position)); float scaleTxtFactor = Math.max(0.0f, 1 - Math.abs(position)); mGuideImage.setScaleX(scaleFactor); mGuideImage.setScaleY(scaleFactor); mTitle.setScaleX(scaleTxtFactor); mTitle.setScaleY(scaleTxtFactor); mTitle.setAlpha(0.0f + (scaleTxtFactor - 0.0f) / (1 - 0.0f) * (1 - 0.0f)); mDesc.setAlpha(mTitle.getAlpha()); mDesc.setScaleX(scaleTxtFactor); mDesc.setScaleY(scaleTxtFactor);&#125; else &#123; // [1，正无穷]的情况 mTitle.setAlpha(0); mDesc.setAlpha(0);&#125; 源码实现视差引导页]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Shape 笔记]]></title>
    <url>%2F2017%2F09%2F30%2FAndroid%20Shape%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学习来源 KEEGAN小钢，谢谢大神分享。 Shape 的作用shape用于设定形状，可以在selector，layout等里面使用。 可以设定的形状有：rectangle ( 矩形 )，line ( 直线 )，ring ( 环形 )，oval ( 椭圆 ) 在selector中这么使用 如下面代码中写的在没点击或者没有呗触摸的时候显示的是point1图片，触摸或者点击的时候显示的是设置的shape_bg_ring样式，在代码中这么设置即可：android:drawable=&quot;@drawable/shape_bg_ring，具体的样式代码在Shape的设定形状用法中实现。 12345&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_enabled=&quot;true&quot; android:drawable=&quot;@drawable/shape_bg_ring&quot; /&gt; &lt;item android:state_enabled=&quot;false&quot; android:drawable=&quot;@drawable/point1&quot; /&gt;&lt;/selector&gt; 在layout中这么使用 在View的background属性里设置我们写好的shape样式android:background=&quot;@drawable/shape_bg_oval_with_gradient&quot; 12345678&lt;TextView android:id=&quot;@+id/id_link&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/shape_bg_oval_with_gradient&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_marginBottom=&quot;16dp&quot; android:text=&quot;gogogogogo&quot;/&gt; Shape 的设定形状的用法 rectangle rectangle 定义的是矩形，它有以下属性： 12345678910111213141516171819202122232425262728293031323334solid: 设置形状填充的颜色，只有android:color一个属性 android:color 填充的颜色padding: 设置内容与形状边界的内间距，可分别设置左右上下的距离android:left 左内间距android:right 右内间距android:top 上内间距android:bottom 下内间距gradient: 设置形状的渐变颜色，可以是线性渐变、辐射渐变、扫描性渐变android:type 渐变的类型linear 线性渐变，默认的渐变类型radial 放射渐变，设置该项时，android:gradientRadius也必须设置sweep 扫描性渐变android:startColor 渐变开始的颜色android:endColor 渐变结束的颜色android:centerColor 渐变中间的颜色android:angle 渐变的角度，线性渐变时才有效，必须是45的倍数，0表示从左到右，90表示从下到上android:centerX 渐变中心的相对X坐标，放射渐变时才有效，在0.0到1.0之间，默认为0.5，表示在正中间android:centerY 渐变中心的相对X坐标，放射渐变时才有效，在0.0到1.0之间，默认为0.5，表示在正中间android:gradientRadius 渐变的半径，只有渐变类型为radial时才使用android:useLevel 如果为true，则可在LevelListDrawable中使用corners: 设置圆角，只适用于rectangle类型，可分别设置四个角不同半径的圆角，当设置的圆角半径很大时，比如200dp，就可变成弧形边了android:radius 圆角半径，会被下面每个特定的圆角属性重写android:topLeftRadius 左上角的半径android:topRightRadius 右上角的半径android:bottomLeftRadius 左下角的半径android:bottomRightRadius 右下角的半径stroke: 设置描边，可描成实线或虚线。android:color 描边的颜色android:width 描边的宽度android:dashWidth 设置虚线时的横线长度android:dashGap 设置虚线时的横线之间的距离 rectangle使用例子 先在drawable目录下创建一个drawable文件shape_rectangle.xml，然后在View中设置给background属性就OK了 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;!--填充的颜色--&gt; &lt;solid android:color=&quot;@color/colorPrimary&quot;/&gt; &lt;!--设置内容区域距离边界的范围--&gt; &lt;padding android:bottom=&quot;10dp&quot; android:top=&quot;10dp&quot; android:left=&quot;5dp&quot; android:right=&quot;5dp&quot;/&gt; &lt;!--设置圆角，只适用于rectangle--&gt; &lt;corners android:radius=&quot;20dp&quot;/&gt; &lt;!--设置描边 dashWidth 设置虚线时的横线长度 dashGap 设置虚线时的横线之间的距离--&gt; &lt;stroke android:width=&quot;2dp&quot; android:dashGap=&quot;4dp&quot; android:dashWidth=&quot;4dp&quot; android:color=&quot;@color/colorAccent&quot;/&gt;&lt;/shape&gt; line line主要用于画分割线，是通过stroke和size特性组合来实现的。 画线时，有几点特性必须要知道的： 只能画水平线，画不了竖线； 线的高度是通过stroke的android:width属性设置的； size的android:height属性定义的是整个形状区域的高度； size的height必须大于stroke的width，否则，线无法显示； 线在整个形状区域中是居中显示的； 线左右两边会留有空白间距，线越粗，空白越大； 引用虚线的view需要添加属性android:layerType，值设为”software”，否则显示不了虚线。 line 使用例子 也是需要先在drawable目录下创建xml文件，然后对对应的View设置即可。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;line&quot;&gt; &lt;stroke android:width=&quot;5dp&quot; android:color=&quot;@color/colorAccent&quot; android:dashGap=&quot;2dp&quot; android:dashWidth=&quot;5dp&quot;/&gt; &lt;!--整个形状区域的高度--&gt; &lt;size android:height=&quot;10dp&quot;/&gt;&lt;/shape&gt; ring 使用例子 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--可以旋转的ring--&gt;&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;1080.0&quot;&gt; &lt;shape android:shape=&quot;ring&quot; android:innerRadius=&quot;5dp&quot; android:thicknessRatio=&quot;10&quot; android:useLevel=&quot;false&quot;&gt; &lt;!--扫描渐变--&gt; &lt;gradient android:endColor=&quot;@color/colorAccent&quot; android:startColor=&quot;@color/colorPrimary&quot; android:type=&quot;sweep&quot;/&gt; &lt;stroke android:width=&quot;1dp&quot; android:color=&quot;@color/colorAccent&quot; /&gt; &lt;/shape&gt;&lt;/rotate&gt; 首先，shape根元素有些属性只适用于ring类型，先过目下这些属性吧： android:innerRadius 内环的半径 android:innerRadiusRatio 浮点型，以环的宽度比率来表示内环的半径，默认为3，表示内环半径为环的宽度除以3，该值会被android:innerRadius覆盖 android:thickness 环的厚度 android:thicknessRatio 浮点型，以环的宽度比率来表示环的厚度，默认为9，表示环的厚度为环的宽度除以9，该值会被android:thickness覆盖 android:useLevel 一般为false，否则可能环形无法显示，只有作为LevelListDrawable使用时才设为true LevelListDrawable` ( 等级列表图片 ) 可参考Android Drawable Resource学习（六）、LevelListDrawable LevelListDrawable对应的标签是标签，他表示的是一个Drawable集合。集合里面的每一个item都有的Drawable都有一个对应的level，然后我们在代码中通过的View 的setLevel来设置不同的等级，等级的范围为0-10000（最小值和默认值都是0），然后根据不同的等级在level-list寻找不同的drawable来显示。作者：阿敏其人链接：http://www.jianshu.com/p/aa87c41182b7來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 oval oval用来画椭圆，而在实际应用中，更多是画正圆，比如消息提示，圆形按钮等 size：设置形状默认的大小，可设置宽度和高度 android:width 宽度 android:height 高度 oval 使用例子 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;oval&quot;&gt; &lt;padding android:bottom=&quot;10dp&quot; android:top=&quot;10dp&quot; android:left=&quot;5dp&quot; android:right=&quot;5dp&quot;/&gt; &lt;!--设置形状的大小--&gt; &lt;size android:width=&quot;40dp&quot; android:height=&quot;40dp&quot;/&gt; &lt;!--注意，android:gradientRadius 渐变的半径，只有渐变类型为radial 放射渐变时才使用--&gt; &lt;gradient android:startColor=&quot;@color/colorPrimary&quot; android:endColor=&quot;@color/colorAccent&quot; android:gradientRadius=&quot;40dp&quot; android:type=&quot;radial&quot;/&gt;&lt;/shape&gt; 总结 使用shape需要在drawable目录下创建drawable文件，在View的background中使用 rectangle 画矩形，line画直线，oval 画椭圆，ring画圆环 属性值有：padding形状边距，size形状大小，gradient渐变色，stroke设置描边，corners设置圆角，solid 设置形状填充的颜色]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ConstraintLayout 学习]]></title>
    <url>%2F2017%2F09%2F25%2FAndroid%20ConstraintLayout%20%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[学习来源：鸿洋大神的公众号 拒绝拖拽 使用ConstraintLayout优化你的布局吧 1、作用 ConstraintLayout 允许您构建复杂的布局，而不必嵌套 View 和 ViewGroup 元素，使用 ConstraintLayout 布局能够减少 UI 的绘制，优化性能。 2、使用 要实现以上布局想必需要嵌套不少布局吧，现在告诉你使用一个ConstrainLayou就够了 Banner 页的布局这里只采用了一个 TextView 去做展示，实际中只需要用用相应的Banner库或者自己写的Banner界面去填充即可。布局如下： 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#11ff0000&quot; android:id=&quot;@+id/constraintLayout&quot;&gt; &lt;TextView android:id=&quot;@+id/banner&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:background=&quot;#765&quot; android:gravity=&quot;center&quot; android:text=&quot;Banner&quot; app:layout_constraintDimensionRatio=&quot;H,16:9&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt; ....&lt;/android.support.constraint.ConstraintLayout&gt; 新的API 1234567 android:layout_width=&quot;0dp&quot; // 需要设置为0dp，相当于match_parent android:layout_height=&quot;0dp&quot; // 需要设置为0dp，相当于match_parent app:layout_constraintLeft_toLeftOf=&quot;parent&quot; // 在父布局的左边 app:layout_constraintRight_toRightOf=&quot;parent&quot; // 在父布局的右边 app:layout_constraintDimensionRatio=&quot;H,16:9&quot; // 宽高比，需要填以上4个操作才有效果// app:layout_constraintDimensionRatio=&quot;W,16:6&quot;// app:layout_constraintDimensionRatio=&quot;H,16:6&quot; 新闻item 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#11ff0000&quot; android:id=&quot;@+id/constraintLayout&quot;&gt; ..... &lt;ImageView android:id=&quot;@+id/img_guitar&quot; android:layout_width=&quot;140dp&quot; android:layout_height=&quot;86dp&quot; android:src=&quot;@drawable/guitar&quot; android:layout_marginTop=&quot;12dp&quot; android:layout_marginLeft=&quot;12dp&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/banner&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;8dp&quot; android:layout_marginRight=&quot;12dp&quot; android:text=&quot;马云:一年交税170多亿马云:一年交税170多亿马云:一年交税170多亿&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;16dp&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/img_guitar&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/img_guitar&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;8dp&quot; android:layout_marginTop=&quot;12dp&quot; android:text=&quot;8分钟前&quot; android:textColor=&quot;#333&quot; android:textSize=&quot;12dp&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/img_guitar&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/img_guitar&quot; /&gt; ......&lt;/android.support.constraint.ConstraintLayout&gt; 新的API 12345678910111213图片在Banner的下方，图片在父布局的左边app:layout_constraintTop_toBottomOf=&quot;@+id/banner&quot; // id是Top，要显示的是Bottomapp:layout_constraintLeft_toLeftOf=&quot;parent&quot;文字在banner下方，在图片左边满屏，顶部和图片对齐 app:layout_constraintLeft_toRightOf=&quot;@+id/img_guitar&quot; // img_guitar右边是文字 app:layout_constraintRight_toRightOf=&quot;parent&quot; // 需要设置 layout_width=&quot;0dp&quot;，相当于match_parent app:layout_constraintTop_toTopOf=&quot;@+id/img_guitar&quot; // 顶部对齐时间在图片的右边，与图片底部对齐 app:layout_constraintLeft_toRightOf=&quot;@+id/img_guitar&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/img_guitar&quot; 按钮 123456789101112131415161718192021&lt;Button android:id=&quot;@+id/btn1&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;12dp&quot; android:layout_marginLeft=&quot;12dp&quot; android:text=&quot;你好&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/img_guitar&quot; /&gt; &lt;Button android:id=&quot;@+id/btn2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;12dp&quot; android:layout_marginLeft=&quot;12dp&quot; android:text=&quot;你好&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/btn1&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/img_guitar&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt; 按钮的实现没啥新的API，之前页使用过了，主要注意的就是需要修改 layout_width=”0dp” ，否则不能填满剩余的父布局 底部的三个 Tab 实现 123456789101112131415161718192021222324252627282930313233343536&lt;TextView android:id=&quot;@+id/tab1&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;30dp&quot; android:background=&quot;#f67&quot; android:gravity=&quot;center&quot; android:text=&quot;Tab1&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/tab2&quot; app:layout_constraintHorizontal_weight=&quot;1&quot; /&gt; &lt;TextView android:id=&quot;@+id/tab2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;30dp&quot; android:background=&quot;#A67&quot; android:gravity=&quot;center&quot; android:text=&quot;Tab2&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/tab1&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/tab3&quot; app:layout_constraintHorizontal_weight=&quot;2&quot; /&gt; &lt;TextView android:id=&quot;@+id/tab3&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;30dp&quot; android:background=&quot;#767&quot; android:gravity=&quot;center&quot; android:text=&quot;Tab3&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/tab2&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintHorizontal_weight=&quot;1&quot; /&gt; 主要思想就是两两互相约束app:layout_constraintHorizontal_weight=&quot;1&quot;这个属性是设置占比，和LinearLayout的layout_weight相像 悬浮按钮的实现 1234567891011121314151617181920&lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline_h&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.8&quot; // 横向距离顶部80% /&gt; &lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline_w&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.8&quot; // 纵向距离顶部80% /&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; app:layout_constraintLeft_toRightOf=&quot;@id/guideline_w&quot; app:layout_constraintTop_toBottomOf=&quot;@id/guideline_h&quot; // 悬浮按钮就在二者的交点展示 /&gt; 新的API 123456789101112android.support.constraint.Guideline该类比较简单，主要用于辅助布局，即类似为辅助线，横向的、纵向的。该布局是不会显示到界面上的。android:orientation取值为&quot;vertical&quot;和&quot;horizontal&quot;.除此以外，还差个属性，决定该辅助线的位置：layout_constraintGuide_beginlayout_constraintGuide_endlayout_constraintGuide_percent可以通过上面3个属性其中之一来确定属性值位置。begin=30dp，即可认为距离顶部30dp的地方有个辅助线，根据orientation来决定是横向还是纵向。end=30dp，即为距离底部。 percent=0.8即为距离顶部80 在这里还可以通过这两个属性去实现这个悬浮按钮layout_constraintHorizontal_bias=”0.9”layout_constraintVertical_bias=”0.9”即设置上下两侧间隙比例分别为90%与10%12345678910&lt;android.support.design.widget.FloatingActionButton android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; app:layout_constraintHorizontal_bias=&quot;0.9&quot; app:layout_constraintVertical_bias=&quot;0.9&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#11ff0000&quot; android:id=&quot;@+id/constraintLayout&quot;&gt; &lt;TextView android:id=&quot;@+id/banner&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:background=&quot;#765&quot; android:gravity=&quot;center&quot; android:text=&quot;Banner&quot; app:layout_constraintDimensionRatio=&quot;H,16:9&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt; &lt;ImageView android:id=&quot;@+id/img_guitar&quot; android:layout_width=&quot;140dp&quot; android:layout_height=&quot;86dp&quot; android:src=&quot;@drawable/guitar&quot; android:layout_marginTop=&quot;12dp&quot; android:layout_marginLeft=&quot;12dp&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/banner&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;8dp&quot; android:layout_marginRight=&quot;12dp&quot; android:text=&quot;马云:一年交税170多亿马云:一年交税170多亿马云:一年交税170多亿&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;16dp&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/img_guitar&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/img_guitar&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;8dp&quot; android:layout_marginTop=&quot;12dp&quot; android:text=&quot;8分钟前&quot; android:textColor=&quot;#333&quot; android:textSize=&quot;12dp&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/img_guitar&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/img_guitar&quot; /&gt; &lt;Button android:id=&quot;@+id/btn1&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;12dp&quot; android:layout_marginLeft=&quot;12dp&quot; android:text=&quot;你好&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/img_guitar&quot; /&gt; &lt;Button android:id=&quot;@+id/btn2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;12dp&quot; android:layout_marginLeft=&quot;12dp&quot; android:text=&quot;你好&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/btn1&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/img_guitar&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/tab1&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;30dp&quot; android:background=&quot;#f67&quot; android:gravity=&quot;center&quot; android:text=&quot;Tab1&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/tab2&quot; app:layout_constraintHorizontal_weight=&quot;1&quot; /&gt; &lt;TextView android:id=&quot;@+id/tab2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;30dp&quot; android:background=&quot;#A67&quot; android:gravity=&quot;center&quot; android:text=&quot;Tab2&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/tab1&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/tab3&quot; app:layout_constraintHorizontal_weight=&quot;2&quot; /&gt; &lt;TextView android:id=&quot;@+id/tab3&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;30dp&quot; android:background=&quot;#767&quot; android:gravity=&quot;center&quot; android:text=&quot;Tab3&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/tab2&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintHorizontal_weight=&quot;1&quot; /&gt; &lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline_h&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.8&quot; /&gt; &lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline_w&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.8&quot; /&gt; &lt;!--&lt;android.support.design.widget.FloatingActionButton--&gt; &lt;!--android:layout_width=&quot;60dp&quot;--&gt; &lt;!--android:layout_height=&quot;60dp&quot;--&gt; &lt;!--app:layout_constraintHorizontal_bias=&quot;0.9&quot;--&gt; &lt;!--app:layout_constraintVertical_bias=&quot;0.9&quot;--&gt; &lt;!--app:layout_constraintBottom_toBottomOf=&quot;parent&quot;--&gt; &lt;!--app:layout_constraintLeft_toLeftOf=&quot;parent&quot;--&gt; &lt;!--app:layout_constraintRight_toRightOf=&quot;parent&quot;--&gt; &lt;!--app:layout_constraintTop_toTopOf=&quot;parent&quot;--&gt; &lt;!--/&gt;--&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; app:layout_constraintLeft_toRightOf=&quot;@id/guideline_w&quot; app:layout_constraintTop_toBottomOf=&quot;@id/guideline_h&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toolbar 使用姿势]]></title>
    <url>%2F2017%2F08%2F19%2FToolbar-%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[听说菜鸟都是这么过来的，没事多写总结。希望能记录自己的实践过程，同时能帮助到又需要的朋友。 简单使用 直接使用ToolBar 布局，在ToolBar布局里添加子布局 使用前的准备 123456789101112131415161718191. 添加依赖compile &apos;com.android.support:appcompat-v7:25.3.1&apos; 2. 隐藏原有的ActionBar，两步，有可能会出现 Theme.AppCompat 北京找不到，说明你的support库版本太低了，需要去SDK manager 去升级那个库。① 在 res/values/styles.xml中&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt;② 在 /res/values-v21/styles.xml中&lt;resources&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;android:navigationBarColor&quot;&gt;@android:color/white&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; ToolBar布局直接使用 12345678910111213&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;@color/colorPrimary&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;android:layout_height=&quot;?attr/actionBarSize&quot; 设置高度android:background=&quot;@color/colorPrimary&quot; 设置背景色 android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; 设置顶部的淡色主题app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; 设置弹出框的主题为淡色主题 Java 代码中使用 12345678910111213141516171819mToolbar = (Toolbar) findViewById(R.id.toolbar); mToolbar.setTitle(&quot;DemoToolbar&quot;); setSupportActionBar(mToolbar); //设置字的颜色 mToolbar.setTitleTextColor(Color.WHITE); //显示NavigationIcon mToolbar.setOnMenuItemClickListener(this); //设置返回的图标 mToolbar.setNavigationIcon(getResources().getDrawable(R.mipmap.slide)); //设置监听 mToolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125; &#125;); menu 创建和点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758① 在activity下重写 onCreateOptionsMenu 方法，获取到 menu 布局 @Override public boolean onCreateOptionsMenu(Menu menu) &#123; //写一个menu的资源文件.然后创建就行了. getMenuInflater().inflate(R.menu.menu,menu); return super.onCreateOptionsMenu(menu); &#125;在res目录先新建一个menu目录，创建一个menu文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/action_edit&quot; android:title=&quot;@string/action_edit&quot; android:orderInCategory=&quot;80&quot; android:icon=&quot;@mipmap/message&quot; app:showAsAction=&quot;ifRoom&quot; /&gt; &lt;item android:id=&quot;@+id/action_share&quot; android:title=&quot;@string/action_share&quot; android:orderInCategory=&quot;90&quot; android:icon=&quot;@mipmap/add&quot; app:showAsAction=&quot;ifRoom&quot; /&gt; &lt;item android:id=&quot;@+id/action_settings&quot; android:title=&quot;@string/action_settings&quot; android:orderInCategory=&quot;10&quot; app:showAsAction=&quot;never&quot;/&gt;&lt;/menu&gt;//1、always：使菜单项一直显示在ToolBar上。 //2、ifRoom：如果有足够的空间，这个值会使菜单项显示在ToolBar上。 //3、never：使菜单项永远都不出现在ToolBar上,在…的子项中显示。 //4、 xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; 记得导入② menu 点击事件1、implement Toolbar.OnMenuItemClickListener2、设置监听 mToolbar.setOnMenuItemClickListener(this);3、实现接口 onMenuItemClick @Override public boolean onMenuItemClick(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.menu1: Toast.makeText(this, &quot;menu1&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.menu2: Toast.makeText(this, &quot;menu2&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.menu3: Toast.makeText(this, &quot;menu3&quot;, Toast.LENGTH_SHORT).show(); break; default: break; &#125; return false; &#125; 听说没图都不敢出来发文 ToolBar的封装 为什么要封装？产品想要这种效果（等我拿起桌上的大刀，奈何他手里拿着手枪）。 实现的效果是左边一个图标，右边一个图标，中间显示文字或者搜索框。 写一个自定义的Toolbar，就叫 CustomToolbar 吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179public class CustomToolbar extends Toolbar &#123; private LayoutInflater mInflater; private View mView; private TextView mLeftButtonText; private TextView mTitleText; private TextView mRightButtonText; private EditText mSearchView; public CustomToolbar(Context context) &#123; this(context,null) ; &#125; public CustomToolbar(Context context, @Nullable AttributeSet attrs) &#123; this(context,attrs,0) ; &#125; public CustomToolbar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView() ; if (attrs != null)&#123; final TintTypedArray tintTypedArray = TintTypedArray.obtainStyledAttributes(getContext(), attrs, R.styleable.CustomToolbar, defStyleAttr, 0); CharSequence leftText = tintTypedArray.getText(R.styleable.CustomToolbar_leftButtonText); if (leftText != null)&#123; setLeftButtonText(leftText) ; &#125; final Drawable leftIcon = tintTypedArray.getDrawable(R.styleable.CustomToolbar_leftIcon); if (leftIcon != null) &#123; //setNavigationIcon(navIcon); setLeftIcon(leftIcon); &#125; final Drawable rightIcon = tintTypedArray.getDrawable(R.styleable.CustomToolbar_rightButtonIcon); if (rightIcon != null) &#123; //setNavigationIcon(navIcon); setRightButtonIcon(rightIcon); &#125; boolean isShowSearchView = tintTypedArray.getBoolean(R.styleable.CustomToolbar_isShowSearchView,false); if(isShowSearchView)&#123; showSearchView(); hideTitleView(); &#125; CharSequence rightButtonText = tintTypedArray.getText(R.styleable.CustomToolbar_rightButtonText); if(rightButtonText !=null)&#123; setRightButtonText(rightButtonText); &#125; tintTypedArray.recycle(); &#125; &#125; public void setLeftIcon(Drawable leftIcon) &#123; // 默认显示返回箭头，文字先不需要 mLeftButtonText.setVisibility(VISIBLE); mLeftButtonText.setCompoundDrawablesWithIntrinsicBounds(leftIcon, null, null, null); &#125; public void setLeftButtonText(CharSequence leftButtonText) &#123; mLeftButtonText.setVisibility(VISIBLE); mLeftButtonText.setText(leftButtonText); &#125; public void setRightTextOnClickListener(OnClickListener li)&#123; mRightButtonText.setOnClickListener(li); &#125; public void setLeftTextOnClickListener(OnClickListener li)&#123; mLeftButtonText.setOnClickListener(li); &#125; public void setRightButtonText(CharSequence text)&#123; mRightButtonText.setVisibility(VISIBLE); mRightButtonText.setText(text); &#125; public void setRightButtonText(int id)&#123; setRightButtonText(getResources().getString(id)); &#125; public TextView getRightButtonText()&#123; return this.mRightButtonText; &#125; public TextView getLeftButton()&#123; return this.mLeftButtonText; &#125; @Override public void setTitle(int resId) &#123; setTitle(getContext().getText(resId)); &#125; @Override public void setTitle(CharSequence title) &#123; initView(); if(mTitleText !=null) &#123; showTitleView(); mTitleText.setText(title); &#125; &#125; public void showTitleView()&#123; if(mTitleText !=null) mTitleText.setVisibility(VISIBLE); &#125; public void hideTitleView() &#123; if (mTitleText != null) mTitleText.setVisibility(GONE); &#125; public void showSearchView() &#123; if(mSearchView !=null) mSearchView.setVisibility(VISIBLE); &#125; public void hideSearchView()&#123; if(mSearchView !=null) mSearchView.setVisibility(GONE); &#125; public void setRightButtonIcon(Drawable rightIcon) &#123; if(mRightButtonText !=null)&#123; mRightButtonText.setVisibility(VISIBLE); mRightButtonText.setCompoundDrawablesWithIntrinsicBounds(null, null, rightIcon, null); &#125; &#125; public void setRightButtonIcon(int icon)&#123; setRightButtonIcon(getResources().getDrawable(icon)); &#125; private void initView() &#123; if(mView == null) &#123; mInflater = LayoutInflater.from(getContext()); mView = mInflater.inflate(R.layout.custom_toolbar, null); mSearchView = (EditText) mView.findViewById(R.id.toolbar_searchview); mLeftButtonText = (TextView) mView.findViewById(R.id.lt_main_title_left); mTitleText = (TextView) mView.findViewById(R.id.lt_main_title); mRightButtonText = (TextView) mView.findViewById(R.id.lt_main_title_right); LayoutParams lp = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT, Gravity.CENTER_HORIZONTAL); addView(mView, lp); &#125; &#125;&#125;代码很简单，就是自定义一个继承自 Toolbar 的自定义View创建一个布局文件，然后读取布局文件中的内容设置对应的方法，用于在Java代码使用中添加内容和隐藏内容布局中利用 TextView 去显示图片，利用到了 mRightButtonText.setCompoundDrawablesWithIntrinsicBounds(null, null, rightIcon, null); 这是对应的TextView中设置的drawableRight，如果不想显示图片，则参数全部设置为null即可。 布局文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:minHeight=&quot;?attr/actionBarSize&quot; &gt; &lt;EditText android:id=&quot;@+id/toolbar_searchview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_centerVertical=&quot;true&quot; android:gravity=&quot;center&quot; android:drawableLeft=&quot;@mipmap/icon_search&quot; style=&quot;@style/search_view&quot; android:hint=&quot;请输入搜索内容&quot; android:visibility=&quot;gone&quot; /&gt; &lt;TextView android:id=&quot;@+id/lt_main_title_left&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:singleLine=&quot;true&quot; android:layout_centerInParent=&quot;true&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_marginLeft=&quot;20dp&quot; android:gravity=&quot;center_vertical&quot; android:textColor=&quot;@color/white&quot; android:textSize=&quot;16dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/lt_main_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:layout_centerInParent=&quot;true&quot; android:singleLine=&quot;true&quot; android:ellipsize=&quot;end&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/lt_main_title_right&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginRight=&quot;20dp&quot; android:textSize=&quot;16dp&quot; /&gt;&lt;/RelativeLayout&gt; 显示左边文字，右边图片，中间居中的文字 1234567891011121314151617CustomToolbar customToolbar = (CustomToolbar) findViewById(R.id.custom_toolbar); customToolbar.setLeftButtonText(&quot;返回&quot;); customToolbar.setTitle(&quot;我是居中标题&quot;); customToolbar.setRightButtonIcon(R.drawable.add); customToolbar.setRightTextOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(RxJavaTestActivity.this, MActivity.class)); Toast.makeText(RxJavaTestActivity.this, &quot;hello&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); customToolbar.setLeftTextOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125; &#125;); 显示搜索框 123456789直接在布局文件中设置&lt;com.xxxx.demo.CustomToolbar android:id=&quot;@+id/m_custom_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;@color/colorAccent&quot; app:isShowSearchView=&quot;true&quot; &gt; &lt;/com.xxxx.demo.CustomToolbar&gt;]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Toolbar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知乎开源的图片选择器 Matisse 在 6.0 以上手机使用相机功能]]></title>
    <url>%2F2017%2F08%2F03%2F%E7%9F%A5%E4%B9%8E%E5%BC%80%E6%BA%90%E7%9A%84%E5%9B%BE%E7%89%87%E9%80%89%E6%8B%A9%E5%99%A8Matisse%E5%9C%A86-0%E4%BB%A5%E4%B8%8A%E6%89%8B%E6%9C%BA%E4%BD%BF%E7%94%A8%E7%9B%B8%E6%9C%BA%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[需求：实现一个图片选择器，能选择本地图片和拍照 拿到需求，第一个想法就是看自己在规定时间上能否又快又好的实现。显然是不能（ 。。），现在那么多前辈都把轮子都造好了，我们直接拼装不久可以了吗？目前为止，我还是这样，等功能深厚成为前辈了再撸几个轮子给后辈使用，这些都是后话，先实现这个需求吧。 先去GitHub搜索一圈图片选择器，发现知乎开源的Matisse家伙长的挺好看的，就选它了。 使用步骤看GitHub的，官方的才是最正确的使用姿势。Matisse 或者是参看一下这位仁兄的介绍：Android 一起来看看知乎开源的图片选择库 官网的使用方式默认是不开启拍照功能的，因此需要拍照功能的可以这么写 123456789101112Matisse.from(PublishActivity.this) .choose(MimeType.allOf()) // 选择 mime 的类型 .countable(true) // 显示选择的数量 .capture(true) // 开启相机，和 captureStrategy 一并使用否则报错 .captureStrategy(new CaptureStrategy(true,&quot;com.meiqu.pianxin.ui.publish.MyFileProvider&quot;)) // 拍照的图片路径 .theme(R.style.Matisse_Dracula) // 黑色背景 .maxSelectable(9) // 图片选择的最多数量 .gridExpectedSize(getResources().getDimensionPixelSize(R.dimen.grid_expected_size)) // 列表中显示的图片大小 .restrictOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) .thumbnailScale(0.85f) // 缩略图的比例 .imageEngine(new GlideEngine()) // 使用的图片加载引擎 .forResult(REQUEST_CODE_CHOOSE); // 设置作为标记的请求码，返回图片时使用 captureStrategy(new CaptureStrategy(true,&quot;com.meiqu.pianxin.ui.publish.MyFileProvider&quot;)) 主要是告知系统拍照的图片存储位置 第二个参数是自己实现继承FileProvider类的一个空类，需要在manifest文件中添加如下代码 123456789&lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;com.meiqu.pianxin.ui.publish.MyFileProvider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/filepaths&quot;/&gt; &lt;/provider&gt; android:resource=”@xml/filepaths” 是在res/xml 目录下的创建的文件filepaths.xml 123456789101112131415161718192021&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!--代表外部存储区域的根目录下的文件 Environment.getExternalStorageDirectory()/DCIM/camerademo目录--&gt; &lt;external-path name=&quot;mq_DCIM&quot; path=&quot;DCIM/camerademo&quot; /&gt; &lt;!--代表外部存储区域的根目录下的文件 Environment.getExternalStorageDirectory()/Pictures/camerademo目录--&gt; &lt;external-path name=&quot;mq_Pictures&quot; path=&quot;Pictures/camerademo&quot; /&gt; &lt;!--代表app 私有的存储区域 Context.getFilesDir()目录下的images目录 /data/user/0/com.hm.camerademo/files/images--&gt; &lt;files-path name=&quot;mq_private_files&quot; path=&quot;images&quot; /&gt; &lt;!--代表app 私有的存储区域 Context.getCacheDir()目录下的images目录 /data/user/0/com.hm.camerademo/cache/images--&gt; &lt;cache-path name=&quot;mq_private_cache&quot; path=&quot;images&quot; /&gt; &lt;!--代表app 外部存储区域根目录下的文件 Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)目录下的Pictures目录--&gt; &lt;external-files-path name=&quot;mq_external_files&quot; path=&quot;Pictures&quot; /&gt; &lt;!--代表app 外部存储区域根目录下的文件 Context.getExternalCacheDir目录下的images目录--&gt; &lt;external-cache-path name=&quot;mq_external_cache&quot; path=&quot;&quot; /&gt; &lt;root-path name=&quot;mq_external_cache&quot; path=&quot;&quot; /&gt;&lt;/paths&gt; 以上使用在 5.0 以下的手机是没毛病的，在 6.0 这个动态权限的控制下就有些问题了 6.0 以上使用 Matisse 的正确姿势 可以自己去写动态权限判断 使用开源库，目前start 最多的动态权限库是 PermissionsDispatcher start已经5000+并且最近15天还在维护 Matisse 和 PermissionsDispatcher 的使用姿势 Matisse 需要用到相机和读写本地数据的权限 1234&gt; &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;&gt; &lt;uses-permission android:name=&quot;android.Manifest.permission.READ_PHONE_STATE&quot; /&gt;&gt; 所以在调用了这些权限的地方是使用 PermissionsDispatcher 去动态设置，看PermissionsDispatcher 官网介绍 我在实际中使用 123456789101112131415161718192021222324252627282930313233步骤：1. 在Activity或者Fragment上添加 @RuntimePermissions 2. 在用到权限的方法（ 例如:void initData(),不能加上 private 修饰）名上添加 @NeedsPermission(Manifest.permission.READ_PHONE_STATE)3. 重写 onRequestPermissionsResult 方法，MainActivityPermissionsDispatcher.onRequestPermissionsResult(MainActivity.this, requestCode, grantResults);4. 在onCreate方法调用，MainActivityPermissionsDispatcher.initDataWithCheck(MainActivity.this);实例：@RuntimePermissions // 必须添加public class MainActivity extends AppCompatActivity &#123; ... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); .... MainActivityPermissionsDispatcher.initDataWithCheck(MainActivity.this); .... &#125; @NeedsPermission(Manifest.permission.READ_PHONE_STATE) // 必须添加 void initData() &#123; // 会调用用户信息权限 DataCenter dc = DataCenter.getInstance(); dc.initDataCenter(this); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); MainActivityPermissionsDispatcher.onRequestPermissionsResult(MainActivity.this, requestCode, grantResults); &#125;&#125; ​]]></content>
      <tags>
        <tag>Android</tag>
        <tag>图片选择器</tag>
        <tag>动态权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView + 九宫格图片 + ViewPager + PhotoView 实现列表图片点击放大并能缩放思路]]></title>
    <url>%2F2017%2F08%2F01%2FRecyclerView-%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9B%BE%E7%89%87-ViewPager-PhotoView-%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E5%9B%BE%E7%89%87%E7%82%B9%E5%87%BB%E6%94%BE%E5%A4%A7%E5%B9%B6%E8%83%BD%E7%BC%A9%E6%94%BE%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[需求：在内容列表中点击图片列表显示大图并且可以双击放大缩小 下文主要介绍思路，不一定是最好的，时间上来不及能先实现效果就OK。 列表 可选的有 ListView 和 RecyclerView，这里主要就是列表数据的填充和展示 使用 ListView 在 getView() 中获取数据并设置数据，然后通过 ListView 的 setOnClickListener 去完成点击事件 使用 RecyclerView 在 ViewHolder 中获取控件，在 onBindView 中去设置数据，在 recyclerView 的 adapter 中添加点击事件的接口完成点击事件 图片列表 可选的有 GitHub 开源库，自己撸 自己撸，思路：一张图片+九张图片（三张一排）的布局；通过判断返回的图片list去填充，如果返回1，则显示一张图片，九张图片的就隐藏；返回0则全部不显示。返回大于1，则通过双层for循环去给九张图中的每一个imageview去设置图片（里面是一个算法）。 开源库 Github 搜索九宫格就有，按照start 最多排序去选择 大图 可选的有 GitHub 开源库，自己撸 开源库：Github 搜索点击查看大图 自己撸：启动新的activity去展示，用Dialog去全屏显示。用activity展示，可以将图片的list以及点击的position传递给activity，list主要是想在activity用Viewpager去滑动展示图片，position是为了viewpager展示的时候是当前点击的图片位置。 双击放大缩小 可选的有 GitHub 开源库，自己撸 自己撸：….脑子不够用了，还是用开源库吧 PhotoView：项目有点久，因为现在项目中有这个库，所以先用这个库来实现，具体用法去Github搜索。 1234567891011//将图片装载到数组中 mImageViews = new PhotoView[mImagesList.size()]; // 将传递过来的list列表给PhotoView去展示 for(int i=0; i&lt; mImagesList.size(); i++)&#123; PhotoView view = new PhotoView(XXXActivity.this); view.isEnabled() ; // 支持缩放 view.setScaleType(ImageView.ScaleType.FIT_CENTER); // 图片裁剪的类别 mImageViews[i] = view; Glide.with(this).load(mImagesList.get(i)).into(view); &#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 消息通信原理浅析]]></title>
    <url>%2F2017%2F07%2F06%2FAndroid-%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[线程间通信原理 Android是单线程模型，好处是避免代码复杂和效率低 主线程负责更新UI，工作线程不能更新UI 工作线程用于执行耗时任务，避免主线程阻塞 主线程中通过Looper遍历消息队列，有消息则处理，没有消息则休眠 Message类 存放线程间通信所需的信息，包括代码 Handler类 Android通过handler类实现线程键消息的收发 子线程更新UI需要用handler将数据发给主线程来更新UI 线程与Handler是一对多的关系，一个线程可以对应多个Handler。但一个Handler只为一个线程服务 Handler发送消息 post方法：调用sendMessageDelayed() —》调用sendMessageAtTime方法—》 sendMessage方法：调用sendMessageDelayed() Handler处理消息 Handler类通过dispatchMessage方法将消息队列中取出的消息分发给相关方法处理 dispatchMessage() –&gt;handleCallBack() 或者handleMessage() Callback：Callback是Handler类的内部接口，在Message.callback中使用 Handler有一个带有Callback的构造方法，通过该方法创建Handler对象，可以避免创建Handler的子类时，覆写handleMessage。 Looper类 Looper用于为指定线程创建并维护一个消息队列，用先进先出的方式从消息队列中取出消息，交给Handler处理。工作线程默认没有Looper和消息循环。一个线程只能有一个Looper。Android为主线程自动创建一个Looper。 创建Looper Looper由Looper.prepare方法创建，不能直接new。 prepare(boolean quitAllowed) 中利用sThreadLocal为每个线程保存一个Looper对象（通过set方法保存在Map集合中） quitAllowed 的值：工作线程在创建时，必须设置quitAllowed为true，允许Looper.quit结束Looper对消息队列的遍历。但主线程的Looper在创建时，quitAllowed必须设置为false，即不允许主线程中的Looper退出。（查看Looper源码可知） 遍历消息队列 Looper.loop方法用于遍历消息队列 loop源码：无限循环，遍历MessageQUeue队列，利用handler.dispatchMessage方法将消息发送给MessageQueue 常见方法 Looper.myLooper()：得到当前线程looper对象 getThread()：得到looper对象所属线程 quit()：结束looper循环，主线程不能调用本方法 MessageQueue类 是一个持有Messages集合的类，被Looper分发。Message会发送到与Handler所绑定的MessageQueue中，通过Looper.myQueue()方法来检索当前线程的MessageQueue MessageQueue的数据结构是先进先出的队列 常用方法 enqueueMessage方法：enqueueMessage方法用链表实现消息入队列，并用无限循环遍历队列中的消息。 next方法：next用无限循环遍历消息队列，取出消息。 Android以下类封装了消息循环机制 HandlerThread类 HandlerThread继承自Thread类，与普通Thread的区别在于，它在创建一个线程的同时也创建了一个绑定该线程的消息循环，可以在当前线程中分发和处理消息。 使创建HandlerThread 1234567891011121314151617181920212223242526272829// 1.创建HandlerThread对象，并为子线程指定一个名称 HandlerThread handlerThread = new HandlerThread(&quot;ruancoder&quot;); // 2.调用start()。此时内部run()方法执行，会创建一个绑定当前线程的Looper对象 handlerThread.start(); // 3.获取HandlerThread的Looper Looper looper = handlerThread.getLooper(); // 4.使用上面的Looper创建Handler Handler handler = new Handler(looper); 使用方式(1)handler.post(new Runnable() &#123; @Override public void run() &#123; // sub thread &#125; &#125;); 使用方式(2)Handler handler = new Handler(looper) &#123; @Override public void handleMessage(Message msg) &#123; // sub thread &#125; &#125;; // 1 handler.sendEmptyMessage(MSG); // 2 handler.sendMessage(msg); 如果想让HandlerThread退出，可以调用HandlerThread的quit()或quitSafely()。 ​ HandlerThread 优点 1231.开发中如果多次使用类似new Thread()&#123;&#125;.start()这种方式开启子线程，会创建多个匿名线程，使得程序运行起来越来越慢，而HandlerThread自带Looper使他可以通过消息机制来多次重复使用当前线程，节省开支。2.Handler类内部的Looper默认绑定的是UI线程的消息队列，对于非UI线程如果需要使用消息机制，自己去创建Looper较繁琐，由于HandlerThread内部已经自动创建了Looper，直接使用HandlerThread更方便。 ​ AsyncTask类 AsyncTask,是android提供的轻量级的异步类,可以直接继承AsyncTask,在类中实现异步操作,并提供接口反馈当前异步执行的程度(可以通过接口实现UI进度更新),最后反馈执行的结果给UI主线程 重要的方法 1234567(1) doInBackground(Params…) 后台执行，比较耗时的操作都可以放在这里。注意这里不能直接操作UI。此方法在后台线程执行，完成任务的主要工作，通常需要较长的时间。在执行过程中可以调用publicProgress(Progress…)来更新任务的进度。(2) onPostExecute(Result) 相当于Handler 处理UI的方式，在这里面可以使用在doInBackground 得到的结果处理操作UI。 此方法在主线程执行，任务执行的结果作为此方法的参数返回有必要的话你还得重写以下这三个方法，但不是必须的：(3) onProgressUpdate(Progress…) 可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。(4) onPreExecute() 这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。(5) onCancelled() 用户调用取消时，要做的操作 ​ ​]]></content>
      <tags>
        <tag>Android</tag>
        <tag>消息通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android内存优化]]></title>
    <url>%2F2017%2F06%2F15%2FAndroid%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Android 系统将进程分为哪些类型？ 前台进程：系统进程或者正在前台运行的进程 可见进程：可见但是不与用户交互的进程 … 引发 GC 操作的原因是什么？ 短时间内有大量频繁的对象创建与释放操作 内存分配失败是触发GC_MALLOC 为什么要避免频繁的 GC 操作？ 如何避免 GC 操作会导致系统所有的线程暂停。频繁的GC操作会导致UI卡顿，影响用户体验 尽量避免在频繁触发的逻辑方法中大量的分配对象，如自定义View的onDraw中执行复杂的操作 常见的内存问题都有哪些？ 内存溢出OOM 内存抖动：短时间内有大量频繁的对象创建和释放操作。 内存泄漏 你在开发中都使用了哪些内存优化的工具？ Allocation Tracker：查看程序某段时间的内存分配情况，如内存抖动；查看某段程序运行结束后的内存分配情况，如内存泄漏。 DDMS-Heap：显示当前引用占用的内存，剩余的饿内存信息。 内存泄露是什么，如何解决？ 内存泄露就是一个对象被超过自己生命周期以外的对象强引用导致该对象无法被正 常垃圾回收 外部类的静态变量持有了 Activity 对象。导致 Activity 退出后无法被系统回收 加载大量的图片缓存在内存中，没有在当前页面退出后释放。 常见的内存泄露导致问题 应用卡顿，响应速度慢（内存占用高时 JVM 虚拟机会频繁触发 GC） 应用莫名的崩溃 如何解决内存泄露 查找所有持有 Application 或 Activity 的静态变量的类，在这些类中编写释放持有 Activity、Application 的静态变量的方法，在 Activity.onDestroy()中调用该工具类的方法释放静 态变量持有的对象 内存抖动是什么，如何解决？ 内存抖动(Memory Churn)是因为在短时间内大量的对象被创建又马上被释放。 如何解决内存抖动？ 避免在循环中大量创建对象，若使用大量对象，应使用对象池。如在循环中使用 Message 时，用 Message.obtain 方法从消息池中复用 Message 尽量避免在 onDraw 方法中创建对 在循环中连接字符串时，要使用 StringBuilder 或 StingBuffer，避免使用 String 内存溢出是什么，如何解决？ Android 的应用程序所能申请的最大内存都是有限的，内存溢出(OutOfMemoery)简称 OOM，是指 APP 向系统申请内存的请求超过了系统为应用分配的上限，系统无法再分配多 余的空间，就会造成 OOM。 OOM 解决 通过 BitmapFactory.options 压缩图片尺寸。 通过 BitmapFactory. inPreferredConfig 控制图片的质量，例如将图片每个像素 默认的字节数由 Bitmap.Config ARGB_8888 改为 Bitmap.Config.RGB_565 为防止 OOM 造成的异常，用 try-catch(OutOfMeory e)捕获 OOM 异常 你在开发中都使用过哪些内存优化措施？ 大图片加载的三种优化措施 通过 BitmapFactory.options 压缩图片尺寸 通过 BitmapFactory. inPreferredConfig 控制图片的质量 在多个 Activity 或 Fragment 都可能加载大量图片时 在当前 Activity.onStop 方法中调用 Bitmap.recycle 方法释放当前 Activity 中的所有 Bitmap 在加载大图片时，为防止 OOM 造成的异常，用 try-catch(OutOfMeoryError e)捕获 OOM 异常]]></content>
      <tags>
        <tag>Android</tag>
        <tag>内存优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsoup爬虫使用记录]]></title>
    <url>%2F2017%2F05%2F11%2FJsoup%E7%88%AC%E8%99%AB%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[背景 学习 Android 到一段时间，想自己做一些项目练练手，需要数据怎么办呢？ 自己造数据 少量的假数据利用数组或者集合来存储少量数据。 大量的后台数据这里的数据是指，自己获取数据，然后自己实现一个后台管理系统，通过这个系统去操作（增删改查）这些大量的数据。 用第三方的API接口 聚合数据（欠我一份广告费）大量的接口数据，有免费的有收费的。 干货集中营代码家大神在维护，种类不多，但是接口格式很标准，使用起来很爽。 爬取数据 第三方工具我使用过的就是八爪鱼，这个工具使用起来也很方便。但是有的缺点就是在获取网页的图片时，获取不到真正的地址，需要再次整理才能得到图片Url。 脚本Python听说不错，没学习不好评论。 开源工具Jsoup，这是最近发现的一个Java爬虫工具。 Jsoup 介绍 是什么？ Jsoup 是一个 Java 的开源HTML解析器，可直接解析某个URL地址、HTML文本 能做什么？ 从一个URL，文件或字符串中解析HTML 使用DOM或者CSS选择器来查找、取出数据 对HTML元素、属性、文本进行操作这里是指Jsoup工具能够对HTML进行增删改查操作 清除不受信任的HTML (来防止XSS攻击) 不能做什么？ 网站使用动态加载技术 jsoup没法爬，建议用htmlutil 工具 【动态加载技术？】利用 ajax() 方法通过 HTTP 请求加载远程数据，该方法是 jQuery 底层 AJAX 实现， AJAXj 它主要用途是提供异步刷新，而jQuery又是一个兼容多浏览器的JavaScript库。JavaScript一种脚本语言，用来给HTML网页增加动态功能。 【为什么爬不了？】Jsoup只能是抓取加载完成后的页面，源码是这么设计的,有时间去看看源码 【解决办法】换扒取数据的Url换工具（ htmlutil ）Google搜索 简单实现 实现步骤 得到自己想要爬取数据的url.http://www.moxiu.com/themes 通过Jsoup的jar包中的方法将Html解析成Document，添加依赖 compile ‘org.jsoup:jsoup:1.10.2’ 使用Document中的一些列get、first、children等方法获取自己想要的数据，如图片地址、名称等内容。 将得到的数据封装成自己的实体类。 将实体中的数据在页面加载出来。 展示的结果 参考 Jsoup的不足之处 Jsoup中文文档 Jsoup源码地址 Jsoup使用介绍 Jsoup源码分析 ​]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Jsoup爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017Q1总结]]></title>
    <url>%2F2017%2F04%2F16%2F2017Q1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[回顾一下，四分之一的2017都做了那些事。 1月 测试 从来公司实习开始就一直做测试工作。做了短视频项目的测试，做了聚合搜索中广告功能的测试，做了桌面侧屏的测试。 刚开始有些不适应，后面也学到很多东西。 比如 : 认识公司不少小伙伴，之后在开协作发中容易沟通；学会任务按照优先级处理，之后修改 Bug 可以先改重要的；了解到公司的测试流程。 MVP 学习 由于测试工作不是很紧加上刚来公司，上级布置任务给的时间很充裕。所以利用多余时间也对开发中用到的技术进行了解。 比如 : MVP 技术。对该技术有了初步了解，同时对 MVC 技术也进行研究。 沟通演讲 在测试的时候遇到一个好同事，她教了我不少与人沟通的能力。 在做测试的时候也参加了测试同学的分享会，比如 : 如何也提交 Bug 的用户交流，利用用户来帮助我们测试，提高我们 App 的稳定性。 在这期间我也在开发小组中分享了一片关于我的爱好的内容。 第一次在公司分享，请教了之前分享过的同事，她们给与了一些书籍和建议，自己也在学别人别人之前分享的思路去做。 结果肯定是很烂。也学到一些技巧，继续加油！ 初步了解 Url 统一域名的相关问题 桌面App的域名还是比较乱的，有幸能够去看那块的代码。也许就是看了别人的乱代码才会想到自己之前也是这么写的吧。 桌面中的 URL 是有生产环境和测试环境两条域名的，如何切换这两个域名呢？桌面中采用的是Gradle去配置。对这块也进行了初步学习。 了解了 Gradle 如何定义一个变量，如何获取一个变量，原来 Build.gradle 文件是自动生成的。 但是用 Gradle 去控制接口是比较复杂的，于是想到 Spring 实战中的一种写法，讲固定的东西写到配置文件中，而这里我选择了写在xml文件中。 2月 面向对象的进一步学习 面向对象最重要的就是抽取对象最重要的功能隐藏对用户毫无用处的细节。 面向对象的具体实现就是：组合、社会分工、消息传递、接口。 归结起来：面向对象 = 数据 + 行为 MVP学习 越深入学习越发现自己要掌握的内容还有很多。一月份的时候了解过 MVP 的实现，这次对谷歌用 MVP 架构写的 Demo 进行研究，发现还有一种写法。谷歌是利用了Contrat ( 契约类 ) 将 View 和 Model 的接口进行统一管理。 这么做的好处就是，每个 View 和 Model 都很清晰，只需要知道Contrat中即可直到对应的 View 和 Model 层。 沟通演讲 在公司里，客户端一直是弱势群体，产品需求来了就做，服务端不想做的，客户端来做。导致目前桌面代码很乱。因此学会拒绝需求很重要！ 拒绝别人是一门艺术，如果做到让别人能接受你的建议，又能乖乖去做呢？这就需要掌握沟通技巧了。 在对需求时，可以不必说某个需求不好，而是说这个需求做起来没收入。总之一切和钱靠上边。没钱的东西，谁还会去坚持做呢？ 在功能做到一定阶段是需要我们去总结的，而领导要的是结果。因此我们只需将结果告诉领导，将过程写入文档即可。 RESTful 初步学习 表述性状态转移就是 RESTful ，她主要是一种架构风格，采用的是面向对象的方式来设计接口。 DNS劫持 Fiddler 模拟 Url 被劫持，利用抓接口工具 Fiddler 中的模拟修改 HOST 进行劫持 Url 。 Http劫持和DNS劫持的区别就是：Http劫持后返回的内容还是网页本来的内容，只是添加了一些广告等内容在原有网页上面。DNS 劫持是将访问的 URL 链接给替换了，用户访问的真是的 URL 页面。 防劫持：利用第三方的平台将访问的url 进行轮询。例如用 HttpDNS 防劫持。 竞品分析 主要分析的就是以下内容：首先是确定好竞品，然后进行比对ui、功能、内存、流量。 在做结论是有个规定：错误的结论不如不做！ 在代码中，对象是可以New出来的额，上天通过赋值将你传给了我，我必将单例执行一生。致—瀝人青℃ 3月 DNS劫持 轮询ip的初步实现，利用 HttpDNS 实现、OkHttp 的 Dns 接口实现. 抓取毕设美伊需要的数据 观察者模式学习 Obverser 观察者 Obvervabel 被观察者 内存泄露 测试工具：leakCanary 预防方式： 用Application 替代 ActivityContent 集合操作是需要有添加和删除 推荐使用static 内部类 监听有开也有关 文件操作时要记得关闭流 文档的写法要求 文档名一目了然 设计和结构清晰 写文档一定是对某个内容深入理解 假设自己是白痴去阅读文档 格式：就近解释 对比：分析优缺点，得出结论 引入新的内容需要有过渡条件 开头表明意图，用数据说话9.最终目的时让白痴都能看懂且没有疑惑 圈复杂度学习 衡量代码中分支结构的复杂程度，方便去做重构和测试。 工具：SourceMonitor、Javancss 有效沟通的方式 有效沟通就是：效率、效果 讲好处，让别人去体会并决定是否去做 插件化 动态加载 动态更新 ReactNative、小程序 JavaWeb设计接口 /servlet 随意配置，一般采用 doGet 处理请求 利用 Gson 的一个工具将数据转为 Json 数据即可 总结 Q1 虽然没写多少代码，但是见识增长了，了解了很多新的内容，这些内容对于之后开发肯定有很大的帮助。加油吧！]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圈复杂度详解]]></title>
    <url>%2F2017%2F04%2F09%2F%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、现象11. 代码设计不规范。 当项目规模达到一定的程度，比如达到十万行的代码量。那么项目肯定存在有些类特别大，方法特别多、特别长。 以上因素会导致什么后果呢？ 一个类没有做到单一指责，后期对这个类改动会导致其他功能出现Bug。 代码阅读性较差，维护困难。12. 没有一个准确的标准去衡量代码结构复杂的程度。 各个公司都会有自己的规范，但是开发中很少人能够去完全遵循规范。而且没有一个明确的标准去衡量代码的复杂程度，而且人工去检测代码的复杂程度是很繁琐的。因此我们急需一个标准去检测代码结构复杂的程度，而圈复杂度这个技术就能够很好的去衡量代码的复杂程度。 二、圈复杂度的定义 圈复杂度是用来衡量一个模块判定结构的复杂程度，数量上表现为独立路径的条数。而独立路径就是在控制流程图中从起点到终点的一条回路。1.1 控制流图（CFG, Control flow graph）也叫控制流程图。是一个过程或程序的抽象表现。常以数据结构链的形式表示。网上给出常见的控制流图结构（简化版）如下：![这里写图片描述](http://img.blog.csdn.net/20170409225836708?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSVR4aWFvZG9uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 圈复杂度高在代码中的表现形式：在一段代码中含有很多的 if / else 语句或者其他的判定语句（if / else , switch / case , for , while , | | , ? , …）。 三、采用圈复杂度去衡量代码的好处11. 指出极复杂模块或方法，这样的模块或方法也许可以进一步细化。 开发者可以根据圈复杂度的值来确定哪块代码需要优化。12. 限制程序逻辑过长。 McCabe&amp;Associates 公司建议尽可能使 V（G） &lt;= 10。NIST（国家标准技术研究所）认为在一些特定情形下，模块圈复杂度上限放宽到 15 会比较合适。 因此圈复杂度 V（G）与代码质量的关系如下： V（G） ∈ [ 0 , 10 ]：代码质量不错； V（G） ∈ [ 11 , 15 ]：可能存在需要拆分的代码，应当尽可能想措施重构； V（G）∈ [ 16 , ∞ )：必须进行重构； 13. 方便做测试计划，确定测试重点。 许多研究指出一模块及方法的圈复杂度和其中的缺陷个数有相关性，许多这类研究发现圈复杂度和模块或者方法的缺陷个数有正相关的关系：圈复杂度最高的模块及方法，其中的缺陷个数也最多，做测试时做重点测试。 四、圈复杂度的计算1231. 手工计算： 计算公式1：V（G）= E - N + 2 计算公式2：V（G）= 区域数 = 判定节点数 + 1 V（G）：代表圈复杂度，有些地方会用 M 或者 CC 表示。 E ：代表控制流程图的路径数量。 N ：代表节点数量。 区域数：需修改控制流图，每一个结束点都增加一个到启始点的边。找出在控制流图中构成回路的个数。 判定节点数：控制流图中判定节点的个数。如if，case的个数 这里有个简单的控制流程图，大家可以参考： 手工计算的缺点： 繁琐 低效 1工具计算（SourceMonitor） 优点是： ① 完美弥补手工计算的缺点。 ② 快速简便 。 ③ 能计算复杂嵌套代码的圈复杂度 。 ④ 能计算类和方法的圈复杂度。 ⑤ 能以图或者表格显示结果。 缺点是： ① 代码结构很复杂时，工具计算和手工计算的误差会比较大。 ② 打开的项目很大时，有些文件扫描不到。 五、优化方法针对以上问题，网络上有很多种优化方法，这里列举两个常见的代码段进行分析。（以下计算全用Sourcemonitor工具计算，人工计算和工具计算会有一点误差，可以接受） 多个 if – else 语句 优化前V（G）= 6123456789101112131415String getValue(String param) &#123; String value ; if(&quot;name&quot;.equals(param)) &#123; value = mName; &#125; else if(&quot;hight&quot;.equals(param)) &#123; value = mHight; &#125; else if(&quot;X&quot;.equals(param)) &#123; value = mX; &#125; else if(&quot;Y&quot;.equals(param)) &#123; value = mY; &#125; else &#123; value = null ; &#125; return value; &#125; 优化后V（G）= 1123456789101112private static String getName() &#123; return mName;&#125;private static String getHight() &#123; return mHight;&#125;private static String getX() &#123; return mX;&#125;private static String getY() &#123; return mY;&#125; 2、多个 case 语句 优化前：V(G) = 812345678910111213141516171819202122232425private static String getName(String id) &#123; switch(id)&#123; case &quot;0000&quot;: name = &quot;小吴&quot;; break; case &quot;0001&quot;: name = &quot;小王&quot;; break; case &quot;0002&quot;: name = &quot;老赵&quot;; break; case &quot;0003&quot;: name = &quot;小李&quot;; break; case &quot;0004&quot;: name = &quot;小刘&quot;; break; case &quot;0005&quot;: name = &quot;小张&quot;; break; default: break; &#125; return name;&#125; 优化后：V(G) = 512345678910111213private static String getName(String id) &#123; String name = null; String[] idArray = new String[]&#123;&quot;0000&quot;, &quot;0001&quot;, &quot;0002&quot;, &quot;0003&quot;, &quot;0004&quot;, &quot;0005&quot;&#125;; String[] nameArray = new String[]&#123;&quot;小吴&quot;, &quot;小王&quot;, &quot;老赵&quot;, &quot;小李&quot;, &quot;小刘&quot;, &quot;小张&quot;&#125;; for(int i = 0;i &lt; idArray.length;i++) &#123; Object peopleID = idArray[i]; if(peopleID.equals(id)) &#123; name = nameArray[i]; break; &#125; &#125; return name; &#125; 3、还有一些形式能导致圈复杂度增高，例如：if –if– else嵌套，switch —case —if—嵌套等具体的优化涉及到代码的重构方面，这里就不在赘述了，需要了解的可以去 Google ：【如何降低圈复杂度】即可得解 六、总结 if else ，switch case 等判断语句会增加圈复杂度，导致代码复杂，不方便维护。 以后写代码按照制定的代码规范来，同时避免写 if，for 多层嵌套的代码。 写完代码可以用圈复杂度来检测代码的质量，圈复杂度高的代码需要重构。 圈复杂度只是衡量代码判定结构的复杂程度，不代表圈复杂度低的代码质量就好，但是圈复杂度高的代码肯定不好。]]></content>
      <tags>
        <tag>圈复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Url 统一域名及 DNS 劫持的相关问题]]></title>
    <url>%2F2017%2F03%2F12%2FUrl%E9%87%8D%E6%9E%84%E4%BB%A5%E5%8F%8A%E9%98%B2DNS%E5%8A%AB%E6%8C%81%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[为什么做Url配置？ Url 格式不统一。 由于公司的 Url 设计的不合理同时没有统一的规范。每个功能对应着 2 条 Url ，一条正式，一条测试。而且正式接口和测试接口是的域名是有很大差别的（Url 保密 ，有些内容用数字和*代替，文中皆是）。 例如：搜索的接口正式：http://***.****.net/json.php?do=Search搜索的接口测试：http://***.test.****.cn/json.php?do=Search 有的接口是可以划分为同一模块，但是并没有。 如下：搜索的接口：http://123.****.net/json.php?do=Search.Bar搜索首页信息的接口：http://234.****.com/json.php?do=Main 二者都属于搜索，但是接口差别却很大。域名没有统一。 而且公司中有些不同的功能用的还是同一接口，这样会导致一个接口出问题了等于两个功能同时不能使用，影响很大。 不方便客户端实现代码。查看关于 url 的配置这块代码，发现新添加一个功能，需要在很多地方修改代码，根据开闭原则，对于程序应该是对扩展开放，对修改封闭。很明显是违背了这一原则，像我这种菜鸡第一次配置肯定会由于配置混乱而导致Bug出现。 怎么去做？ 分析现有 Url 的结构，对所有Url进行模块划分上述问题主要是 Url 的域名以及域名之后的参数不够明确对应的功能和域名不够统一，由于 Url 的不规则，导致客户端的实现容易出 Bug，因此我们要做的就是将 Url 进行模块化划分，就是将属于同一个模块的Url进行统一设计和分类。 例如搜索模块之前的域名由于历史原因不方便修改，所以就不对之前的域名进行修改，以后新添加的功能对应的域名就应该按模块化划分。可以是域名一致，当功能点不同时可以在域名之后添加不同的参数。例如：搜索功能一的 Url 如下表示：http://search.****.com/function1/...，搜索模块二的 Url 如下表示：http://search.****.com/function2/...， 对代码进行优化。通过分析原有代码发现，添加一个新功能比较繁琐。代码冗余，每添加一个新功能都要添加一个静态方法，静态方法过多会导致不容易做单元测试，而且每产生一个静态方法就会占用一点内存，当静态方法过多时会占用更多内存，严重时会导致内存溢出。 经上分析，我们目前的优化方式是：控制开关( 判断是采用正式接口还是测试接口 )和 Url 接口分别写在 XML 文件中，在 Java 类中只写一个方法去调用开关和 Url 接口然后判断是使用正式接口还是测试接口。 Retrofit 简介 一个类型安全的Android和Java的HTTP客户端Retrofit是基于异步线程的网络请求框架，支持线程安全，开发者无需关心线程问题。 使用注解去声明HTTP请求例如： @GET(“group/{id}/users”) Call]]></content>
      <tags>
        <tag>URL重构</tag>
        <tag>防DNS劫持</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不必纠结MVC还是MVP，听我说两句~]]></title>
    <url>%2F2017%2F02%2F21%2F%E4%B8%8D%E5%BF%85%E7%BA%A0%E7%BB%93MVC%E8%BF%98%E6%98%AFMVP%EF%BC%8C%E5%90%AC%E6%88%91%E8%AF%B4%E4%B8%A4%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[故事开始MVC全称是Model-View-Controller 也就是模型–视图–控制器。是在1970年的时候提出由TrygveReenskaug在Smalltalk-80系统上首次提出的。 SmallTalk在百度百科的解释是这样: Smalltalk被公认为历史上第二个面向对象的程序设计语言和第一个真正的集成开发环境 (IDE)。 来张图说明一下MVC的工作模式吧 图中红色小框框就是MVC的工作模式 从图中可以看出用户向View发送指令，再有View直接要求Modle改变状态 用户也可以直接向Controller发送指令，再由Controller发送给Model，再通过Model去改变View的状态 所以MVC框架模式View和Model之间的联系还是相当紧密，耦合度还是很高，后期维护改动View需要将Model中的内容也要改动。 MVC是一种框架模式而非设计模式其优点是： 理解起来比较容易，技术含量并不高，对开发和维护来说易于维护和修改 耦合度不高，表现层与业务层分离，各司其职。 其缺点是： 它定义不是很明确，完全理解MVC模式并不容易。 使用MVC需要精心策划，因为它的内部原理比较复杂 一些小的项目采用MVC框架反而会更加复杂 MVC的Android伪代码实现 以下图片中代码与数据不匹配，只是为了方便理解MVC在代码中如何写，需要看实例的可以去网上了解，我在这里就偷懒了：） 首先你需要一个View视图，也就是XML布局。 然后你还需要一个Model也就是数据，可以是数据库中的内容，也可以是在代码中写的List集合。 最后需要一个Controller，也就是Activity或者Fragment通过在Controller中对用户在View中传递过来的操作，进行访问model中的数据，然后改变View中的状态。 MVP是MVC的一个演化版本，全称是Model-View-Presenter。MVP的出现主要就是解决MVC中的View和Model的耦合性高的的问题，同时又带来了很好的扩展性。 MVP模式的三个角色的作用： Presenter-中介主演沟通View和Model的桥梁，它从Model获取数据后返回给View层，使得View层和Model层之间没有耦合，从而将业务逻辑从View层抽离。 Model-房主Model主要提供数据的存取功能，Presenter需要通过Model层存储、获取数据，Model层就像是一个仓库。 View-用户View通常是指Activity、Fragment或者某个View控件。它持有一个Presenter成员变量，同时它需要实现一个逻辑接口，将View上的操作转交给Presenter层进行实现，最后Presenter层调用View层逻辑接口将结果返回给View元素。 来张图说明一下MVP的工作模式吧 从图中我们可以看出MVP和MVC之间的额最大区别： View和Model之间彻底的解耦 MVP是面向接口编程，也就是说用户不必知道我是具体如何实现的，用户只要知道有这个功能接口，直接调用即可。 MVP的Android伪代码实现 以下图片中代码与数据不匹配，只是为了方便理解MVC在代码中如何写，需要看实例的可以去网上了解，我在这里就偷懒了：） 首先需要一个Presenter，作为View和Model的中间人 然后你还需要一个View以及ViewImpl接口 最后你还需要Model一个ModelImpl接口 为什么说不必纠结是MVC还是MVP呢？ MVC和MVP的最终目的就是要数据和UI分离，互相不影响。那么如何能不必纠结而做到呢？？你听说过面向对象吗？听过再听听我的理解~ 面向对象封装、多态，继承。老师好像也都是这么教的，那么到底什么才是多态封装继承呢？ 封装封装就是将用户不想看到的东西封装起来，可以用到面向对象中的 Private属性，将用户不想看到的内容写在这里面。比如收音机上的播放功能，用户不用知道收音机如何播放，它只需要知道摁下这个键能播放即可。 多态多态就是一个对象的多种表现形态，主要表现为：行为多态和状态多态。行为多态就好比一个父亲有多个孩子，每个孩子都不一样，但是都是同一个父亲；状态多态就好比每个孩子在一天中有好多个状态变现，有吃饭，学习，睡觉。 继承？不！我想说的是对象！我的一个朋友告诉我继承其实是对面向对象的最大误解。继承我们可以理解成一个对象他有多个小对象组成；比如人这个对象是由手脚，脑袋…等其它小对象组成。因此继承我们可以不去记住，我们只要对每个对象有深刻的认识即可把对象用代码描述清楚！ 那么MVC、MVP与面向对象有什么关系呢？？ 首先MVC和MVP都是要求数据和UI之间互不影响，那么面向对象不就是吗！？ 面向对象View?对象可以看作是我们说的用户也就是MCV或者MVP中View，用户需要什么我们就展示给其什么，不需要的我们将其封装起来提供一个方法给你调用即可，这是不是和MVC或者MVP中很像！ 面向对象Model?同时面向对象也是需要将对象的行为细分，比如人可以跑，可以游泳…这是不是和MVC中的Model一样，需要处理用户不同的操作。 面向对象Controller?最后面向对象也是需要一个状态去控制的，比如人的大脑。通过大脑去协调手和脚的平衡。 学点英文It is not easy to meet each other in such a big world.世界这么大，能遇见，不容易。—- 2月18号倩儿]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity和Fragment之间的数据通信]]></title>
    <url>%2F2016%2F09%2F26%2FActivity%E5%92%8CFragment%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[Activity和Fragment之间的数据通信有两种：Activity向Fragment中传递数据、Fragment向Activity传递数据。 同时Activity之间也能传递数据，Fragment之间又能传递数据。本文主要是总结自己在项目中遇到的问题以及解决办法！ Activity向Fragment中传递数据项目中遇到的问题：项目采用的是一个MainActivity + 4个Fragment搭建的框架，其余的小功能采用的是Activity去实现；在实现个人中心（Fragment）时需要将登录的用户名返回给个人中心显示在页面上。 我的实现方法： 通过用户注册时向数据库中插入用户信息，在用户中心判断用户是否存在，存在则显示用户名。这个方法有点不像Fragment向Activity传递数据的解决办法。但是能实现我所要求的功能。（本人小白，能实现功能已经高兴一天了，哈哈） 网上的数据传递方法 1（链接）： 给Fragment添加newInstance方法，将需要的参数传入，设置到bundle中，然后setArguments(bundle)，最后在onCreate中进行获取； 注意事项：setArguments方法必须在fragment创建以后，添加给Activity前完成。千万不要，首先调用了add，然后设置arguments 网上的数据传递方法 2 直接在Fragment中采用getActivity.getIntent()拿到Activity中的参数，故此能拿到Activity中的方法 网上的数据传递方法 3 Activity在切换Fragment的时候，通过setArguments向Fragment传递参数，Fragment通过getArguments();获得从activity中传递过来的值 Fragment向Activity传递数据 网上的数据传递方法 1（链接）： 在Fragment中写一个回调接口 在Activity中实现这个接口 在Fragment中的onAttach方法中得到Activity中实现好的实例化接口对象 用接口对象进行传值 Activity向Activity传递数据 第一行代码中写到： 活动之间传递数据可以采用new Intent().putExtra()方法传递，putExtra()方法的第一个参数是键，第二个参数是值；在第二个Activity中getIntent即可拿到第一个Activity传递过来的intent，在通过intent.get…Extra()过来方法拿到第一个Activity传递过来的数据。 使用Bundle来传递数据：首先创建一个Bundle对象，采用bundle.putExtra()方法，道理同上，接着intent.putExtra(bundle)传递数据。在第二个Activity中getIntent即可拿到第一个Activity传递过来的bundle，在通过bundle.get…Extra()过来方法拿到第一个Activity传递过来的数据。 Activity返回数据给上一个Activity 第一行代码中如此写到： 在第一个Activity中启动第二个Activity：startActivityForResult(intent,1)//第一个参数是intent，第二个参数是请求码，只要值唯一就ok 在第二个Activity中用intent携带数据，然后setResult(RESULR_OK,intent)；将数据返回，最后finish();关闭当前Activity（切记一定要关闭当前Activity） 在第一个Activity中重写onActivityResult( int requestCode,int resultCode,Intetnt data)方法,通过判断requestCode来识别是哪个Activity返回的数据，在判断返回数据的处理结果，最后通过data.getStringExtra()方法拿到数据。 Fragment向Fragment传递数据回顾项目中采用一个MainActivity + 4个Fragment搭建的框架，那么我想在其中的两个Fragment之间有数据交互怎么解决？ 第一行代码中如此说道： 首先在一个Fragment中拿到与之相关联的Activity，然后通过这个Activity去获取另一个Fragment，这样就实现了Fargment与Fragment之间的通信 网上的说法（链接）： 在Fragment2中，新建一个函数:newInstance(String text)来接收传过来的参数 然后在Fragment2的OnCreateView的时候再从arguments中获取参数 在Fragment1中，在调起Fragmen2t时，通过调用newInstance函数来获取实例并传递参数 Fragment2返回数据给ragment1 采用回调方法实现[直接看第三部分]（链接） 总结 数据传递出去： 可以采用intent，或者bundle传递出去 可以采用新建一个setValue方法将数据传递出去 采用回调方法实现数据传递 数据传递回来: 采用接口回调方式 因此接口回调方法很重要，一点要掌握！！ 安利一下我的Github账户还有我的博客地址 GitHub 我的博客]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub上不错的库]]></title>
    <url>%2F2016%2F08%2F28%2F%E5%80%BC%E5%BE%97%E4%B8%80%E7%9C%8B%E7%9A%84GitHub%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[注册登录 https://github.com/fanrunqi/MaterialLogin（源码，可以直接参考） https://github.com/shem8/MaterialLogin（原生的登录，直接添加依赖就可以用） 播放音乐 https://github.com/iammert/MusicPlayerView（音乐播放界面做的很好） https://github.com/andremion/Music-Player（完整的音乐播放器） http://www.tuicool.com/articles/fUbUZz3（音乐API数据） 夜间模式 https://github.com/hehonghui/Colorful https://github.com/hongyangAndroid/ChangeSkin 下拉刷新、上拉加载更多 https://github.com/bingoogolapple/BGARefreshLayout-Android https://github.com/shichaohui/AnimRefreshRecyclerView https://github.com/LuckyJayce/MVCHelper 介绍下拉刷新、上拉加载更多的一些优秀博客 http://www.cnblogs.com/android-blogs/p/5354284.html http://www.jb51.net/article/84634.htm http://blog.csdn.net/jdsjlzx/article/details/51794220 https://github.com/blipinsk/RecyclerViewHeader（RecyclerView添加头布局） http://www.jianshu.com/p/991062d964cf# （瀑布流）RecyclerView的使用 http://www.aiuxian.com/article/p-1693380.html 实现上拉加载更多的SwipeRefreshLayout http://www.cnblogs.com/krislight1105/p/5251893.html android卡片式布局（CardView）http://blog.csdn.net/duanymin/article/details/44979355 recyclerview分页加载 http://blog.csdn.net/u014775861/article/details/51031078 二维码扫描 https://github.com/liang530/ScanCode 网络数据的加载 https://github.com/square/okhttp https://github.com/square/retrofit https://github.com/hongyangAndroid/okhttputils 动图轮播 https://github.com/Jude95/RollViewPager]]></content>
      <tags>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记-小知识点]]></title>
    <url>%2F2016%2F08%2F28%2FAndroid%E5%B0%8F%E7%9F%A5%E8%AF%86~%2F</url>
    <content type="text"><![CDATA[记录平时开发中遇到的小问题，以便下次查找。目前有以下小知识点： 毫秒转换为年月日的代码段 Snackbar 与 Toast 小区别 TextView 设置不同的文本颜色 fragment再一次点击后刷新页面的方法 启动百度地图导航页面 软键盘和搜索框冲突的解决办法 …… Snackbar 与 Toast 小区别： Snackbar activity消失后不显示内容 Toast activity消失后仍显示内容 Androidstudio下Module的导入步骤 file---import module ---找到路径---导入---在build.gradle(app)下---添加compile project(&#39;:module名&#39;) 使用 Fragment 小心导包出错 导包一定要一致，例如要导包import android.support.v4.app.Fragment;就全部导这个包，要导import android.app.Fragment;包就全部导这个包 截取字符串 substring() public String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。该子字符串从指定的 beginIndex 处开始， endIndex:到指定的 endIndex-1处结束。 示例： “hamburger”.substring(3,8) returns “burge” “smiles”.substring(0,5) returns “smile” 参数：beginIndex - 开始处的索引（包括）。 endindex 结尾处索引（不包括）。 返回：指定的子字符串。 抛出：IndexOutOfBoundsException - 如果 beginIndex 为负，或length大于字符串长度。 将毫秒转换为年月日的代码段1234long time = questionInfo.getTime() ;//通过实体对象拿到数据Date date = new Date(time);SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); holder.tv_question_time.setText(simpleDateFormat.format(date));//给TextView设置数据 listview 刷新时图片闪烁 给控件设置 setTag和getTag解决 2017年7月3号更新TextView 设置不同的文本颜色 方案一 TextView textView = (TextView)findViewById() ; String str=”默认颜色红颜色“; // String str=”默认颜色红颜色“; textView.setTextSize() ; // textView.setText(Html.fromHtml(str)) ; 方案二 SpannableString spanStr = new SpannableString(&quot;默认颜色红颜色&quot;) ; spanStr.setSpan(new ForegroundColorSpan(Color.parseColor(“#FF0000”)), 4,spannableString.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); tv.setText(spannableString); /** 其中，”默认颜色红颜色” 为你要改变的文本。setSpan方法有四个参数，ForegroundColorSpan是为文本设置前景色，也就是文字颜色。如果要为文字添加背景颜色，可替换为BackgroundColorSpan。4为文本颜色改变的起始位置，spannableString.length()为文本颜色改变的结束位置。最后一个参数为布尔型，可以传入以下四种。 Spanned.SPAN_INCLUSIVE_EXCLUSIVE 从起始下标到终了下标，不包括起始下标，包括终了坐标 Spanned.SPAN_INCLUSIVE_INCLUSIVE 从起始下标到终了下标，同时包括起始下标和终了下标 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE 从起始下标到终了下标，都不包括起始下标和终了下标 Spanned.SPAN_EXCLUSIVE_INCLUSIVE 从起始下标到终了下标，包括起始坐标，不包括终了下标*/ Html.fromHtml(string) 直接修改字符串的资源 也可以直接引用xml的设置的字符串资源 修改字体颜色、加粗、 SpannableStringBuilder : 修改字体颜色 设置字体背景颜色设置字体大小 设置粗体斜体 设置删除线 设置下划线 设置图片—-将位置为多少多少的地方设置为图片 设置点击事件 fragment再一次点击后刷新页面的方法 给每个Fragment设置一个Tag，通过判断Tag来刷新数据 重写这个方法 onHiddenChanged 里面做刷新操作 启动百度地图导航页面12345678String url = &quot;http://api.map.baidu.com/direction?origin=33.988177,118.786991&amp;destination=32.047616,118.790609&amp;mode=driving&amp;output=&quot;Uri uri = Uri.parse(url);intent = new Intent(Intent.ACTION_VIEW);intent.setData(uri);intent.setPackage(com.baidu.BaiduMap);mContext.startActivity(intent); SimpleDraweeView第三方插件不支持wrap_content glide 可以加载图片获取图片的真实宽高 软键盘和搜索框冲突的解决办法参考：http://www.a-site.cn/article/1219953.Htmlhttp://blog.csdn.net/zhangzhikaixinya/article/details/7802059 xml 中添加—部分机型可用 123456789 &lt;activity android:name=&quot;.MainActivity&quot; android:windowSoftInputMode=&quot;adjustPan|stateHidden&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; listView.setTranscriptMode(ListView.TRANSCRIPT_MODE_NORMAL)—测试不可用 根布局设置为ScrollView——可行 计算高度去实现—-可行 AndroidStudio新建module的问题当module中导入aar不行时，可以将aar添加到主项目中的libs目录下，然后在主builde.gradle文件里添加对应的compile name:’SMSSDK-3.0.0’,ext:’aar’ 2017年12月27日更新TextView 动态设置 drawableLeft, TextView 设置行间距TextView 动态设置 drawableLeft，其他方向同理 Drawable drawable= getResources().getDrawable(R.drawable.topic_detail_no_collect); // 这一步必须要做,否则不会显示. drawable.setBounds(0, 0, drawable.getMinimumWidth(), drawable.getMinimumHeight()); collection.setCompoundDrawables(drawable,null,null,null); TextView 设置行间距 1、android:lineSpacingExtra 设置行间距，如”3dp”。 2、android:lineSpacingMultiplier 设置行间距的倍数，如”1.2″。 微信朋友圈的点赞弹出框12345678910111213141516171819202122232425private void showCollectionSharePopupWindow() &#123; // 弹出收藏和分享 LayoutInflater inflater = (LayoutInflater)this.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View content = inflater.inflate(R.layout.popup_collection_share, null, false); mPopupWindow = new PopupWindow(content, ViewGroup.LayoutParams.WRAP_CONTENT, DensityUtils.dp2px(this, 34f));//固定34dp的高度 mPopupWindow.setBackgroundDrawable(new BitmapDrawable()); mPopupWindow.setOutsideTouchable(true); mPopupWindow.setTouchable(true); content.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED); mMeasuredWidth = content.getMeasuredWidth(); mMeasuredHeight = content.getMeasuredHeight(); View parent = mPopupWindow.getContentView(); // TODO 设置不同的状态显示不同的图标 if (mPopupWindow.isShowing()) &#123; mPopupWindow.dismiss(); &#125; else &#123; float scale = getResources().getDisplayMetrics().density; int heightMoreBtnView = headViewViewColletionAndShareImg.getHeight(); mPopupWindow.showAsDropDown(view, (int)(-160*scale), (int)(-20*scale)); &#125; &#125; 微信右上角的弹窗实现1234567891011121314151617181920// 设置SelectPicPopupWindow弹出窗体的宽 popupWindow.setWidth(LayoutParams.WRAP_CONTENT); // 设置SelectPicPopupWindow弹出窗体的高 popupWindow.setHeight(LayoutParams.WRAP_CONTENT); // 设置SelectPicPopupWindow弹出窗体可点击 popupWindow.setFocusable(true); popupWindow.setOutsideTouchable(true); View view = LayoutInflater.from(this).inflate(R.layout.popupview_right_top_image, null); // TODO 初始化布局 // TODO 具体的点击和设置数据 popupWindow.setContentView(view); popupWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); popupWindow.setOutsideTouchable(false); popupWindow.setFocusable(true); int[] popWindowPos = PopupWindowUtils.calculatePopWindowPos(mToolbar, view); int xOff = popWindowPos[0]-20 ; // 右边的偏移量 popWindowPos[0] -= xOff ; popupWindow.showAtLocation(view, Gravity.TOP|Gravity.END, popWindowPos[0],popWindowPos[1]); 使用 Toolbar 内容不 macth_parent参考：http://blog.csdn.net/yypccc/article/details/53694570 在ToolBar中添加RelativeLayout match_parent 时左边出现5dp的空白（查看源码278行可知） 解决办法： 在 Toolbar 布局中添加如下内容 app:contentInsetStart=&quot;0dp&quot; 阴影的实现 layer-list TextView 文本加阴影，有API android:translationZ android:elevation ViewCompat 是对 Elevation 的兼容 NestedScorllView + recyclerview 展示布局，recyclerview 抢占焦点解决 在整体页面布局的跟布局设置 android:focusableInTouchMode=&quot;true&quot; android:focusable=&quot;true&quot; android:descendantFocusability=&quot;beforeDescendants&quot; 或者是： 设置recyclerView.setFocusable(false) 即可 AppBarLayout 去掉 toolbar 下方的阴影1app:elevation=&quot;0dp&quot; CountDownTimer 在 dialog 中使用要在 onTick 方法中判断activity是否为空不为空则开始倒计时 实现悬浮头 Recycler View - 继承 RecyclerView.ItemDecoration 实现 PinnedListView 高斯模糊 Glide 实现添加第三方库 系统自带的 RenderScript 二阶贝塞尔曲线 有计算公式，需要知道起始点，终点，还有中间受力的点 git 本地提交成功了，但是远端没看到，可能时本地的邮箱和远端的邮箱不一致，修改邮箱即可(1) 到当前目录下 git config user.email (2) 邮箱不一致则 git config --global user.email &quot;youemail@xxx.xxx&quot;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 命令记录]]></title>
    <url>%2F2016%2F08%2F16%2F%E4%BD%BF%E7%94%A8git%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Git 是一个开源的分布式版本管理工具。他的开发者是 Linux 操作系统的作者 Linus Torvalds。Git 被开发出来的初中是为了更好的额管理 Linux 内核，而现在已经被广泛的应用于各种大中小型的项目。 当我执行git add .的时候没报错，接着执行git commit -m “F code”，也没出现问题。接我我高兴的有执行了git push origin 这时候灾难来了。。提示我一些错误，我照着错误网上找了一下结果，没有找到可以解救的办法。于是我仔细一思考：出现这个原因，应该是我之前在笔记本电脑上提交了一次更新，然后我在家里的台式机有提交了一次跟新，导致更新冲突！！，于是我又接着上网找git更新冲突的解决办法。但是老天不帮我，找不到。。 最后的最后我想起之前有过一次类似的经历，我先是将项目clone下来，然后将github上的项目仓库也给删除了。然后我重新创建一个一模一样的项目，再将代码添加进去应该就OK了但是啊但是！！不仅那么多天的提交记录没有了，而且项目在AndroidStudio中还是显示不出文件夹结构（在Android下），我崩溃了。。 更新一下AndroidStudio希望有用！！ 问题androidstudio的android目录下显示不出文件！！ 后记记得备份 2017年7月3号更新Git命令Git是世界上最先进的分布式版本控制工具。 Git教程 Git和SVN的区别 SVN是集中式版本控制系统，版本库是几种放在中央服务器的，工作的时候先从中央服务器获取到最新的版本后才能工作，完成工作后将做完的任务推送到中央服务器。集中式版本控制系统是必须联网才能工作。 Git是分布式版本控制系统，它没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候可以不用联网 集中式和分布式的区别是 集中式开发是将项目集中存放在中央服务器中，在工作的时候，大家只在自己电脑上操作，从同一个地方下载最新版本，然后开始工作，做完的工作再提交给中央服务器保存。这种方式需要联网，现在云开发就是这样的处理方式。 集中式的缺点：（1）如果网络出现异常或者很卡，直接影响工作效率。如果是中央服务器挂了，那就集体喝茶去了。 （2）还有一种情况，各自电脑中操作的所有软件工具，都存放在一个中央服务器上（现在流行叫云服务器），只需要用各自电脑登陆连接到云服务器上，（一般服务器都是用linux），比如用ps工具，大家其实用的是云服务器中的同一个ps 软件，在使用率高的情况下，ps会出现异常，当用ps筛选颜色的时候，已经混乱，无法正常选择颜色，这个情况是我在开发中遇到的。以前我们是每个人用各自安装的ps,但是在这样的环境下用的是同一个ps软件的时候就会有ｂｕｇ。（3）安全度不高，重要的东西都放在一个中央服务器中，如果被黑，那损失就大了。 分布式开发：只要提供一台电脑作为版本集中存的服务器放就够了，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它也一样干活，只是交换修改不方便而已。而每一台电脑有各自独立的开发环境，不需要联网，本地直接运行，相对集中式安全系数高很多。 ​ Git的工作流程 克隆 Git 资源作为工作目录。clone 在克隆的资源上添加或修改文件。add 如果其他人修改了，你可以更新资源。status 在提交前查看修改。diff status 提交修改。commit push 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。reset commit push 新建代码库在当前目录新建一个Git代码库$ git init 新建一个目录，将其初始化为Git代码库$ git init [project-name] 下载一个项目和它的整个代码历史$ git clone [url] 配置显示当前的Git配置$ git config –list 编辑Git配置文件$ git config -e [–global] 设置提交代码时的用户信息$ git config [–global] user.name “[name]”$ git config [–global] user.email “[email address]” 添加文件 git add README hello.php $ git add . 添加当前目录的所有文件到暂存区 提交 使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中 Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。 12$ git config --global user.name &apos;runoob&apos;$ git config --global user.email test@runoob.com 查看提交记录 git log git log –oneline 选项来查看历史记录的简洁的版本 我们还可以用git log –oneline –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项 显示有变更的文件$ git status 显示当前分支的版本历史$ git log 显示commit历史，以及每次commit发生变更的文件$ git log –stat 显示某个文件的版本历史，包括文件改名$ git log –follow [file]$ git whatchanged [file] 显示指定文件相关的每一次diff$ git log -p [file] 显示指定文件是什么人在什么时间修改过$ git blame [file] 显示暂存区和工作区的差异$ git diff 显示暂存区和上一个commit的差异$ git diff –cached [file] 显示工作区与当前分支最新commit之间的差异$ git diff HEAD 显示两次提交之间的差异$ git diff [first-branch]…[second-branch] 显示某次提交的元数据和内容变化$ git show [commit] 显示某次提交发生变化的文件$ git show –name-only [commit] 显示某次提交时，某个文件的内容$ git show [commit]:[filename] 显示当前分支的最近几次提交$ git reflog 查看谁修改了代码 git status 命令用于查看项目的当前状态 执行 git diff 来查看执行 git status 的结果的详细信息 撤销缓存区的修改 git reset HEAD 命令用于取消已缓存的内容。 1$ git reset HEAD -- hello.php 撤销具体文件 分支 列出所有本地分支$ git branch 列出所有远程分支$ git branch -r 列出所有本地分支和远程分支$ git branch -a 新建一个分支，但依然停留在当前分支$ git branch [branch-name] 新建一个分支，并切换到该分支$ git checkout -b [branch] 新建一个分支，指向指定commit$ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系$ git branch –track [branch] [remote-branch] 切换到指定分支，并更新工作区$ git checkout [branch-name] 建立追踪关系，在现有分支与指定的远程分支之间$ git branch –set-upstream [branch] [remote-branch] 合并指定分支到当前分支$ git merge [branch] 选择一个commit，合并进当前分支$ git cherry-pick [commit] 删除分支$ git branch -d [branch-name] 删除远程分支$ git push origin –delete [branch-name]$ git branch -dr [remote/branch] 合并分支（提交代码用） git merge 解决冲突步骤 进入文件 cat test.txt git diff 手动修改冲突文件 git status git add . git commit -m “” git push 远程相关 从仓库clone git clone git@github.com:tianqixin/runoob-git-test.git 添加远程仓库 git remote add origin git@github.com:tianqixin/runoob-git-test.git 1git push -u origin master 查看远程仓库 1git remote 拉取数据 1git pull 提交数据 1git push origin master # 推送到 Github 删除远程仓库 1git remote rm origin2 撤销 恢复暂存区的指定文件到工作区$ git checkout [file] 恢复某个commit的指定文件到工作区$ git checkout [commit] [file] 恢复上一个commit的所有文件到工作区$ git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] 重置暂存区与工作区，与上一次commit保持一致$ git reset –hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset –hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset –keep [commit] 新建一个commit，用来撤销指定commit 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大三生产实习记录]]></title>
    <url>%2F2016%2F08%2F06%2F%E5%A4%A7%E4%B8%89%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[很激动！为什么这么说呢？因为我学习上就是个渣渣，每次做课上的项目。都是抱别人的大腿，而这次第一次做项目组长！在这里也非常感谢那些让我抱过大腿的大神。 首先说一下为什么这次组长是我吧。我们组六个人，这次搞的是一个Android小软件（吃货宝）。组内六个人只有我和另一个小伙伴自学过一点Android基础，还有一个是在做Web项目，没时间学Android还有三个小伙伴是都没学过Java更何况有学习过Android。那个和我一起自学过Android的小伙伴，由于他学习学的有点累了，所以这个艰巨的任务就由我来承担了。 当时想想自己还是挺高兴的，毕竟能够带领一个团队从无到有的开发一款软件。但是我想的太天真了！ 第一次从无到有开发一款软件，第一次做Android开发组长。好多东西都需要学。之前自己学习Android直接上来就编码，然后编到哪里不会再去查哪里，这样非常浪费时间！而这一次，我们从项目立项，需求文档，概要设计，编码，测试。这几个阶段来完成。 我的第一个难题。文档怎么写？？谁来写？？作为组长，这个问题就需要我来解决。首先参考一下报告文档，然后找出文档写的好的组员来完成。由于是第一次合作。我们之间都没有默契，而且大家都是学生，谁都难以听从另一个学生的安排！作为组长，你需要有威慑力，让组内成员无条件服从你。就算组长的决定是错的，组员也要无条件服从完成任务！ 我的第二个难题。编码实现，由于大家都没有基础。想要在20天内做出一款软件，就需要大家都努力完成各自的任务。然而当我布置任务出去，组内成员都没有基础，遇到问题都要请教。所以白天时间基本就在解决基础问题中度过了。大部分的编码实现还都是在晚上加班实现的。而且在实现过程中自己也遇到了好多技术上的难点。自己解决也花费了不了时间。 我的第三个难题。项目的整合，这个原因原本应该可以避免。但是我认为组内成员想要在这么短时间内完成一款软件，而且是一点基础都没有。所以我就没让组内成员学习版本控制工具。导致后期项目的整合也花费了不了时间。 总结一下这20天的收获吧！ 做一款软件，文档是必不可少的，而且越详细越好。 界面原图，能画的越详细越好，最好是能一条路线全部画出。 设计软件完区分主次任务！主要任务必须先完成。(比如主要的功能完先实现，后期再想着去优化) 作为一名组长。要以身作则，要能够让组内的成员都能够很好的协同工作。同时作为技术人员，特别是一款软件的技术组长。你需要技术上很牛逼。文档内规划出的功能，你需要把握好能不能实现，为什么要实现。 同时你需要了解对手实现有哪些功能，你和产品有什么优势！ 最后非常感谢组内成员的完美配合，我们组基本实现了软件的基本功能！]]></content>
      <tags>
        <tag>生产实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程]]></title>
    <url>%2F2016%2F07%2F21%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、http协议跟socket有什么区别？ http协议是一种无状态的协议：就是每次发出请求第一步都是客户端与服务端建立连接，连接成功之后把数据传过去，服务器收到数据进行响应，然后再回传结果给客户端，这一次请求结束之后连接就断开了，下次再发新的请求就会再重新建立连接 而 socket 协议则不一样：socket协议意思就是长连接，言外之意就是发数据之后，连接不会断开，会一直保持连接 http是基于 udp协议的；socket是基于 tcp/IP 协议的 相应的优缺点就很明显了：因为http每发送请求，就会断开连接，假设有1w个用户，如果用http协议，可能同时连接服务器的只有1000个用户，因为其他用户请求完就断开连接了；如果用socket可能同时会有1w个人连接服务器，这个就比较浪费服务器资源，消耗带宽。但是socket的优势也很明显，因为一直保持连接么，每次用户发送数据都很快，不用重新建立连接的过程，而http则每次都要重新建立连接，导致效率上没有socket高效 应用：由于http协议每次都要重新建立连接，导致效率上没有socket高效；socket协议大多用IM，IM就是即时聊天应用，类似qq。微信 2、http协议一般包含两大块 请求和响应，即request和response request就是你在浏览器里输入一个网址，后者手机端发送一个网络请求都算 request request 一般包含请求的 地址、参数、header、method 地址：如www.baidu.com 参数：参数包含两块, 一种是 GET 请求 http://www.baidu.com/?key1=value&amp;key2=value2,像上述的 key1, key2 是参数的一种,这种叫做 query params,一般来说一个url 问号后面的都是参数 还有一种就是 POST 请求最初网页上填写表单，比如填用户名、密码然后提交给服务器的;这种参数不会直接显示的,他通过body的方式传递给服务端;这种参数有的叫form即表单，也有的叫 body params,默认情况下都是一种 key 、value 对的形式传递的 http的请求方法包含 get、post、delete、put、head、patch、trace、options，只不过我们常见的只有2中，即 get和post，而其他六种都是基于post方法衍生的；除了这两种，你们还需要了解 put delete这两种，总共加起来就是 get post put delete 四种最重要 而这也是 restful 最基本的概念 举个例子 假设我们有如下需求：查询学生数量，创建新学生，修改学生信息，删除学生；get /api/student/index 查询接口；post /api/student/ 携带一些 params 是创建接口；post /api/student/update 携带一些参数 修改接；post /api/student/update 携带一些参数 修改接口； 可以看到只用了 get 和 post 方法，然后 api 的 url 定义的不太一样，但是如果用了 restful 方法 就会变成如下这样；get /api/student/index 查询接口 不变；post /api/student/ 携带一些 params 是创建接口 不变；put /api/student/ 携带一些参数 修改接口；delete /api/student/携带参数 删除接口； 以上的区别： 修改跟删除直接用 http 的 method 来指定，url 哪怕一样，就可以轻松知道你的动作；这就是所谓的 restful 概念最重要的一个理念。 restful一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。—- 百度百科 header header 不管是request 还是 response 都有的一个东西；header的作用有很多，比如客户端告诉服务端 我发起的请求是什么语言；我发起的请求带的参数是什么格式的，是json还是哈希；我发起的请求需不需要带缓存；我发起的请求需要压缩等。这些信息都是通过header 传递的；服务端在返回结果的时候也有一些信息告诉客户端的，同样在header里传递，比如我返回的数据是什么格式的；我这次请求是不支持缓存的；我这次返回的数据没有压缩等。header里的信息都是一个个的哈希，即key value对；比如大家常见的一些 header里的信息 Content-Type: application/json，Cache-Control : true 等；header里默认的有很多字段，这是规定，当然你也可以自定义一些字段在里面传递，只要跟你们服务端约定好就行 - 这里有个字段叫做 Connection: keep-alive，这个字段是什么意思呢？ 就是像http能不能实现socket一样的，http如果每次都请求断开未免太没效率了，后来有人就发现 ：一般我在发起一个请求之后，可能紧接着就发起第二个请求了。如果频繁的断开重连效率太低了，于是就有了这个字段。这个字段顾名思义，就是声明连接的类型；这个字段有两个值，close 和 keep-live；如果你指定close，那么每次请求就会立马断开连接；如果你指明了 keep-live，就可以在一段时间内保持长连接，这个时间服务端可以自行配置，但是时间也不会太长，不然服务器会很吃紧，比如设置个30s，意味着这30s的时间内不会重新断开重连； response，意为服务端返回的值 服务端的返回刚刚说了有 header， response也会有header 对于app中，目前大部分的response都是json格式的数据 Android中有各种各样的json数据解析器，如gson、jackson、FastJson等等 除了 返回的数据之外还有一个比较重要的叫做状态码(叫做 http status)，一般是 200—500,比如正常的时候返回的 status 就是200，代表成功；大家常见的status code有 404 找不到；500 代表服务器挂了； 常见的几个状态码如 200表示链接成功，304表示缓存内容，404表示找不到 50x服务器挂了，其他很多状态码不常见 记法： 一般是 200开头的大多是成功；30x代表重定向，304是服务端告诉你内容没有改变，意为缓存的内容；40x一般是请求找不到，大部分是你url写错了；50x那就是服务器挂了 整个http 最主要的就是 request 和 reponse。不要只会用一些网络库发送请求，接受结果就行了，却连最基本的http知识都不了解。 3、 http 的缓存缓存是跟开发中最常见的一环，可以算是性能优化的一个大点了，缓存有两部分，客户端和服务端，做客户端的会以为缓存只有客户端才有，其实服务端更有；因为加上你没查一个数据，服务端都要到数据库重新查询一遍，那服务器压力得有多大，所以服务器会有一个缓存机制 缓存有两种机制 第一种最常见的就是时间缓存 比如我查询中国的城市信息，中国的城市信息可能很久都不会变更，对于这部分假设我就设置7天的缓存时间，意味着客户端每次请求，服务端一次查询数据库，7天之内都不会再查询数据库，直接返回给你上一次的结果，对应的 status code 就是304，这对服务器性能优化是很大的一环 缓存有没有生效一般用 header里的 cache-control 字段控制；如果客户端传递 cache-control 字段为 true 那么服务端有缓存的话就会启动缓存；如果传递 false 那么会强制服务端每次都去数据库里查询，一般不会这么干的； 缓存的时间有一个字段叫做 expired 字段，告诉你缓存过期的时间 一般来说，如果性能优化的话会有这么一个点，客户端发起一个请求，服务端返回数据，并且告诉客户端我这个请求有缓存的，缓存时间是7天，那么客户端就可以把这个请求结果缓存在本地，然后7天之内都不再发起请求，直接读取本地的缓存数据，那么会极大的节省服务器资源 第二种就是Etag 缓存 以时间为缓存的大多为那些请求数据不常变化的，但大多数场景是数据经常变化，比如我刷个微博，微博变化很快。可能1小时不会变化，但也可能1分钟就有更新，这种缓存就没法用固定的时间来进行衡量了，所以第二种缓存叫做 Etag 缓存 Etag 你们可以理解成就是一个唯一的字符串，这个字符串是服务端根据时间、用户标识、内容索引等生成的一个字符串，一旦用户的内容变化，这个Etag就会变化，如果用户内容不变化，那么Etag也不会变化 所以刷微博的话机制就是这样的，客户端发起一个请求，服务端返回了一个数据，告诉客户端，我是有缓存的，缓存的 Etag 值也返回给你了，然后我把返回的数据以及 Etag 缓存到本地，这样下次请求的话如果数据没有变化，那么服务端不会返回给你数据了，而只会返回一个 Etag值，拿到这个Etag值之后到本地去找这个Etag缓存对应的数据 etag的生成与比较都是在服务端做的 etag的缓存其实才是目前使用最多的缓存策略 主流网络库都会默认支持这两种缓存，也就说volley或者okhttp都会支持的，以volley为例，他内部实现了缓存机制，每次请求之后如果服务端支持缓存的话，他自己只直接在本地进行缓存的，也就是说 如果服务端返回了 304 ，并返回了etag，volley会自动去本地寻找上次缓存过的数据进行渲染。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发遇到的坑]]></title>
    <url>%2F2016%2F07%2F13%2FAndroid%E5%BC%80%E5%8F%91%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[AS没有报错但是运行不了 错误原因如下：12Error:Execution failed for task &apos;:app:transformClassesWithDexForDebug&apos;.&gt; com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &apos;command &apos;D:\JDK\bin\java.exe&apos;&apos; finished with non-zero exit value 1 解决的办法如下： 将buildToolsVersion改为23.0.0,即可完美解决 运行AndroidStudio项目出现两个图标，但是删除其中一个图标即可删除移除应用 原因如下在新建Activity是勾选了Launch Activity复选框 解决的办法就是新建Activity是按默认进行即可，不用勾选复选框 报错Caused by: java.lang.NoClassDefFoundError: android.support.design.internal.NavigationMenuPresenter 原因可能是xml出错或者用到了控件没有在gradle中配置 问题：androidstudio应用打包Error:(4) Error: “XXX” is not translated in “en” (English) [MissingTranslation] 解决办法： 在出问题的资源文件的 resources 标签内增加xmlns:tools=”http://schemas.android.com/tools“ tools:ignore=”MissingTranslation”两个属性即可 问题：Error:Execution failed for task ‘:app:processDebugManifest’. &gt; Manifest merger failed with multiple 原因：添加Gradle依赖后出现，目测是版本问题。。。 解决：在 manifest 中添加 xmlns:tools=”http://schemas.android.com/tools“ 标签，然后再 application 中添加 tools:replace=”android:icon,android:theme” 标签 2017年7月6日更新com.google.gson.JsonSyntaxException: java.lang.NumberFormatException: Invalid double: “”1234567错误原因是：定义的实体类数据和服务端返回的数据类型不匹配。我这里出错的是因为服务器返回的是String类型的，我给他定义成long类型。排查方法： 1. 将出错处用到的实体类打印log出来 2. 将服务器返返回的数据也打log 3. 仔细对比二者，必能找到原因（找不到的话...再问google） Java.lang.IllegalStateException: Expected BEGIN_ARRAY but was BEGIN_OBJECT at line 1 column 2 path $12345678910111213141516171819错误原因是：希望的结果是列表，但是请求的时候是一个对象我这里出错的是在请求网络接口的时候，参数应该是一个对象，我给设置成了一个List&lt;对象&gt;（有点和报错信息不一致，但是我改过后的结果是正确的）。错误代码：（封装后的OkHttp网络请求，new SpotsCallBack&lt;List&lt;Favorites&gt;&gt;关键点）okHttpHelper.post(Contants.API.FAVORITE_CREATE, params, new SpotsCallBack&lt;List&lt;Favorites&gt;&gt;(this) &#123; @Override public void onSuccess(Response response, List&lt;Favorites&gt; favorites) &#123; ToastUtils.show(WareDetailActivity.this,&quot;已添加到收藏夹&quot;); &#125;修改后的正确代码：(将 SpotsCallBack 的参数改为 Favorites 对象)okHttpHelper.post(Contants.API.FAVORITE_CREATE, params, new SpotsCallBack&lt;Favorites&gt;(this) &#123; @Override public void onSuccess(Response response, List&lt;Favorites&gt; favorites) &#123; ToastUtils.show(WareDetailActivity.this,&quot;已添加到收藏夹&quot;); &#125;排查方法： 1. 将请求网络的参数排查一遍，主要看实体类数据和集合类数据 发起网络请求后，返回的code是405是什么原因？1405是请求的方法不允许，可能原因是后台采用的是get请求而实现的时候用的是post操作，因此会返回这个code码。 2017年7月24日更新Error:(1, 0) Your project path contains non-ASCII characters. This will most likely cause the build to fail on Windows. Please move your project to a different directory. See http://b.android.com/95744 for details. This warning can be disabled by adding the line ‘android.overridePathCheck=true’ to gradle.properties file in the project directory.1原因是导入的项目目录中有中文，将项目切换到非中文目录下在导入即可。 Error:(1, 0) Plugin with id ‘com.android.application’ not found123456789打开报错的项目的build.gradle,添加如下内容buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:1.5.0&apos; // 看gradle的版本是哪个就填写哪个 &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试技巧]]></title>
    <url>%2F2016%2F07%2F08%2F%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[薄荷张哥谈如何写简历总结： 简历如何写？ 不要太花哨，你应聘的是技术，不是设计师 把基本信息要说清楚 无关的不要写，比如头像之类的 有个人博客和Github的务必写在简历上，而且Github上有拿得出手的项目 任何时候不要欺骗，否则直接被pass 应届生将证书挂上，比如四六级，奖学金，计算机相关证书 最重要的就是项目经历！！把项目写进去，2，3个为好，时间是倒序的 项目经验注意地方，一定要和应聘职位紧密联系的，比如面试Android，项目里有两个PHP项目就不好 项目经验写明你在其中的作用，写自己参与度比较高的项目 最好的项目是已经上线，而且用户量还不少 项目经验是注重考察的环节！！！ 应届生，实习生把平时练习的项目算作项目经验 必须要有一些项目经验，没有完整的做过一个项目经验别去找工作，项目不一定做全，有时间在完善也OK 简历最多控制在两页A4纸 转行经验 做项目从模仿开始 看懂后自己写 面试官问项目的具体实现，能说出来就ＯＫ 项目如何问？ 项目是什么作用 有哪些模块 自己手机必装项目演示用，有Bug最好别演示，演示时最好APP别崩溃，否则印象不好 团队的话，面试官会问你主要负责哪块功能，如果你只负责20%，建议对整个项目了解，一定要熟悉具体的实现与思路，尽量捡自己熟悉的模块说 针对性的问模块的具体实现，以及如何实现，如何优化，有网络请求还会问是自己写还是用开源库，自己写需要注意哪些问题！！用了哪些开源库，面试官再针对开源库问相关问题。比如，张哥面试还会问网络编程，post个get方法有何不同？app内缓存如何处理 尽量不提自己不熟悉的领域 项目经历总结 自己亲手做的东西一定要明白，慎重欺骗面试官 问的时候会问一些知识点相关的话题，比如你的数据是需要api交互的，那可能会问http相关，json数据解析相关，缓存相关，图片加载相关等，关联到的一些知识点最好提前做好准备 对用到的知识点虽用不着一定要看源码的地步，但是最好要懂原理，比如图片加载一定要知道二级缓存，一些常见的缓存算法等。 开源框架的原理哪怕自己不是很理解，但是网上查一下，也要把一些主要的知识点说下。自己不理解的知识点最好不要主动提，面试官问到的时候可以提两句如果不接着问就算了。如果接着往深了问，最好诚实点，直接说自己就只是到这个程度，没有仔细研究 去面试时候的一些注意事项 去面试前一定要花点时间了解下你面试的这家公司，如果你面试的不是外包公司，那肯定是有自己的产品的，知道他们的业务范围，下载体验他们的产品，最好能给产品提点意见，到时候面试的时候也许有个环节就是问你，你觉得我们的产品有哪些改进的地方 面试的时候态度要谦虚点。哪怕面试官刚好问的是你特别特别熟的领域，也不要很浮夸，觉得自己技术很牛一样，任何时候交流都要冷静，不要太浮夸给人一种对这个技术看不上眼的样子 学习能力很重要。面试的时候一定要让面试官感受到你是一个好学的人。比如问到一些知识点不会的时候，承认自己不会的同时，顺便说一下回头自己就去搜索学习下。这个小细节会给人好印象的。另外，面试官一般还会问你的个人兴趣,尽量不要提什么打游戏，唱歌之类的。业余时间提下自己经常上一些技术社区，看一些技术博客之类的，除非面试官明确说明除了技术之外你的兴趣是什么那就可以提下你喜欢的运动与爱好之类的 除了基本的知识点。面试官通常都会问一些比较深的领域，这些可能你是没接触过的，但是别气馁，这个时候面试官可能只是考察下你的技术的深度而已，看你接触知识的知识面广不，答上来加分答不上来就直接承认自己没接触过。这些领域一般包括设计模式，虚拟机，插件化，React Native之类的自己最好这些概念都接触下，被面试官问你React Native你一脸懵逼说自己没听过，不知道是干嘛的就减分了 我只给你们说下我之前常问的知识点吧。首先你得明白你的定位。比如初级的，那基本的 Activity/Fragment的生命周期，四大组件的具体作用以及用法，Activity四种启动模式的区别，ListView的优化，一些动画的使用，Java一些基础知识如最基本的 String、StringBuilder、StringBuffer的区别、如ArrayList、LinkedList的区别、Java线程的几种用法。这些初级的知识总结下来就是基础知识，也是有特定答案的知识点 如果你是应聘中级的，那会问下一些屏幕适配经验，性能优化的经验等。后面的没来得及总结。都时候到了中级再研究吧。]]></content>
      <tags>
        <tag>面试技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb笔记-2]]></title>
    <url>%2F2016%2F07%2F07%2FJavaWeb%E7%AC%94%E8%AE%B0-2%2F</url>
    <content type="text"><![CDATA[JSP内置对象out对象 说明out对象主要是向浏览器输出数据，也可以通过out对象对缓冲区操作 常用方法 123456789public abstract void print(),显示各种类型的数据，该方法需要一个参数。public abstract void println(),分行显示各种类型的数据public abstract void close(),关闭输出流public abstract void clear(),清空缓冲区的内容,不将数据发送至客户端public abstract void clearBuffer(),清空缓冲区的内容,并将缓冲区中的数据发送至客户端public int getBufferSize(),获取缓冲区的大小public int getRemaining(),返回缓冲区剩余空间的大小public abstract void flush(),输出缓冲区的数据public boolean isAutoFlush(),获取AutoFlush布尔类型的值 request对象 说明request对象是从客户端向服务器端发出请求，包括用户提交的信息以及客户端的一些信息 常用方法 123456String getParameter(String name),获取客户端的参数值，并以字符串形式返回指定参数值，如果参数不存在则返回空值String[] getParameterValues(String name),获取单个参数的所有值，主要用于获取复选框的值void setCharacterEncoding(String encoding),设置字符串编码格式，用来解决中文乱码问题String getHeader(String name),获取name的头long getDateHeader(String name),获取日期类型的name标头 response对象 说明response对象与request对象相对应，用于服务器端封装JSP处理请求后产生的结果，并将其结果响应给客户端 主要方法 123456789101112131415void addDateHeader(String name,long date),新增long类型，名称为name的标头void addHeader(String name,String value),新增String类型，名称为name的标头void setIntHeader(String name,String value),常用于设置页面的自动刷新时间间隔void setHeader(String name,String value),常用于设置页面的自动刷新时间间隔与设置浏览器有无缓冲void addCookie(Cookie cookie),在响应中增加一个指定的cookie。可通过多次调用该方法来定义多个cookieString encodeURL(String url),当需要在会话中存数数据而浏览器不支持cookie时，使用该方法会将回话ID附加到URL后void sendRedirect(String url),将页面重定向到指定的URL地址上void sendRedirectURL(String url),对指定的页面地址进行编码void setContentType(String contentType),动态指定数据内容的类型及字符编码方式void setContentTypeLength(int contentLength),设置数据内容的长度void sendError(int sc),传送状态码void setStatus(int sc),设置状态码，408/409表示网站忙，200表示响应成功，404找不到页面，500内部服务器错误 注意使用response对象的sendRedict(url)方法实现浏览器重定向功能与行为元素&lt;jsp:forward&gt;直接在服务端重定向不同，该方法需要先返回浏览器，然后由浏览器发送重定向的URL请求 session对象 说明session 用于在回话范围内，记录每个客户端的访问状态，在会话中存储的信息，在浏览器发出后续请求时可以获取这些回话的有效数据 session对象可以保存用户的登录信息，实现购物车功能等。 session工作原理 客户端首次访问服务器的一个页面时，服务器就会为该客户分配一个session对象并为session对象指定唯一ID，将该ID发送到客户端写入到Cookie中，让客户端与服务器端的session建议一一对应关系 当客户继续访问服务器上的其他资源时，服务器不再为该客户分配新的session对象，直到浏览器关闭、链接超时等 当用户重打开浏览器访问服务器网站时，服务器会重新为客户分一个session对象，并重新分配sessionID 常用方法 1234567public void setAttibute(String name,Object value),指定名字属性的值，并将它添加到session会话范围内public Object getAttribute(String value),在会话范围内获取指定名字的属性的值public void removeAttribute(String name),删除指定名字的session属性public void invalidate(),使session会话失效public String getId(),获取当前会话的IDpublic void setMaxInactiveInterval(int interval),设置会话的最大持续时间，单位是秒，负数表示会话在当前浏览器永远不会失效，0表示立即删除该Cookiepublic void getMaxInactiveInterval(int interval),获取会话的最大持续时间 Cookie对象 说明Cookie对象通常用于在浏览器端保存会话过程中的一些参数，如用户名和ID等。Cookie对象不属于JSP内置对象 作用 可以让站点跟踪特定访问者访问的次数，最后访问的时间以及访问者进入站点的路径 帮助站点统计用户个人资料 在同一站点内可使用户实现自动登录功能 写入Cookie的主要步骤 创建Cookie对象 Cookie cookie = new Cookie(); 设定Cookie的属性 cookie.setMacAge(30); 调用response.addCookie(Cookie cookie) 方法将Cookie写入到客户端 response.addCookie(cookie) session对象和Cookie对象的关系session对象能和客户建立联系依赖于客户端的浏览器是否支持Cookie,如果不支持，那么客户在不同页面之间的session可能是互不相关的 二者的不同之处 存放地点：Cookie存放在客户端的硬盘中，属于离线存放；而session存放在服务器的内存中 存货时间：Cookie可以长期存放在客户端，具体的存活时间由setMaxAge()方法做指定的参数决定；而session岁用户访问服务器而产生，服务器超时或下线而消失 安全性：Cookie存放在客户端，安全性较差；session存放在服务器端，安全性较高。 二者的联系 不论是Cookie还是session内置对象，都需要浏览器支持Coookie并且没有禁用Cookie application对象 说明负责提供某个应用在服务器运行时的一些全局信息，它在服务器启动时创建，直到服务器关闭时消失 工作原理 application对象和session对象不同，application对象实在服务器启动后产生的，当用户浏览所访问的王长的各个页面，这个application都是同一个，直到浏览器关闭，这个application对象才被取消。所有的客户的application对象都是同一个，即左右对象共享这个内置的application，而session对象是因不同的客户对象也不同。 常用方法(作用和session的相似)123public void setAttibute(String name,Object value)public Object getAttribute(String value)public void removeAttribute(String name) pageContext对象 说明JSP利用上下文对象pageContext可以获取页面的所有相关属性 config对象 说明主要用于获取服务器的配置信息。 page对象对应servlet类的实现对象，相当于this，实际上指的就是JSP本身。由于page对象占用内存很大，所以不建议使用page对象 exception对象JSP文件运行所产生的错误和异常，只有在包含&lt;%@ page isErrorPage=”true”%&gt;的页面才可以使用。 数据库JDBC驱动程序的4种类型如下： JDBC-ODBC桥，同通过ODBC数据源与数据库进行连接不过Sun强烈建议JDBC-ODBC桥接器最好用来测试，不建议在Web应用程序中使用 通过网络库进行连接的纯Java驱动程序此种类型少了ODBC这一层，应用程序直接与网络库连接，减少了中间驱动程序层。 通过中间件服务器与数据库建立链接的驱动程序这种驱动程序不用安装网络库，比且驱动程序安装在中间件服务器上，而不是客户机上。 直接与数据库连接的纯Java JDBC驱动程序完全使用Java实现，不需要其他的驱动程序，也不需要安装其他的网络库 JDBC访问数据库的基本步骤 装载驱动程序使用MySQL的驱动程序：Class.forName(&quot;com.mysql.jdbc.Dirver&quot;); 定义所要连接的数据库的地址Strng MySQLURL = &quot;jdbc:mysql://host(服务器IP):port(端口号)/dbName(数据库名)&quot;; 与数据库建立连接Connection conn = DirverManager.getConnection(url,LoginName,PassWord); 例如：连接MySQL的book数据库，用户名为root，密码为root 123Class.forName(&quot;com.myslq.jdbc.Dirver&quot;);String MySQLURL = &quot;jdbc:myslq://localhost:3306/book&quot;;Connection conn = DirverManager.getConnection(MySQLURL,&quot;root&quot;,&quot;root&quot;); 建立语句对象 12Connection conn = DirverManager.getConnection(MySQLURL,&quot;root&quot;,&quot;root&quot;);Statement stmt = conn.createStatement(); 声明并执行SQL语句 查询： 1234Connection conn = DirverManager.getConnection(MySQLURL,&quot;root&quot;,&quot;root&quot;);Statement stmt = conn.createStatement();String sql = &quot;SELECT * FORM book&quot;;ResultSet rs = stmt.executeQuery(sql);//将结果存储在ResultSet对象的结果集中。 更新： 1234Connection conn = DirverManager.getConnection(MySQLURL,&quot;root&quot;,&quot;root&quot;);Statement stmt = conn.createStatement();String sql = &quot;DELETE FORM book WHERE bookid=1234&quot;;int i = stmt.executeUpdate(sql); 对结果集进行处理ResultSet对象称为结果集，是符合条件的所有行的集合主要方法如下： boolean next()用于将结果集定位到下一行，ResultSet最初是定位在第0行上，此时应该调用next()将其定位到第一行，然后再输出。 getXxx()当ResultSet定位到某一行时，可以用getXxx()方法获得这一行单个字段的值 显示结果集中所有记录的前两列12345while(rs.next)&#123; name = rs.getString(1); score = rs.getFloat(2); System.out.println(name + &quot;,&quot; + score);&#125; 关闭对象关闭对象使用close()方法,关闭对象前需要判断对象是否为空 JavaBean组件简介 JavaBean的特点 可以实现代码的重复利用 易编写，易维护，易使用 可以在任何安装了Java运行环境的平台上使用，而不用重新编译 使用JavaBean的好处 可以是JSP页面变得清晰 节省软件开发时间 减低系统维护难度 为JSP应用带来更多的可伸缩性，使系统更加健壮和灵活 在实际中，一个JavaBean类的编码约定包括以下内容 类实现了java.io.Serializable接口 必须放在某package(包)中 如果类中有构造方法，那么这个构造方法也是公有的，并且是无参的 属性：xxx，所有属性都是私有的 getXxx():用来获取属性xxx，并且该方法是公有的 setXxx(),用来设置属性xxx,并且该方法也是公有的 对于boolean类型的成员变量，允许使用“is”代替上面的“get”和“set” 类中的普通方法不适用于上面的命名规则，当时方法必须是公有的 使用JavaBean JSP 代码段调用 JavaBean 123456789101112131415161718192021222324252627&lt;%@ page language = &quot;java&quot; contentType = &quot;text/html;charset = utf-8&quot;%&gt;&lt;%@ page import=&quot;bean.Person&quot; %&gt;&lt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;JSP代码段使用JavaBean&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% Person bean = new Person(); %&gt;初始值为：&lt;br&gt;姓名：&lt;% = bean.getName();%&gt;&lt;br&gt;年龄：&lt;% = bean.getAge();%&gt;&lt;br&gt;性别：&lt;% = bean.getSex();%&gt;&lt;br&gt;职业：&lt;% = bean.getCareer();%&gt;&lt;br&gt;&lt;% bean.setName(&quot;小明&quot;);bean.setAge(18);bean.setSex(&quot;男&quot;);bean.setCareer(&quot;学生&quot;);%&gt;&lt;br&gt;&lt;br&gt;更改后的值为：&lt;br&gt;姓名：&lt;% = bean.getName();%&gt;&lt;br&gt;年龄：&lt;% = bean.getAge();%&gt;&lt;br&gt;性别：&lt;% = bean.getSex();%&gt;&lt;br&gt;职业：&lt;% = bean.getCareer();%&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 使用&lt;jsp:useBean&gt;标记 用法一 123456&lt;jsp:useBean id=&quot;bean&quot;, class=&quot;package.class&quot; [scope=&quot;page|request|session|application&quot;] /&gt;id：给bean起名class：创建bean的类名，特别注意类名的大小写要一致scope：bean的有效范围 用法二 123456&lt;jsp:useBean id=&quot;bean&quot;, class=&quot;package.class&quot; [scope=&quot;page|request|session|application&quot;] &gt;本体内容&lt;/jsp:useBean&gt;本体内容：实际上可以看作JavaBean中需要初始化的代码 &lt;jsp:setProperty&gt;标记&lt;jsp:setProperty&gt;元素使用JavaBean实例给定的setter方法，在实例bean中设置一个或多个属性值。&lt;jsp:setProperty&gt;中的name值应当和&lt;jsp:userBean&gt;中的id值相同&lt;jsp:setProperty&gt; 标记用于设置JavaBean的属性值。其用法如下 第一种用法 1234567&lt;jsp:setProperty name = &quot;beanName&quot;property = &quot;propertyName&quot;value = &quot;propertyValue&quot; /&gt;解释：name指出是在操作哪个bean property指出对该bean的哪个属性赋值 vlaue用来指定给属性赋的值 第二种用法 1234567 &lt;jsp:setProperty name = &quot;beanName&quot;property = &quot;propertyName&quot;param = &quot;paramName&quot; /&gt;解释：name指出是在操作哪个bean property指出对该bean的哪个属性赋值 param表示传入参数的名字 第三种用法 12345678 &lt;jsp:setProperty name = &quot;beanName&quot;property = &quot;propertyName&quot;param = &quot;propertyName&quot; /&gt;注意：这里的参数名字与bean中属性名字一致解释：name指出是在操作哪个bean property指出对该bean的哪个属性赋值 param表示传入参数的名字 第四种用法 1234 &lt;jsp:setProperty name = &quot;beanName&quot;property = &quot;*&quot; /&gt;使用这种方法可以一次为多个属性赋值 &lt;jsp:getProperty&gt;标记&lt;jsp:getProperty&gt;用于获取JavaBean实例给定属性值，并将这个值转换为字符串形式显示在JSP页面中。&lt;jsp:setProperty&gt;中的name值应当和&lt;jsp:userBean&gt;中的id值相同&lt;jsp:getProperty&gt; 标记用于设置JavaBean的属性值。其用法如下 1234&lt;jsp:getProperty name = &quot;name&quot; property = &quot;propertyName&quot;&gt;解释：name属性代表JavaBean对象实例名，该实例必须在前面定义过property属性代表需要获取的那个JavaBean对象对应的属性名字 Servlet技术介绍Servlet是用Java语言编写的程序，运行于支持Java的Web服务器或应用程序中，Servlet先于JSP出现，提供和和客户端动态交互的功能。Servlet可以处理来自客户端的HTTP 请求，并生成响应返回客户端。 Servlet的优点 可移植性 安全性 高效性 Servlet的生命周期 当客户端第一次请求Servlet时，Servlet被加载到内存，容器会创建Servlet实例，并调用init()方法进行初始化工作 容器创建请求对象和响应对象。然后调用Servlet的service()方法为客户端提供服务 当Servlet不在被需要时，容器调用Servlet的destroy()方法将Servlet实例销毁 Servlet的常用API HttpServlet的常用方法 getServletContext(): 获取ServletContext()对象 getServletName(): 获取Servlet配置时声明Web应用内部使用的名字 getInitParameter(String name): 获取Servlet配置时提供的名为name的参数值 HttpServletRequest的常用方法 getRequestURL(): 获取请求的URL地址 getRequestURI(): 获取请求的服务器地址 getContextPath(): 获取Web应用的跟路径 getServletPath(): 获取Servlet的访问路径 getParameter(String name)：获得名为name的参数的单个值 getParameterValues(String name): 获得名为name的参数的多个值 getAttribute(String name): 获得名为name的属性值 setAttribute(String name, String value): 设置名为name的属性值为value getSession():获取session对象 getRequestDispatcher(String path): 获取请求转发对象 HttpServletResponse的常用方法 setContentType(String type): 设置响应的内容类型为type setCharacterEncoding(String charset): 设置响应的编码字符集为charset getWriter(): 返回一个PrintWriter对象 sendRedirect(String location): 向客户端发送一个重定向请求，地址为locationServlet过滤器Servlet过滤器是一种Java组件，它位于客户端与处理程序之间，能够对请求和响应进行检查和修改。Servlet过滤器通常用来完成一些通用的操作，例如同意字符编码，字符压缩、加密、实施安全控制等 Servlet过滤器API Filter接口所有的过滤器都必须实现Filter接口 init() Init 方法在 Filter 生命周期中仅执行一次，web 容器在调用 init 方法时 destory() 在Web容器卸载 Filter 对象之前被调用。该方法在Filter的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。 doFilter() Filter 链的执行 FilterChain接口 调用过滤器链中的下一个过滤器 FilterConfig接口 该接口用于在过滤器初始化阶段提供过滤器名、初始化参数及Servlet上下文等信息，该接口提供以下4个方法 getFilteName(): 返回web.xml文件到中定义的该过滤器名称 getServletContext(): 返回调用者所处的Servlet上下文 getInitParameter(String name): 返回配置过滤器时名为name的初始化参数值 getInitParameterNames(): 以Enumeration形式返回配置过滤器时名为name的初始化参数的名称]]></content>
      <tags>
        <tag>JavaWeb基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android布局你未知的属性]]></title>
    <url>%2F2016%2F07%2F05%2FAndroid%E5%B8%83%E5%B1%80%E4%BD%A0%E6%9C%AA%E7%9F%A5%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[本文是做项目的时候在搭建布局时遇到还未了解的属性的记录，后期遇到会继续完善。 TextView中的ellipsize属性 一般与android:singleLine=”true”使用1234android:ellipsize=”start”—–省略号显示在开头 &quot;...pedia&quot;android:ellipsize=”end”——省略号显示在结尾 &quot;encyc...&quot;android:ellipsize=”middle”—-省略号显示在中间 &quot;en...dia&quot;android:ellipsize=”marquee”–以横向滚动方式显示(需获得当前焦点时) RatingBar的使用 这个属性是必须的android:progressDrawable=&quot;@drawable/process_ratingbar&quot; 查看源码可知，源码地址为SDK–platforms–任意android版本–data–res–drawble–ratingbar_full.xml process_ratingbar.xml 内容如下 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+android:id/background&quot; android:drawable=&quot;@drawable/rating_small_empty&quot; /&gt; &lt;item android:id=&quot;@+android:id/secondaryProgress&quot; android:drawable=&quot;@drawable/rating_small_half&quot; /&gt; &lt;item android:id=&quot;@+android:id/progress&quot; android:drawable=&quot;@drawable/rating_small_full&quot; /&gt;&lt;/layer-list&gt; 在&lt;item android:id=&quot;@+android:id/background&quot; android:drawable=&quot;@drawable/rating_small_empty&quot; /&gt;中系统可能会识别不了，需要选择Disable selector 的属性 android:enterFadeDuration/android:exitFadeDuration (Drawables)此属性在Drawable具有多种状态的时候，可以定义它展示前的淡入淡出效果。12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:enterFadeDuration=&quot;200&quot;&gt; &lt;item android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/list_item_bg_pressed&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/list_item_bg_normal&quot;&gt;&lt;/item&gt;&lt;/selector&gt; ImageView 图片的拉伸处理 通过设置android:scaleType=”fitXY”使得图片拉伸显示。scaleType的属性有matrix（默认）、center、centerCrop、centerInside、fitCenter、fitEnd、fitStart、fitXY。 android:scaleType=”center”保持原图的大小，显示在ImageView的中心。当原图的size大于ImageView的size，超过部分裁剪处理。 android:scaleType=”centerCrop”以填满整个ImageView为目的，将原图的中心对准ImageView的中心，等比例放大原图，直到填满ImageView为止（指的是ImageView的宽和高都要填满），原图超过ImageView的部分作裁剪处理。 android:scaleType=”centerInside”以原图完全显示为目的，将图片的内容完整居中显示，通过按比例缩小原图的size宽(高)等于或小于ImageView的宽(高)。如果原图的size本身就小于ImageView的size，则原图的size不作任何处理，居中显示在ImageView。 android:scaleType=”matrix”不改变原图的大小，从ImageView的左上角开始绘制原图，原图超过ImageView的部分作裁剪处理。 android:scaleType=”fitCenter”把原图按比例扩大或缩小到ImageView的ImageView的高度，居中显示 android:scaleType=”fitEnd”把原图按比例扩大(缩小)到ImageView的高度，显示在ImageView的下部分位置 android:scaleType=”fitStart”把原图按比例扩大(缩小)到ImageView的高度，显示在ImageView的上部分位置 android:scaleType=”fitXY”把原图按照指定的大小在View中显示，拉伸显示图片，不保持原比例，填满ImageView. ListView的item点击事件消失 原因可能是：item中包含了CheckBox 或者Button等控件抢占焦点 解决办法： （1）在ListView 控件下添加如下属性 属性的值有三种： 1234beforeDescendants：viewgroup会优先其子类控件而获取到焦点afterDescendants：viewgroup只有当其子类控件不需要获取焦点时才获取焦点blocksDescendants：viewgroup会覆盖子类控件而直接获得焦点通常我们用到的是第三种，即在Item布局的根布局加上android:descendantFocusability=”blocksDescendants”的属性。 (2)在CheckBox 或者Button等能抢占焦点的控件下，添加如下属性 123android:focusable=&quot;false&quot;android:clickable=&quot;false&quot;android:focusableInTouchMode=&quot;false&quot;]]></content>
      <tags>
        <tag>AndroidLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础学习资源]]></title>
    <url>%2F2016%2F07%2F04%2FAndroid%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[Android这么火你还不学？怎么学？从哪里开始学？ 本篇文章本着开源与奉献的精神,收集了如下的Android学习资源，希望能帮助到各位的同时，自己也有所进步。 在Windows下搭建Android开发环境 开发工具Eclipse + ADT + JDK，推荐教程如下： 搭建Android开发环境 五步搞定Android开发环境部署 由于Google公司推出了新的开发工具，因此现在大牛开发Android大部分都采用AndroidStudio(简称AS)，Eclipse用的也不少，但是以后肯定是AS的天下，所以现在开始使用AS开发Android吧！ AS的搭建 使用Android Studio搭建Android集成开发环境 andriod studio 安装与环境搭建 科学上网（翻墙软件） 由于大天朝对Google的极力支持，所以我们只能顺应大天朝的做法。采取科学上网的方式进行连接Google官网。AndroidSDK的下载就需要翻墙才能下载，虽然也有别人下载好的压缩包，但是有些API会过时了，so,自己选择吧。 下载地址蓝灯 极速模拟器Genymotion Eclipse的模拟器简直就是渣渣，启动速度超级慢，而且很卡，如果你不能忍受就选择Genymotion模拟器吧！ 下载地址 集成到Eclipse中 集成到AS中 集成到AS中出现的问题汇总 AS的完美配置 默认的界面真是太丑了，那么跟着我来搞定它吧！ Android Studio 的安装和配置篇（Windows篇） 第一次使用Android Studio时你应该知道的一切配置 Android学习资源 Android官网(需要科学上网) 中文版Android官网 GitHub 安卓巴士 eoe安卓社区 极客学院 我的技术博客]]></content>
      <tags>
        <tag>Android资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb笔记]]></title>
    <url>%2F2016%2F06%2F21%2FJavaWeb%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近在课设，加上一大波考试来临。整个人都萌比了！这次是软件工程的课设，我们组做的是学生社团信息管理系统，用JavaWeb实现，故现在来总结一下JavaWeb中不易理解的知识吧。以下纯属个人见解，欢迎指教。 HTML123&lt;br&gt;与&lt;p&gt;的区别： &lt;br&gt;强迫到下一行 &lt;p&gt;换行且多产生一行空白 colspan = #(水平合并单元格) rowspan = #(竖直合并单元格) 输入框123&lt;input type = &quot;text,password,Radio,CheckBox,submit,reset&quot;,name = &quot;&quot;,value=&quot;&quot; check&gt;值type 表示输入框的类型​check 用于Radio,CheckBox,表示选中 文本域1&lt;TextArea name=&quot; &quot; rows=&quot;&quot; clos=&quot; &quot;&gt;&lt;/TextArea&gt; 下拉框12&lt;select size=&quot;大小&quot; name=&quot; &quot;&gt;&lt;option select value=&quot;&quot;&gt;显示的值&lt;/option&gt; 表单1&lt;form name =&quot; &quot; method=&quot;post&quot; action=&quot;form.jsp&quot;&gt;&lt;/form&gt; method 表单的提交方式 action 处理请求的文件，此处有时也用onSubmit=”return check()”, 表示提交给JavaScript校验，check()为JavaScript的函数名 name 里面的值可以调用form中的所有name属性 CSSCSS语句格式选择符{ 属性：值}例如：123a&#123; color:green&#125;h1&#123; font-family:&quot;Courier New&quot;&#125;p&#123;font-size:15;color:red&#125; CSS选择符1有三种：优先级如下：HTML选择符 &lt; CLASS选择符 &lt; ID选择符 HTML选择符如下123p&#123;font-size:15;color:red&#125;h1&#123;text-align:center;color:red&#125;div p&#123;color:red;font-size:12;&#125; //多个选择符用空格隔开 CLASS选择符如下123451、&lt;p class=&quot;stop&quot;&gt;这是stop的样式&lt;/p&gt; p.stop&#123;color:red&#125;2、&lt;p class=&quot;stop&quot;&gt;这是stop的样式&lt;/p&gt;&lt;style type=&quot;text/css&quot;&gt; .stop&#123;color:red&#125; //注意前面的小点&lt;/style&gt; ID选择符如下1234&lt;div id=&quot;title&quot;&gt;welcome to neusoft&lt;/div&gt;&lt;style type=&quot;text/css&quot;&gt; #title&#123;color:red&#125;&lt;/style&gt; CSS设置方式 内联样式 123&lt;body&gt; &lt;h1 style=&quot;font-family:黑体&quot;&gt;hello&lt;/h1&gt;&lt;/body&gt; 嵌入样式 12345678&lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; h1&#123;font-family:黑体&#125; &lt;style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello&lt;/h1&gt;&lt;/body&gt; 外部样式 12345678&lt;head&gt; &lt;link rel = &quot;stylesheet&quot; href=&quot;h1.css&quot; type=&quot;text/css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello&lt;/h1&gt;&lt;/body&gt;h1.cssh1&#123;font-family:黑体&#125; 伪元素选择符选择符：伪元素{值}例如：1234567a:hover&#123;color:red&#125;//鼠标指针在超链接上悬停，超链接显示红色以下为超链接标签&lt;a&gt;的4种伪元素的含义1、a:active 表示超链接选中的状态2、a:hover 鼠标移动到超链接上的状态3、a:link 表示超链接的正常状态4、a:visited 表示访问过的超链接的状态 JavaScriptJavaScript支持的对象 常用的window document history location等 内置对象String Math Date等 String对象 创建方式有两种 123str = &quot;hello&quot; ;str2 = new String(&quot;hello&quot;) ;String对象的属性只有length String常用方法 121、charAt() 返回指定位置上的字符（长度为1的字符串）2、indexOf()返回某个指定的字符串值在字符串中首次出现的位置 document对象 常用的属性 1231、forms[] form对象数组，每一个元素对应与文档中的一个HTML&lt;form&gt;标记2、links[] link对象数组，每一个元素对应与文档中的一个HTML&lt;a href&gt;标记 常用方法 1234561、alter() 创建一个具有OK按钮的对话框2、confirm() 提供一个具有两个按钮的对话框3、prompt() 允许用户在对话框中输入信息，并可使用默认信息，格式如下： prompt(&quot;提示信息&quot;,默认值)4、document.write() 将文本信息直接输出到浏览器窗口中5、document.writeln() 将文本信息换行直接输出到浏览器窗口中 window对象 常用属性 12341、closed 窗口是否关闭2、document3、history4、location 常用方法 1234561、alter(&quot;显示信息&quot;)2、confirm() 带有确认信息的窗口，并有“确定”和“取消”按钮3、focus() 使本窗口获取焦点4、open() 打开新窗口5、prompt(&quot;信息&quot;,默认信息)6、close() 关闭当前窗口 将JavaScript代码添加到HTML文件中 格式123451、&lt;script language=&quot;JavaScript&quot; src=&quot;&quot;&gt; JavaScript代码; &lt;/script&gt;2、&lt;script src=&quot;body.js&quot;&gt;&lt;/script&gt; src表示JavaScript的源文件的路径 JSP基本语法 JSP的基本规范 脚本元素：声明，脚本段，表达式 注释元素：HTML，Java，JSP隐式注释 指令元素：page，include，taglib等 动作元素：jsp.include,jsp.forward,jsp,userBean等 JSP脚本元素 脚本段的使用语法如下：1&lt;%合法的Java代码段%&gt; 脚本段能完成的功能： 12341、声明将要用到的局部变量2、使用out对象显示输出信息 out.write(&quot;hello&quot;);3、使用JSP的任何内置对象的任何声明过的对象4、当JSP页面接收到客户端请求时，脚本段就会自动执行 声明语法格式如下： 1&lt;%! 声明1;声明2;...%&gt; 声明的变量是全局变量，这些变量的内存空间直到服务器关闭才释放 表达式的语法格式如下： 1&lt;% =符合Java语法的不完整的Java语句(结尾不带分号)%&gt; EL表达式的使用格式如下： 1$&#123;expr&#125;; 指令元素 格式如下： 1&lt;%@ 指令名 属性1=”值1“ 属性2=”值2“ ...%&gt; page指令语法格式如下： 1&lt;%@ page 属性1=”值1“ 属性2=”值2“ ...%&gt; page指令的属性有： language import contenType pageEncoding session bufffer autoFlush isThreadSafe info errorPage isELIgnored等，import contenType可以指定多次，其他属性只能指定一个值，否则会导致转换错误 info属性用来指定有关页面的描述信息， 在JSP页面可以使用getServletInfo()方法获取 buffer属性的值取值为”none“时，autoFlush属性的值就必须设置为true taglib指令的语法格式如下： 1&lt;%@ taglib uri=&quot;标记库的uri地址&quot; prefix=”前缀名“ %&gt; 动作元素 12345678910&lt;jsp:include&gt;和&lt;jsp:param&gt;&lt;jsp:include&gt;动作元素用于当前页面中包含其他文件&lt;jsp:param&gt;子动作用于向被包含的动态页面中传递参数，使用”键-值“对的形式&lt;jsp:forward&gt;动作元素用于运行时在服务器端结束当前页面的执行并从当前页面转向指定的页面语法如下：&lt;jsp:forward page=&quot;目标页面的URL&quot;/&gt;]]></content>
      <tags>
        <tag>JavaWeb基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令记录]]></title>
    <url>%2F2016%2F06%2F17%2Fgit%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[粗略记录一下git命令，后期使用过程中会逐渐完善这些命令 查看日志的炫酷命令 原来的日志输入git log，如果日志太多可以输入q或者qw或者ctrl+c，我也记不住了，就是这几个命令就可以关闭日志输出了 1git log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset%s %Cgreen(%cr)%C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --date=relative 炫酷的效果 开启git输出着色1git config --global color.ui true 设置显示中文文件名1git config --global core.quotepath false 修改git的编辑器 git默认的编辑器是vi，可以用下面代码修改编辑器为Vim，前提是本机有安装Vim1git config --global core.editor &quot;vim&quot; diff 查看代码的改动123git diff &lt;$id1&gt;&lt;$id2&gt;#比较两次提交的差异git diff &lt;branch1&gt;..&lt;branch2&gt;#比较两个分支的差异git diff --staged#比较暂缓区与版本库的差异 checkout 切换分支的作用 1git checkout develop 撤销的作用(把原文件还原) 1git checkout a.md 注：checkout命令只能撤销还没add进缓存区的文件 stash 使用情景：当开发新功能时，突然有个紧急的Bug需要解决，但是还未commit，因为每一次commit我们都要有明确的意义，这时我们可以用如下办法： 把当前分支所有没有commit的代码先暂缓起来 1git stash 此时输入git status你会发现当前分支很干净，因为暂时缓存起来了 git status list你会发现暂缓区有一天记录 还原之前的代码git stash apply,你会发现之前的代码都还原回来了，紧接着你最好需要把缓存区的这次stash记录删除 执行git stash drop即可删除最近的一条记录 其实还有更方便的方法把git stash apply和git stash drop一起执行了那就是git stash pop 清空缓存区的记录git stash clear 分支合并merge&amp;rebase 将a分支合并到master分支 12git checkout mastergit merge a merge和rebase的区别 merge比较暴力，内容不会重新排序，但是可以知道内容来源与哪个分支 rebase合并起来会重新排序，但是不知道内容来源与哪个分支 各有好处，按使用习惯选择 人生精神领袖——stormzhang]]></content>
      <tags>
        <tag>Git命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GooglePlay项目第一天笔记]]></title>
    <url>%2F2016%2F06%2F13%2FGooglePlay-1%2F</url>
    <content type="text"><![CDATA[GooglePlay项目第一天笔记，主要介绍了ActionBar的使用，以及DrawerLayout 抽屉菜单的实现等。 ActionBar 从 Android3.0 开始谷歌推荐使用 这里暂时不讨论低版本兼容问题 Eclipse 引用v7-appcompat Activity继承ActionBarActivity android:theme=”@style/Theme.AppCompat.Light” &gt; AS AS中的SDK是最新的，默认是继承了ActionBarAtivity，所以不用引入v7库 Activity继承ActionBarActivity android:theme=”@style/Theme.AppCompat.Light” ActionBar中的搜索按钮 Eclipse 在menu目录下添加如下代码 &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:dongxi=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;!-- Search, should appear as action button --&gt; &lt;item android:id=&quot;@+id/action_search&quot; android:icon=&quot;@drawable/ic_action_search&quot; android:title=&quot;@string/action_search&quot; dongxi:showAsAction=&quot;ifRoom&quot; dongxi:actionViewClass=&quot;android.support.v7.widget.SearchView&quot; /&gt; &lt;/menu&gt; 在继承ActionBar的类中实现以下方法 /* 处理actionBar菜单条目的点击事件 / public boolean onOptionsItemSelected(MenuItem item) { if (item.getItemId() == R.id.action_search) { Toast.makeText(getApplicationContext(), &quot;搜索&quot;, Toast.LENGTH_SHORT).show(); } return drawerToggle.onOptionsItemSelected(item)|super.onOptionsItemSelected(item); } // 当搜索提交的时候 @Override public boolean onQueryTextSubmit(String query) { Toast.makeText(getApplicationContext(), query, Toast.LENGTH_SHORT).show(); return true; } // 当搜索的文本发生变化 @Override public boolean onQueryTextChange(String newText) { return true; } AS 由于AS中没有menu目录，所以需要在res下创建一个menu目录 实现步骤同Eclipse，这里就不重复写了 ActionBar中返回按钮的处理（AS） 在activity中处理 添加如下代码actionBar = getSupportActionBar();//可以向下兼容12actionBar.setDisplayHomeAsUpEnabled(true);//设置图片显示actionBar.setHomeButtonEnabled(true);//设置图片可以点击 在AndroidManifest文件中处理 android:name=".DetailActivity"12345678 android:label=&quot;@string/app_detail&quot; android:parentActivityName=&quot;.MainActivity&quot;&gt; //返回的上一个Activity&lt;meta-data android:name=&quot;android.support.PARENT_ACTIVITY&quot; android:value=&quot;.MainActivity&quot; /&gt;&lt;/activity&gt; ActionBar Tab标签的实现 在drawable目录下新建一个标签的状态选择器 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- 标签没被选中的样式 --&gt; &lt;!-- Non focused states --&gt; &lt;item android:state_focused=&quot;false&quot; android:state_selected=&quot;false&quot; android:state_pressed=&quot;false&quot; android:drawable=&quot;@drawable/tab_unselected&quot; /&gt; &lt;item android:state_focused=&quot;false&quot; android:state_selected=&quot;true&quot; android:state_pressed=&quot;false&quot; android:drawable=&quot;@drawable/tab_selected&quot; /&gt; &lt;!-- Focused states (such as when focused with a d-pad or mouse hover) --&gt; &lt;item android:state_focused=&quot;true&quot; android:state_selected=&quot;false&quot; android:state_pressed=&quot;false&quot; android:drawable=&quot;@drawable/tab_unselected_focused&quot; /&gt; &lt;item android:state_focused=&quot;true&quot; android:state_selected=&quot;true&quot; android:state_pressed=&quot;false&quot; android:drawable=&quot;@drawable/tab_selected_focused&quot; /&gt; &lt;!-- 标签被选中的样式 --&gt; &lt;!-- 非聚焦状态 --&gt; &lt;item android:state_focused=&quot;false&quot; android:state_selected=&quot;false&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/tab_unselected_pressed&quot; /&gt; &lt;item android:state_focused=&quot;false&quot; android:state_selected=&quot;true&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/tab_selected_pressed&quot; /&gt; &lt;!-- 聚焦状态 (例如当用方向键或鼠标悬停于) --&gt; &lt;item android:state_focused=&quot;true&quot; android:state_selected=&quot;false&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/tab_unselected_pressed&quot; /&gt; &lt;item android:state_focused=&quot;true&quot; android:state_selected=&quot;true&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/tab_selected_pressed&quot; /&gt; &lt;/selector&gt; 实现自定义主题 12345678910111213&lt;resources&gt;&lt;style name=&quot;CustomActionBarTheme&quot; //自定义主题名 parent=&quot;@style/Theme.AppCompat.Light&quot;&gt;//继承的ActionBar背景 &lt;item name=&quot;android:actionBarTabStyle&quot;&gt;@style/MyActionBarTabs&lt;/item&gt; &lt;item name=&quot;actionBarTabStyle&quot;&gt;@style/MyActionBarTabs&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;MyActionBarTabs&quot; parent=&quot;@style/Widget.AppCompat.ActionBar.TabView&quot;&gt; &lt;item name=&quot;android:background&quot;&gt;@drawable/actionbar_tab_indicator&lt;/item&gt;//状态选择器 &lt;item name=&quot;background&quot;&gt;@drawable/actionbar_tab_indicator&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; 在代码里添加标签 1234ActionBar actionBar = getSupportActionBar();actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);Tab tab1=actionBar.newTab().setText(&quot;标签一&quot;).setTabListener(new MyTabListener());actionBar.addTab(tab1); DrawerLayout和SlidingMenu的对比 抽屉菜单（DrawerLayout）优点 DrawerLayout稳定可靠，使用起来更简单一点； 抽屉菜单（DrawerLayout）缺点 个人见解不一定完全正确，欢迎指导 抽屉的大小不好控制（据说可用ListView实现抽屉，可以参考官方文档） 侧滑菜单的优点，缺点 正好和DrawerLayout相反 总结： 根据不同情况使用不同的控件 SlidingMenu因为很容易实现的，而且好控制 DrawerLayout使用方便，代码实现较SlidingMenu简单 DrawerLayout 抽屉菜单的实现 保证V4包下有这个类123456789101112131415161718192021&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:id=&quot;@+id/dl&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; /&gt; &lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/bg_tab&quot; android:layout_gravity=&quot;left&quot;&gt; &lt;/FrameLayout&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; ActionBarDrawerToggle 抽屉菜单的开关 控制抽屉的开关，在actionbar的上面123456789101112131415161718192021222324252627ActionBar actionBar = getSupportActionBar();actionBar.setDisplayHomeAsUpEnabled(true);actionBar.setHomeButtonEnabled(true);/* * 参数1）显示Navigation Drawer的 Activity 对象 参数2） DrawerLayout 对象 参数3）一个用来指示Navigation Drawer的 drawable资源 参数4）一个用来描述打开Navigation Drawer的文本 (用于支持可访问性)。 参数5）一个用来描述关闭Navigation Drawer的文本(用于支持可访问性). */drawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, R.drawable.ic_drawer_am, R.string.open_drawer, R.string.close_drawer);mDrawerLayout.setDrawerListener(drawerToggle);// 让开关和actionbar建立关系 drawerToggle.syncState();/** 处理actionBar菜单条目的点击事件 */public boolean onOptionsItemSelected(MenuItem item) &#123; if (item.getItemId() == R.id.action_search) &#123; Toast.makeText(getApplicationContext(), &quot;搜索&quot;, 0).show(); &#125; return drawerToggle.onOptionsItemSelected(item)|super.onOptionsItemSelected(item);&#125; BaseApplication extendes Application 需要在AndroidManifest中配置 添加这个属性 android:name=”BaseApplication”123456789101112&lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/CustomActionBarTheme&quot; android:name=&quot;BaseApplication&quot;&gt;//添加&lt;activity android:name=&quot;.MainActivity&quot;&gt;&lt;intent-filter&gt;&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&lt;/intent-filter&gt;&lt;/activity&gt;]]></content>
      <tags>
        <tag>GooglePlay项目笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客个性化搭建]]></title>
    <url>%2F2016%2F06%2F12%2FBolg-With-Hexo%2F</url>
    <content type="text"><![CDATA[原先的博客使用的是Jekyll搭建，但是发现Hexo更炫酷一些，故现在改为Hexo,目前还未完善，待有时间会完善。 感谢以下作者如何搭建博客 小白手把手搭建博客 动动手指，NexT主题与Hexo更搭哦（基础篇） 添加背景音乐 打开网页版网易云音乐。 如果只是加入单曲，只需要搜索歌曲，点开歌曲名，点击生成外链播放器，复制html代码（可以选择是否自动播放），将html代码无需任何修改放入markdown文章里就OK了。如果想要加入歌单，就需要自己创建歌单，然后分享歌单，找到自己的分享动态，点进去可以看到有“生成外链播放器”这些字眼，其余操作就和上面一样了。不过，你的歌单有变化的话，这个外链的歌曲同样跟着变，这一点挺棒的。例如，播放待你长发及腰这首歌，自动播放只需要嵌入一下代码(现在好像不支持了)1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;http://music.163.com/outchain/player?type=2&amp;id=28947001&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; 嵌入不自动播放只需要把以上代码中的auto改为=0即可，样子是这样的类似方法还可以嵌入虾米播播 添加视频 另外，markdown完全兼容html，你可以用html插入这些东西，例如：(现在好像不支持了) 1&lt;iframe height=498 width=510 src=&quot;http://player.youku.com/embed/XMjI2MjU3MDMy&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt; 参数解释 123src=&quot;&quot;: 视频路径frameborder：设置或返回是否显示框架周围的边框allowfullscreen: 允许全屏=true。也就是允许全屏,=false时表示不允许全屏 添加阅读全文按钮 用markdown编辑的时候在适当的位置加入&lt;!--more--&gt;即可 Hexo NexT主题首标题的优化 更改index.swig文件，文件路径是your-hexo-site\themes\next\layout将下面代码 不知道什么原因，我只要将下面的代码除去就部署不上去…所以大家就找到下面的除去的代码段，然后改成如下即可。 改成 添加最近访客 首先需要开通多说的评论功能，可以参考这里 接着添加如下代码到文章底部(你喜欢在哪添加都行，一般在底部显示) 12345&lt;blockquote class=&quot;blockquote-center&quot;&gt;来了就打个招呼呗！&lt;/blockquote&gt;&lt;br/&gt;&gt;最近访客&lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;28&quot; data-avatar-size=&quot;42&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt; 参数解释1234class=“ds-recent-visitors” //指定显示最近访客容器data-num-items=“28” //显示最近访客的数量data-avatar-size=“42” //显示最近访客头像尺寸大小id=“ds-recent-visitors” //为了调节最近访客样式加的 Git push(Hexo g -d)时重复输入用户名密码的问题 首先添加环境变量。在用户变量中新建如下内容 12变量名：HOME变量值：%USERPROFILE% 在用户文件夹如C:\Users\用户名下新建一个名为_netrc的文件。 编辑该文件：内容如下 123machine github.comlogin GitHub的用户名password GitHub的密码 保存。]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F06%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
